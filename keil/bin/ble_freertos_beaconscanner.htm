<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html><head>
<title>Static Call Graph - [.\bin\ble_freertos_beaconscanner.axf]</title></head>
<body><HR>
<H1>Static Call Graph for image .\bin\ble_freertos_beaconscanner.axf</H1><HR>
<BR><P>#&#060CALLGRAPH&#062# ARM Linker, 5060750: Last Updated: Thu Mar 26 10:35:17 2020
<BR><P>
<H3>Maximum Stack Usage =        940 bytes + Unknown(Cycles, Untraceable Function Pointers)</H3><H3>
Call chain for Maximum Stack Depth:</H3>
smprScActCalcDHKey &rArr; smpScActCalcSharedSecret &rArr; SecEccGenSharedSecret &rArr; uECC_shared_secret &rArr; EccPoint_mult &rArr; XYcZ_initial_double &rArr; EccPoint_double_jacobian &rArr; vli_modSquare_fast &rArr; vli_square &rArr; mul2add
<P>
<H3>
Mutually Recursive functions
</H3> <LI><a href="#[10]">NMI_Handler</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[10]">NMI_Handler</a><BR>
 <LI><a href="#[12]">MemManage_Handler</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[12]">MemManage_Handler</a><BR>
 <LI><a href="#[13]">BusFault_Handler</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[13]">BusFault_Handler</a><BR>
 <LI><a href="#[14]">UsageFault_Handler</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[14]">UsageFault_Handler</a><BR>
 <LI><a href="#[15]">SecureFault_Handler</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[15]">SecureFault_Handler</a><BR>
 <LI><a href="#[17]">DebugMon_Handler</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[17]">DebugMon_Handler</a><BR>
 <LI><a href="#[2c]">am_adc_isr</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[2c]">am_adc_isr</a><BR>
</UL>
<P>
<H3>
Function Pointers
</H3><UL>
 <LI><a href="#[66]">AppHandler</a> from app_main.o(i.AppHandler) referenced from radio_task.o(i.exactle_stack_init)
 <LI><a href="#[44]">AppServerConnCback</a> from app_server.o(i.AppServerConnCback) referenced from beaconscanner_main.o(i.BeaconScannerStart)
 <LI><a href="#[64]">AttHandler</a> from att_main.o(i.AttHandler) referenced from radio_task.o(i.exactle_stack_init)
 <LI><a href="#[67]">BeaconScannerHandler</a> from beaconscanner_main.o(i.BeaconScannerHandler) referenced from radio_task.o(i.exactle_stack_init)
 <LI><a href="#[13]">BusFault_Handler</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[17]">DebugMon_Handler</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[62]">DmHandler</a> from dm_main.o(i.DmHandler) referenced from radio_task.o(i.exactle_stack_init)
 <LI><a href="#[11]">HardFault_Handler</a> from am_util_faultisr.o(.emb_text) referenced from startup_keil.o(RESET)
 <LI><a href="#[69]">HciDrvHandler</a> from hci_drv_apollo3.o(i.HciDrvHandler) referenced from radio_task.o(i.exactle_stack_init)
 <LI><a href="#[61]">HciHandler</a> from hci_main.o(i.HciHandler) referenced from radio_task.o(i.exactle_stack_init)
 <LI><a href="#[63]">L2cSlaveHandler</a> from l2c_slave.o(i.L2cSlaveHandler) referenced from radio_task.o(i.exactle_stack_init)
 <LI><a href="#[12]">MemManage_Handler</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[10]">NMI_Handler</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[18]">PendSV_Handler</a> from port.o(.emb_text) referenced from startup_keil.o(RESET)
 <LI><a href="#[6c]">RadioTask</a> from radio_task.o(i.RadioTask) referenced from rtos.o(i.setup_task)
 <LI><a href="#[f]">Reset_Handler</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[16]">SVC_Handler</a> from port.o(.emb_text) referenced from startup_keil.o(RESET)
 <LI><a href="#[51]">SecAesHciCback</a> from sec_aes.o(i.SecAesHciCback) referenced from sec_aes.o(i.SecAesInit)
 <LI><a href="#[52]">SecCmacHciCback</a> from sec_cmac_hci.o(i.SecCmacHciCback) referenced from sec_cmac_hci.o(i.SecCmacInit)
 <LI><a href="#[15]">SecureFault_Handler</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[65]">SmpHandler</a> from smp_main.o(i.SmpHandler) referenced from radio_task.o(i.exactle_stack_init)
 <LI><a href="#[19]">SysTick_Handler</a> from port.o(i.SysTick_Handler) referenced from startup_keil.o(RESET)
 <LI><a href="#[14]">UsageFault_Handler</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[5d]">WsfTimer_handler</a> from wsf_timer.o(i.WsfTimer_handler) referenced from wsf_timer.o(i.WsfTimerInit)
 <LI><a href="#[129]">__main</a> from __main.o(!!!main) referenced from startup_keil.o(RESET)
 <LI><a href="#[2c]">am_adc_isr</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[26]">am_ble_isr</a> from radio_task.o(i.am_ble_isr) referenced from startup_keil.o(RESET)
 <LI><a href="#[1a]">am_brownout_isr</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[39]">am_clkgen_isr</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[28]">am_ctimer_isr</a> from rtos.o(i.am_ctimer_isr) referenced from startup_keil.o(RESET)
 <LI><a href="#[27]">am_gpio_isr</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[5e]">am_hal_itm_print</a> from am_hal_itm.o(i.am_hal_itm_print) referenced from am_bsp.o(i.am_bsp_itm_printf_enable)
 <LI><a href="#[20]">am_iomaster0_isr</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[21]">am_iomaster1_isr</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[22]">am_iomaster2_isr</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[23]">am_iomaster3_isr</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[24]">am_iomaster4_isr</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[25]">am_iomaster5_isr</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[1f]">am_ioslave_acc_isr</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[1e]">am_ioslave_ios_isr</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[2e]">am_mspi0_isr</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[2d]">am_pdm0_isr</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[1c]">am_rtc_isr</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[2b]">am_scard_isr</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[2f]">am_software0_isr</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[31]">am_stimer_cmpr0_isr</a> from port.o(i.am_stimer_cmpr0_isr) referenced from startup_keil.o(RESET)
 <LI><a href="#[32]">am_stimer_cmpr1_isr</a> from port.o(i.am_stimer_cmpr1_isr) referenced from startup_keil.o(RESET)
 <LI><a href="#[33]">am_stimer_cmpr2_isr</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[34]">am_stimer_cmpr3_isr</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[35]">am_stimer_cmpr4_isr</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[36]">am_stimer_cmpr5_isr</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[37]">am_stimer_cmpr6_isr</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[38]">am_stimer_cmpr7_isr</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[30]">am_stimer_isr</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[2a]">am_uart1_isr</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[29]">am_uart_isr</a> from radio_task.o(i.am_uart_isr) referenced from startup_keil.o(RESET)
 <LI><a href="#[1d]">am_vcomp_isr</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[1b]">am_watchdog_isr</a> from startup_keil.o(RESET) referenced from startup_keil.o(RESET)
 <LI><a href="#[3b]">appMasterProcMsg</a> from app_master.o(i.appMasterProcMsg) referenced from app_master.o(i.AppMasterInit)
 <LI><a href="#[60]">appSlaveLegAdvRestart</a> from app_slave_leg.o(i.appSlaveLegAdvRestart) referenced from app_slave_leg.o(i.appSlaveAdvMode)
 <LI><a href="#[5f]">appSlaveLegAdvStop</a> from app_slave_leg.o(i.appSlaveLegAdvStop) referenced from app_slave_leg.o(i.appSlaveAdvMode)
 <LI><a href="#[3c]">appSlaveProcMsg</a> from app_slave.o(i.appSlaveProcMsg) referenced from app_slave.o(i.AppSlaveInit)
 <LI><a href="#[3f]">attDmConnCback</a> from att_main.o(i.attDmConnCback) referenced from att_main.o(i.AttHandlerInit)
 <LI><a href="#[b8]">attEmptyConnCback</a> from att_main.o(i.attEmptyConnCback) referenced from att_main.o(.constdata)
 <LI><a href="#[b0]">attEmptyDataCback</a> from att_main.o(i.attEmptyDataCback) referenced 2 times from atts_ind.o(.constdata)
 <LI><a href="#[41]">attEmptyHandler</a> from att_main.o(i.attEmptyHandler) referenced 2 times from att_main.o(.constdata)
 <LI><a href="#[41]">attEmptyHandler</a> from att_main.o(i.attEmptyHandler) referenced from atts_main.o(i.AttsInit)
 <LI><a href="#[3d]">attL2cCtrlCback</a> from att_main.o(i.attL2cCtrlCback) referenced from att_main.o(i.AttHandlerInit)
 <LI><a href="#[3e]">attL2cDataCback</a> from att_main.o(i.attL2cDataCback) referenced from att_main.o(i.AttHandlerInit)
 <LI><a href="#[a2]">attcConnCback</a> from attc_main.o(i.attcConnCback) referenced from attc_main.o(.constdata)
 <LI><a href="#[a0]">attcCtrlCback</a> from attc_main.o(i.attcCtrlCback) referenced from attc_main.o(.constdata)
 <LI><a href="#[9f]">attcDataCback</a> from attc_main.o(i.attcDataCback) referenced from attc_main.o(.constdata)
 <LI><a href="#[a1]">attcMsgCback</a> from attc_main.o(i.attcMsgCback) referenced from attc_main.o(.constdata)
 <LI><a href="#[a8]">attcProcErrRsp</a> from attc_proc.o(i.attcProcErrRsp) referenced from attc_proc.o(.constdata)
 <LI><a href="#[ab]">attcProcFindByTypeRsp</a> from attc_read.o(i.attcProcFindByTypeRsp) referenced from attc_proc.o(.constdata)
 <LI><a href="#[aa]">attcProcFindOrReadRsp</a> from attc_proc.o(i.attcProcFindOrReadRsp) referenced 3 times from attc_proc.o(.constdata)
 <LI><a href="#[a9]">attcProcMtuRsp</a> from attc_proc.o(i.attcProcMtuRsp) referenced from attc_proc.o(.constdata)
 <LI><a href="#[af]">attcProcPrepWriteRsp</a> from attc_write.o(i.attcProcPrepWriteRsp) referenced from attc_proc.o(.constdata)
 <LI><a href="#[ad]">attcProcReadLongRsp</a> from attc_read.o(i.attcProcReadLongRsp) referenced from attc_proc.o(.constdata)
 <LI><a href="#[ac]">attcProcReadRsp</a> from attc_proc.o(i.attcProcReadRsp) referenced 2 times from attc_proc.o(.constdata)
 <LI><a href="#[ae]">attcProcWriteRsp</a> from attc_proc.o(i.attcProcWriteRsp) referenced 2 times from attc_proc.o(.constdata)
 <LI><a href="#[a4]">attcSendContinuingReq</a> from attc_main.o(i.attcSendContinuingReq) referenced 5 times from attc_main.o(.constdata)
 <LI><a href="#[a3]">attcSendMtuReq</a> from attc_main.o(i.attcSendMtuReq) referenced from attc_main.o(.constdata)
 <LI><a href="#[a7]">attcSendPrepWriteReq</a> from attc_main.o(i.attcSendPrepWriteReq) referenced from attc_main.o(.constdata)
 <LI><a href="#[a5]">attcSendSimpleReq</a> from attc_main.o(i.attcSendSimpleReq) referenced 4 times from attc_main.o(.constdata)
 <LI><a href="#[a6]">attcSendWriteCmd</a> from attc_main.o(i.attcSendWriteCmd) referenced from attc_main.o(.constdata)
 <LI><a href="#[40]">attsCccMainCback</a> from atts_ccc.o(i.attsCccMainCback) referenced from atts_ccc.o(i.AttsCccRegister)
 <LI><a href="#[b7]">attsConnCback</a> from atts_main.o(i.attsConnCback) referenced from atts_main.o(.constdata)
 <LI><a href="#[b4]">attsDataCback</a> from atts_main.o(i.attsDataCback) referenced from atts_main.o(.constdata)
 <LI><a href="#[b3]">attsIndConnCback</a> from atts_ind.o(i.attsIndConnCback) referenced from atts_ind.o(.constdata)
 <LI><a href="#[b1]">attsIndCtrlCback</a> from atts_ind.o(i.attsIndCtrlCback) referenced from atts_ind.o(.constdata)
 <LI><a href="#[b2]">attsIndMsgCback</a> from atts_ind.o(i.attsIndMsgCback) referenced from atts_ind.o(.constdata)
 <LI><a href="#[b5]">attsL2cCtrlCback</a> from atts_main.o(i.attsL2cCtrlCback) referenced from atts_main.o(.constdata)
 <LI><a href="#[b6]">attsMsgCback</a> from atts_main.o(i.attsMsgCback) referenced from atts_main.o(.constdata)
 <LI><a href="#[d]">attsProcExecWriteReq</a> from atts_write.o(i.attsProcExecWriteReq) referenced 2 times from atts_main.o(.data)
 <LI><a href="#[4]">attsProcFindInfoReq</a> from atts_proc.o(i.attsProcFindInfoReq) referenced 2 times from atts_main.o(.data)
 <LI><a href="#[5]">attsProcFindTypeReq</a> from atts_read.o(i.attsProcFindTypeReq) referenced 2 times from atts_main.o(.data)
 <LI><a href="#[3]">attsProcMtuReq</a> from atts_proc.o(i.attsProcMtuReq) referenced 2 times from atts_main.o(.data)
 <LI><a href="#[c]">attsProcPrepWriteReq</a> from atts_write.o(i.attsProcPrepWriteReq) referenced 2 times from atts_main.o(.data)
 <LI><a href="#[8]">attsProcReadBlobReq</a> from atts_read.o(i.attsProcReadBlobReq) referenced 2 times from atts_main.o(.data)
 <LI><a href="#[a]">attsProcReadGroupTypeReq</a> from atts_read.o(i.attsProcReadGroupTypeReq) referenced 2 times from atts_main.o(.data)
 <LI><a href="#[9]">attsProcReadMultReq</a> from atts_read.o(i.attsProcReadMultReq) referenced 2 times from atts_main.o(.data)
 <LI><a href="#[7]">attsProcReadReq</a> from atts_proc.o(i.attsProcReadReq) referenced 2 times from atts_main.o(.data)
 <LI><a href="#[6]">attsProcReadTypeReq</a> from atts_read.o(i.attsProcReadTypeReq) referenced 2 times from atts_main.o(.data)
 <LI><a href="#[e]">attsProcValueCnf</a> from atts_ind.o(i.attsProcValueCnf) referenced 2 times from atts_main.o(.data)
 <LI><a href="#[b]">attsProcWrite</a> from atts_write.o(i.attsProcWrite) referenced 4 times from atts_main.o(.data)
 <LI><a href="#[43]">beaconScannerAttCback</a> from beaconscanner_main.o(i.beaconScannerAttCback) referenced from beaconscanner_main.o(i.BeaconScannerStart)
 <LI><a href="#[46]">beaconScannerBtnCback</a> from beaconscanner_main.o(i.beaconScannerBtnCback) referenced from beaconscanner_main.o(i.BeaconScannerStart)
 <LI><a href="#[45]">beaconScannerCccCback</a> from beaconscanner_main.o(i.beaconScannerCccCback) referenced from beaconscanner_main.o(i.BeaconScannerStart)
 <LI><a href="#[47]">beaconScannerDiscCback</a> from beaconscanner_main.o(i.beaconScannerDiscCback) referenced from beaconscanner_main.o(i.BeaconScannerStart)
 <LI><a href="#[42]">beaconScannerDmCback</a> from beaconscanner_main.o(i.beaconScannerDmCback) referenced from beaconscanner_main.o(i.BeaconScannerStart)
 <LI><a href="#[48]">beaconScannerIasWriteCback</a> from beaconscanner_main.o(i.beaconScannerIasWriteCback) referenced from beaconscanner_main.o(i.BeaconScannerStart)
 <LI><a href="#[68]">button_handler</a> from radio_task.o(i.button_handler) referenced from radio_task.o(i.exactle_stack_init)
 <LI><a href="#[2]">default_RNG</a> from uecc.o(i.default_RNG) referenced 2 times from uecc.o(.data)
 <LI><a href="#[be]">dmAdvActClearSets</a> from dm_adv_leg.o(i.dmAdvActClearSets) referenced from dm_adv_leg.o(.constdata)
 <LI><a href="#[b9]">dmAdvActConfig</a> from dm_adv_leg.o(i.dmAdvActConfig) referenced from dm_adv_leg.o(.constdata)
 <LI><a href="#[bd]">dmAdvActRemoveSet</a> from dm_adv_leg.o(i.dmAdvActRemoveSet) referenced from dm_adv_leg.o(.constdata)
 <LI><a href="#[ba]">dmAdvActSetData</a> from dm_adv_leg.o(i.dmAdvActSetData) referenced from dm_adv_leg.o(.constdata)
 <LI><a href="#[bf]">dmAdvActSetRandAddr</a> from dm_adv_leg.o(i.dmAdvActSetRandAddr) referenced from dm_adv_leg.o(.constdata)
 <LI><a href="#[bb]">dmAdvActStart</a> from dm_adv_leg.o(i.dmAdvActStart) referenced from dm_adv_leg.o(.constdata)
 <LI><a href="#[bc]">dmAdvActStop</a> from dm_adv_leg.o(i.dmAdvActStop) referenced from dm_adv_leg.o(.constdata)
 <LI><a href="#[c0]">dmAdvActTimeout</a> from dm_adv_leg.o(i.dmAdvActTimeout) referenced from dm_adv_leg.o(.constdata)
 <LI><a href="#[c2]">dmAdvHciHandler</a> from dm_adv_leg.o(i.dmAdvHciHandler) referenced from dm_adv_leg.o(.constdata)
 <LI><a href="#[c3]">dmAdvMsgHandler</a> from dm_adv_leg.o(i.dmAdvMsgHandler) referenced from dm_adv_leg.o(.constdata)
 <LI><a href="#[c1]">dmAdvReset</a> from dm_adv_leg.o(i.dmAdvReset) referenced from dm_adv_leg.o(.constdata)
 <LI><a href="#[ce]">dmConn2HciHandler</a> from dm_conn.o(i.dmConn2HciHandler) referenced from dm_conn.o(.constdata)
 <LI><a href="#[cf]">dmConn2MsgHandler</a> from dm_conn.o(i.dmConn2MsgHandler) referenced from dm_conn.o(.constdata)
 <LI><a href="#[cb]">dmConnHciHandler</a> from dm_conn.o(i.dmConnHciHandler) referenced from dm_conn.o(.constdata)
 <LI><a href="#[cc]">dmConnMsgHandler</a> from dm_conn.o(i.dmConnMsgHandler) referenced from dm_conn.o(.constdata)
 <LI><a href="#[ca]">dmConnReset</a> from dm_conn.o(i.dmConnReset) referenced from dm_conn.o(.constdata)
 <LI><a href="#[d0]">dmConnSmActAccept</a> from dm_conn_slave_leg.o(i.dmConnSmActAccept) referenced from dm_conn_slave_leg.o(.constdata)
 <LI><a href="#[d4]">dmConnSmActAcceptFailed</a> from dm_conn_slave_leg.o(i.dmConnSmActAcceptFailed) referenced from dm_conn_slave_leg.o(.constdata)
 <LI><a href="#[d1]">dmConnSmActCancelAccept</a> from dm_conn_slave_leg.o(i.dmConnSmActCancelAccept) referenced from dm_conn_slave_leg.o(.constdata)
 <LI><a href="#[c5]">dmConnSmActClose</a> from dm_conn.o(i.dmConnSmActClose) referenced from dm_conn.o(.constdata)
 <LI><a href="#[d3]">dmConnSmActConnAccepted</a> from dm_conn_slave_leg.o(i.dmConnSmActConnAccepted) referenced from dm_conn_slave_leg.o(.constdata)
 <LI><a href="#[c8]">dmConnSmActConnClosed</a> from dm_conn.o(i.dmConnSmActConnClosed) referenced from dm_conn.o(.constdata)
 <LI><a href="#[c7]">dmConnSmActConnFailed</a> from dm_conn.o(i.dmConnSmActConnFailed) referenced from dm_conn.o(.constdata)
 <LI><a href="#[c6]">dmConnSmActConnOpened</a> from dm_conn.o(i.dmConnSmActConnOpened) referenced from dm_conn.o(.constdata)
 <LI><a href="#[c9]">dmConnSmActHciUpdated</a> from dm_conn.o(i.dmConnSmActHciUpdated) referenced from dm_conn.o(.constdata)
 <LI><a href="#[d5]">dmConnSmActL2cUpdateCnf</a> from dm_conn_slave.o(i.dmConnSmActL2cUpdateCnf) referenced from dm_conn_slave_leg.o(.constdata)
 <LI><a href="#[c4]">dmConnSmActNone</a> from dm_conn.o(i.dmConnSmActNone) referenced from dm_conn.o(.constdata)
 <LI><a href="#[d2]">dmConnSmActUpdateSlave</a> from dm_conn_slave.o(i.dmConnSmActUpdateSlave) referenced from dm_conn_slave_leg.o(.constdata)
 <LI><a href="#[d6]">dmDevActReset</a> from dm_dev.o(i.dmDevActReset) referenced from dm_dev.o(.constdata)
 <LI><a href="#[d7]">dmDevHciHandler</a> from dm_dev.o(i.dmDevHciHandler) referenced from dm_dev.o(.constdata)
 <LI><a href="#[d8]">dmDevMsgHandler</a> from dm_dev.o(i.dmDevMsgHandler) referenced from dm_dev.o(.constdata)
 <LI><a href="#[d9]">dmEmptyHandler</a> from dm_main.o(i.dmEmptyHandler) referenced 3 times from dm_main.o(.constdata)
 <LI><a href="#[cd]">dmEmptyReset</a> from dm_main.o(i.dmEmptyReset) referenced 4 times from dm_conn.o(.constdata)
 <LI><a href="#[49]">dmHciEvtCback</a> from dm_main.o(i.dmHciEvtCback) referenced from dm_main.o(i.DmHandlerInit)
 <LI><a href="#[dc]">dmPrivActAddDevToResList</a> from dm_priv.o(i.dmPrivActAddDevToResList) referenced from dm_priv.o(.constdata)
 <LI><a href="#[de]">dmPrivActClearResList</a> from dm_priv.o(i.dmPrivActClearResList) referenced from dm_priv.o(.constdata)
 <LI><a href="#[e1]">dmPrivActGenAddr</a> from dm_priv.o(i.dmPrivActGenAddr) referenced from dm_priv.o(.constdata)
 <LI><a href="#[e2]">dmPrivActGenAddrAesCmpl</a> from dm_priv.o(i.dmPrivActGenAddrAesCmpl) referenced from dm_priv.o(.constdata)
 <LI><a href="#[dd]">dmPrivActRemDevFromResList</a> from dm_priv.o(i.dmPrivActRemDevFromResList) referenced from dm_priv.o(.constdata)
 <LI><a href="#[db]">dmPrivActResAddrAesCmpl</a> from dm_priv.o(i.dmPrivActResAddrAesCmpl) referenced from dm_priv.o(.constdata)
 <LI><a href="#[da]">dmPrivActResolveAddr</a> from dm_priv.o(i.dmPrivActResolveAddr) referenced from dm_priv.o(.constdata)
 <LI><a href="#[df]">dmPrivActSetAddrResEnable</a> from dm_priv.o(i.dmPrivActSetAddrResEnable) referenced from dm_priv.o(.constdata)
 <LI><a href="#[e0]">dmPrivActSetPrivacyMode</a> from dm_priv.o(i.dmPrivActSetPrivacyMode) referenced from dm_priv.o(.constdata)
 <LI><a href="#[e4]">dmPrivHciHandler</a> from dm_priv.o(i.dmPrivHciHandler) referenced from dm_priv.o(.constdata)
 <LI><a href="#[e5]">dmPrivMsgHandler</a> from dm_priv.o(i.dmPrivMsgHandler) referenced from dm_priv.o(.constdata)
 <LI><a href="#[e3]">dmPrivReset</a> from dm_priv.o(i.dmPrivReset) referenced from dm_priv.o(.constdata)
 <LI><a href="#[e6]">dmScanActStart</a> from dm_scan_leg.o(i.dmScanActStart) referenced from dm_scan_leg.o(.constdata)
 <LI><a href="#[e7]">dmScanActStop</a> from dm_scan_leg.o(i.dmScanActStop) referenced from dm_scan_leg.o(.constdata)
 <LI><a href="#[e8]">dmScanActTimeout</a> from dm_scan_leg.o(i.dmScanActTimeout) referenced from dm_scan_leg.o(.constdata)
 <LI><a href="#[ea]">dmScanHciHandler</a> from dm_scan_leg.o(i.dmScanHciHandler) referenced from dm_scan_leg.o(.constdata)
 <LI><a href="#[eb]">dmScanMsgHandler</a> from dm_scan_leg.o(i.dmScanMsgHandler) referenced from dm_scan_leg.o(.constdata)
 <LI><a href="#[e9]">dmScanReset</a> from dm_scan_leg.o(i.dmScanReset) referenced from dm_scan_leg.o(.constdata)
 <LI><a href="#[ed]">dmSecHciHandler</a> from dm_sec.o(i.dmSecHciHandler) referenced from dm_sec.o(.constdata)
 <LI><a href="#[ef]">dmSecLescMsgHandler</a> from dm_sec_lesc.o(i.dmSecLescMsgHandler) referenced from dm_sec_lesc.o(.constdata)
 <LI><a href="#[ee]">dmSecMsgHandler</a> from dm_sec.o(i.dmSecMsgHandler) referenced from dm_sec.o(.constdata)
 <LI><a href="#[ec]">dmSecReset</a> from dm_sec.o(i.dmSecReset) referenced from dm_sec.o(.constdata)
 <LI><a href="#[95]">hciEvtParseAuthTimeoutExpiredEvt</a> from hci_evt.o(i.hciEvtParseAuthTimeoutExpiredEvt) referenced from hci_evt.o(.constdata)
 <LI><a href="#[91]">hciEvtParseDataLenChange</a> from hci_evt.o(i.hciEvtParseDataLenChange) referenced from hci_evt.o(.constdata)
 <LI><a href="#[71]">hciEvtParseDisconnectCmpl</a> from hci_evt.o(i.hciEvtParseDisconnectCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[7c]">hciEvtParseEncChange</a> from hci_evt.o(i.hciEvtParseEncChange) referenced from hci_evt.o(.constdata)
 <LI><a href="#[7b]">hciEvtParseEncKeyRefreshCmpl</a> from hci_evt.o(i.hciEvtParseEncKeyRefreshCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[93]">hciEvtParseGenDhKeyCmdCmpl</a> from hci_evt.o(i.hciEvtParseGenDhKeyCmdCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[81]">hciEvtParseHwError</a> from hci_evt.o(i.hciEvtParseHwError) referenced from hci_evt.o(.constdata)
 <LI><a href="#[82]">hciEvtParseLeAddDevToResListCmdCmpl</a> from hci_evt.o(i.hciEvtParseLeAddDevToResListCmdCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[9a]">hciEvtParseLeAdvSetTerm</a> from hci_evt.o(i.hciEvtParseLeAdvSetTerm) referenced from hci_evt.o(.constdata)
 <LI><a href="#[84]">hciEvtParseLeClearResListCmdCmpl</a> from hci_evt.o(i.hciEvtParseLeClearResListCmdCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[9e]">hciEvtParseLeCmdCmpl</a> from hci_evt.o(i.hciEvtParseLeCmdCmpl) referenced 5 times from hci_evt.o(.constdata)
 <LI><a href="#[6f]">hciEvtParseLeConnCmpl</a> from hci_evt.o(i.hciEvtParseLeConnCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[72]">hciEvtParseLeConnUpdateCmpl</a> from hci_evt.o(i.hciEvtParseLeConnUpdateCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[73]">hciEvtParseLeCreateConnCancelCmdCmpl</a> from hci_evt.o(i.hciEvtParseLeCreateConnCancelCmdCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[88]">hciEvtParseLeEncryptCmdCmpl</a> from hci_evt.o(i.hciEvtParseLeEncryptCmdCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[70]">hciEvtParseLeEnhancedConnCmpl</a> from hci_evt.o(i.hciEvtParseLeEnhancedConnCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[7d]">hciEvtParseLeLtkReq</a> from hci_evt.o(i.hciEvtParseLeLtkReq) referenced from hci_evt.o(.constdata)
 <LI><a href="#[7a]">hciEvtParseLeLtkReqNegReplCmdCmpl</a> from hci_evt.o(i.hciEvtParseLeLtkReqNegReplCmdCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[79]">hciEvtParseLeLtkReqReplCmdCmpl</a> from hci_evt.o(i.hciEvtParseLeLtkReqReplCmdCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[9c]">hciEvtParseLePerAdvSyncEst</a> from hci_evt.o(i.hciEvtParseLePerAdvSyncEst) referenced from hci_evt.o(.constdata)
 <LI><a href="#[9d]">hciEvtParseLePerAdvSyncLost</a> from hci_evt.o(i.hciEvtParseLePerAdvSyncLost) referenced from hci_evt.o(.constdata)
 <LI><a href="#[89]">hciEvtParseLeRandCmdCmpl</a> from hci_evt.o(i.hciEvtParseLeRandCmdCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[86]">hciEvtParseLeReadLocalResAddrCmdCmpl</a> from hci_evt.o(i.hciEvtParseLeReadLocalResAddrCmdCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[85]">hciEvtParseLeReadPeerResAddrCmdCmpl</a> from hci_evt.o(i.hciEvtParseLeReadPeerResAddrCmdCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[83]">hciEvtParseLeRemDevFromResListCmdCmpl</a> from hci_evt.o(i.hciEvtParseLeRemDevFromResListCmdCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[9b]">hciEvtParseLeScanReqRcvd</a> from hci_evt.o(i.hciEvtParseLeScanReqRcvd) referenced from hci_evt.o(.constdata)
 <LI><a href="#[99]">hciEvtParseLeScanTimeout</a> from hci_evt.o(i.hciEvtParseLeScanTimeout) referenced from hci_evt.o(.constdata)
 <LI><a href="#[87]">hciEvtParseLeSetAddrResEnableCmdCmpl</a> from hci_evt.o(i.hciEvtParseLeSetAddrResEnableCmdCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[98]">hciEvtParsePhyUpdateCmpl</a> from hci_evt.o(i.hciEvtParsePhyUpdateCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[75]">hciEvtParseReadChanMapCmdCmpl</a> from hci_evt.o(i.hciEvtParseReadChanMapCmdCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[8c]">hciEvtParseReadDefDataLenCmdCmpl</a> from hci_evt.o(i.hciEvtParseReadDefDataLenCmdCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[78]">hciEvtParseReadLeRemoteFeatCmpl</a> from hci_evt.o(i.hciEvtParseReadLeRemoteFeatCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[8f]">hciEvtParseReadMaxDataLenCmdCmpl</a> from hci_evt.o(i.hciEvtParseReadMaxDataLenCmdCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[96]">hciEvtParseReadPhyCmdCmpl</a> from hci_evt.o(i.hciEvtParseReadPhyCmdCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[92]">hciEvtParseReadPubKeyCmdCmpl</a> from hci_evt.o(i.hciEvtParseReadPubKeyCmdCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[77]">hciEvtParseReadRemoteVerInfoCmpl</a> from hci_evt.o(i.hciEvtParseReadRemoteVerInfoCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[74]">hciEvtParseReadRssiCmdCmpl</a> from hci_evt.o(i.hciEvtParseReadRssiCmdCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[76]">hciEvtParseReadTxPwrLvlCmdCmpl</a> from hci_evt.o(i.hciEvtParseReadTxPwrLvlCmdCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[8b]">hciEvtParseRemConnParamNegRepCmdCmpl</a> from hci_evt.o(i.hciEvtParseRemConnParamNegRepCmdCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[8a]">hciEvtParseRemConnParamRepCmdCmpl</a> from hci_evt.o(i.hciEvtParseRemConnParamRepCmdCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[90]">hciEvtParseRemConnParamReq</a> from hci_evt.o(i.hciEvtParseRemConnParamReq) referenced from hci_evt.o(.constdata)
 <LI><a href="#[8e]">hciEvtParseSetDataLenCmdCmpl</a> from hci_evt.o(i.hciEvtParseSetDataLenCmdCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[97]">hciEvtParseSetDefPhyCmdCmpl</a> from hci_evt.o(i.hciEvtParseSetDefPhyCmdCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[80]">hciEvtParseVendorSpec</a> from hci_evt.o(i.hciEvtParseVendorSpec) referenced from hci_evt.o(.constdata)
 <LI><a href="#[7f]">hciEvtParseVendorSpecCmdCmpl</a> from hci_evt.o(i.hciEvtParseVendorSpecCmdCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[7e]">hciEvtParseVendorSpecCmdStatus</a> from hci_evt.o(i.hciEvtParseVendorSpecCmdStatus) referenced from hci_evt.o(.constdata)
 <LI><a href="#[94]">hciEvtParseWriteAuthTimeoutCmdCmpl</a> from hci_evt.o(i.hciEvtParseWriteAuthTimeoutCmdCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[8d]">hciEvtParseWriteDefDataLenCmdCmpl</a> from hci_evt.o(i.hciEvtParseWriteDefDataLenCmdCmpl) referenced from hci_evt.o(.constdata)
 <LI><a href="#[4c]">l2cDefaultCtrlCback</a> from l2c_main.o(i.l2cDefaultCtrlCback) referenced from l2c_main.o(i.L2cInit)
 <LI><a href="#[4a]">l2cDefaultDataCback</a> from l2c_main.o(i.l2cDefaultDataCback) referenced from l2c_main.o(i.L2cInit)
 <LI><a href="#[4d]">l2cDefaultDataCidCback</a> from l2c_main.o(i.l2cDefaultDataCidCback) referenced from l2c_main.o(i.L2cInit)
 <LI><a href="#[4f]">l2cHciAclCback</a> from l2c_main.o(i.l2cHciAclCback) referenced from l2c_main.o(i.L2cInit)
 <LI><a href="#[4e]">l2cHciFlowCback</a> from l2c_main.o(i.l2cHciFlowCback) referenced from l2c_main.o(i.L2cInit)
 <LI><a href="#[4b]">l2cRxSignalingPkt</a> from l2c_main.o(i.l2cRxSignalingPkt) referenced from l2c_main.o(i.L2cInit)
 <LI><a href="#[50]">l2cSlaveRxSignalingPkt</a> from l2c_slave.o(i.l2cSlaveRxSignalingPkt) referenced from l2c_slave.o(i.L2cSlaveInit)
 <LI><a href="#[6d]">prvIdleTask</a> from tasks.o(i.prvIdleTask) referenced from tasks.o(i.vTaskStartScheduler)
 <LI><a href="#[6a]">prvTaskExitError</a> from port.o(i.prvTaskExitError) referenced from port.o(i.pxPortInitialiseStack)
 <LI><a href="#[6e]">prvTimerTask</a> from timers.o(i.prvTimerTask) referenced from timers.o(i.xTimerCreateTimerTask)
 <LI><a href="#[53]">secEccRng</a> from sec_ecc.o(i.secEccRng) referenced from sec_ecc.o(i.SecEccInit)
 <LI><a href="#[54]">secHciCback</a> from sec_main.o(i.secHciCback) referenced from sec_main.o(i.SecInit)
 <LI><a href="#[6b]">setup_task</a> from rtos.o(i.setup_task) referenced from rtos.o(i.run_tasks)
 <LI><a href="#[101]">smpActAttemptRcvd</a> from smp_act.o(i.smpActAttemptRcvd) referenced 2 times from smpr_sc_sm.o(.constdata)
 <LI><a href="#[fe]">smpActCheckAttempts</a> from smp_act.o(i.smpActCheckAttempts) referenced 2 times from smpr_sc_sm.o(.constdata)
 <LI><a href="#[126]">smpActCleanup</a> from smp_act.o(i.smpActCleanup) referenced from smpr_sm.o(.constdata)
 <LI><a href="#[fc]">smpActMaxAttempts</a> from smp_act.o(i.smpActMaxAttempts) referenced 2 times from smpr_sc_sm.o(.constdata)
 <LI><a href="#[f0]">smpActNone</a> from smp_act.o(i.smpActNone) referenced 2 times from smpr_sc_sm.o(.constdata)
 <LI><a href="#[ff]">smpActNotifyDmAttemptsFailure</a> from smp_act.o(i.smpActNotifyDmAttemptsFailure) referenced 2 times from smpr_sc_sm.o(.constdata)
 <LI><a href="#[100]">smpActNotifyDmRspToFailure</a> from smp_act.o(i.smpActNotifyDmRspToFailure) referenced 2 times from smpr_sc_sm.o(.constdata)
 <LI><a href="#[f7]">smpActPairCnfCalc1</a> from smp_act.o(i.smpActPairCnfCalc1) referenced 2 times from smpr_sc_sm.o(.constdata)
 <LI><a href="#[f8]">smpActPairCnfCalc2</a> from smp_act.o(i.smpActPairCnfCalc2) referenced 2 times from smpr_sc_sm.o(.constdata)
 <LI><a href="#[fa]">smpActPairCnfVerCalc1</a> from smp_act.o(i.smpActPairCnfVerCalc1) referenced 2 times from smpr_sc_sm.o(.constdata)
 <LI><a href="#[fb]">smpActPairCnfVerCalc2</a> from smp_act.o(i.smpActPairCnfVerCalc2) referenced 2 times from smpr_sc_sm.o(.constdata)
 <LI><a href="#[128]">smpActPairingCancel</a> from smp_act.o(i.smpActPairingCancel) referenced from smpr_sm.o(.constdata)
 <LI><a href="#[fd]">smpActPairingCmpl</a> from smp_act.o(i.smpActPairingCmpl) referenced 2 times from smpr_sc_sm.o(.constdata)
 <LI><a href="#[127]">smpActPairingFailed</a> from smp_act.o(i.smpActPairingFailed) referenced from smpr_sm.o(.constdata)
 <LI><a href="#[f9]">smpActSendPairCnf</a> from smp_act.o(i.smpActSendPairCnf) referenced 2 times from smpr_sc_sm.o(.constdata)
 <LI><a href="#[f5]">smpActStorePin</a> from smp_act.o(i.smpActStorePin) referenced 2 times from smpr_sc_sm.o(.constdata)
 <LI><a href="#[5b]">smpAuthReq</a> from smp_act.o(i.smpAuthReq) referenced from smpr_sm.o(i.SmprInit)
 <LI><a href="#[57]">smpDmConnCback</a> from smp_main.o(i.smpDmConnCback) referenced from smp_main.o(i.SmpHandlerInit)
 <LI><a href="#[55]">smpL2cCtrlCback</a> from smp_main.o(i.smpL2cCtrlCback) referenced from smp_main.o(i.SmpHandlerInit)
 <LI><a href="#[56]">smpL2cDataCback</a> from smp_main.o(i.smpL2cDataCback) referenced from smp_main.o(i.SmpHandlerInit)
 <LI><a href="#[5a]">smpProcPairing</a> from smp_act.o(i.smpProcPairing) referenced from smpr_sm.o(i.SmprInit)
 <LI><a href="#[11c]">smpScActCalcF5Ltk</a> from smp_sc_act.o(i.smpScActCalcF5Ltk) referenced from smpr_sc_sm.o(.constdata)
 <LI><a href="#[11b]">smpScActCalcF5MacKey</a> from smp_sc_act.o(i.smpScActCalcF5MacKey) referenced from smpr_sc_sm.o(.constdata)
 <LI><a href="#[11a]">smpScActCalcF5TKey</a> from smp_sc_act.o(i.smpScActCalcF5TKey) referenced from smpr_sc_sm.o(.constdata)
 <LI><a href="#[f1]">smpScActCleanup</a> from smp_sc_act.o(i.smpScActCleanup) referenced from smpr_sc_sm.o(.constdata)
 <LI><a href="#[11d]">smpScActDHKeyCalcF6Ea</a> from smp_sc_act.o(i.smpScActDHKeyCalcF6Ea) referenced from smpr_sc_sm.o(.constdata)
 <LI><a href="#[11e]">smpScActDHKeyCalcF6Eb</a> from smp_sc_act.o(i.smpScActDHKeyCalcF6Eb) referenced from smpr_sc_sm.o(.constdata)
 <LI><a href="#[f3]">smpScActPairingCancel</a> from smp_sc_act.o(i.smpScActPairingCancel) referenced from smpr_sc_sm.o(.constdata)
 <LI><a href="#[f2]">smpScActPairingFailed</a> from smp_sc_act.o(i.smpScActPairingFailed) referenced from smpr_sc_sm.o(.constdata)
 <LI><a href="#[10b]">smpScActPkKeypress</a> from smp_sc_act.o(i.smpScActPkKeypress) referenced from smpr_sc_sm.o(.constdata)
 <LI><a href="#[10c]">smpScActPkSendKeypress</a> from smp_sc_act.o(i.smpScActPkSendKeypress) referenced from smpr_sc_sm.o(.constdata)
 <LI><a href="#[10a]">smpScActPkSetup</a> from smp_sc_act.o(i.smpScActPkSetup) referenced from smpr_sc_sm.o(.constdata)
 <LI><a href="#[59]">smpScAuthReq</a> from smp_sc_act.o(i.smpScAuthReq) referenced from smp_sc_main.o(i.SmpScInit)
 <LI><a href="#[58]">smpScProcPairing</a> from smp_sc_act.o(i.smpScProcPairing) referenced from smp_sc_main.o(i.SmpScInit)
 <LI><a href="#[121]">smprActCnfVerify</a> from smpr_act.o(i.smprActCnfVerify) referenced 2 times from smpr_sc_sm.o(.constdata)
 <LI><a href="#[105]">smprActProcPairCnf</a> from smpr_act.o(i.smprActProcPairCnf) referenced 2 times from smpr_sc_sm.o(.constdata)
 <LI><a href="#[120]">smprActProcPairCnfCalc1</a> from smpr_act.o(i.smprActProcPairCnfCalc1) referenced 2 times from smpr_sc_sm.o(.constdata)
 <LI><a href="#[103]">smprActProcPairReq</a> from smpr_act.o(i.smprActProcPairReq) referenced 2 times from smpr_sc_sm.o(.constdata)
 <LI><a href="#[124]">smprActRcvKey</a> from smpr_act.o(i.smprActRcvKey) referenced 2 times from smpr_sc_sm.o(.constdata)
 <LI><a href="#[125]">smprActSendKey</a> from smpr_act.o(i.smprActSendKey) referenced 2 times from smpr_sc_sm.o(.constdata)
 <LI><a href="#[122]">smprActSendPairRandom</a> from smpr_act.o(i.smprActSendPairRandom) referenced 2 times from smpr_sc_sm.o(.constdata)
 <LI><a href="#[104]">smprActSendPairRsp</a> from smpr_act.o(i.smprActSendPairRsp) referenced 2 times from smpr_sc_sm.o(.constdata)
 <LI><a href="#[102]">smprActSendSecurityReq</a> from smpr_act.o(i.smprActSendSecurityReq) referenced 2 times from smpr_sc_sm.o(.constdata)
 <LI><a href="#[123]">smprActSetupKeyDist</a> from smpr_act.o(i.smprActSetupKeyDist) referenced 2 times from smpr_sc_sm.o(.constdata)
 <LI><a href="#[119]">smprScActCalcDHKey</a> from smpr_sc_act.o(i.smprScActCalcDHKey) referenced from smpr_sc_sm.o(.constdata)
 <LI><a href="#[11f]">smprScActDHKeyCheckSend</a> from smpr_sc_act.o(i.smprScActDHKeyCheckSend) referenced from smpr_sc_sm.o(.constdata)
 <LI><a href="#[108]">smprScActJwncCalcG2</a> from smpr_sc_act.o(i.smprScActJwncCalcG2) referenced from smpr_sc_sm.o(.constdata)
 <LI><a href="#[109]">smprScActJwncDisplay</a> from smpr_sc_act.o(i.smprScActJwncDisplay) referenced from smpr_sc_sm.o(.constdata)
 <LI><a href="#[107]">smprScActJwncSendCnf</a> from smpr_sc_act.o(i.smprScActJwncSendCnf) referenced from smpr_sc_sm.o(.constdata)
 <LI><a href="#[106]">smprScActJwncSetup</a> from smpr_sc_act.o(i.smprScActJwncSetup) referenced from smpr_sc_sm.o(.constdata)
 <LI><a href="#[115]">smprScActOobCalcCa</a> from smpr_sc_act.o(i.smprScActOobCalcCa) referenced from smpr_sc_sm.o(.constdata)
 <LI><a href="#[116]">smprScActOobSendRand</a> from smpr_sc_act.o(i.smprScActOobSendRand) referenced from smpr_sc_sm.o(.constdata)
 <LI><a href="#[114]">smprScActOobSetup</a> from smpr_sc_act.o(i.smprScActOobSetup) referenced from smpr_sc_sm.o(.constdata)
 <LI><a href="#[112]">smprScActPkCalcCa</a> from smpr_sc_act.o(i.smprScActPkCalcCa) referenced from smpr_sc_sm.o(.constdata)
 <LI><a href="#[110]">smprScActPkCalcCb</a> from smpr_sc_act.o(i.smprScActPkCalcCb) referenced from smpr_sc_sm.o(.constdata)
 <LI><a href="#[111]">smprScActPkSendCnf</a> from smpr_sc_act.o(i.smprScActPkSendCnf) referenced from smpr_sc_sm.o(.constdata)
 <LI><a href="#[113]">smprScActPkSendRand</a> from smpr_sc_act.o(i.smprScActPkSendRand) referenced from smpr_sc_sm.o(.constdata)
 <LI><a href="#[10d]">smprScActPkStoreCnf</a> from smpr_sc_act.o(i.smprScActPkStoreCnf) referenced from smpr_sc_sm.o(.constdata)
 <LI><a href="#[10e]">smprScActPkStoreCnfAndCalcCb</a> from smpr_sc_act.o(i.smprScActPkStoreCnfAndCalcCb) referenced from smpr_sc_sm.o(.constdata)
 <LI><a href="#[10f]">smprScActPkStorePinAndCalcCb</a> from smpr_sc_act.o(i.smprScActPkStorePinAndCalcCb) referenced from smpr_sc_sm.o(.constdata)
 <LI><a href="#[f4]">smprScActSendPubKey</a> from smpr_sc_act.o(i.smprScActSendPubKey) referenced from smpr_sc_sm.o(.constdata)
 <LI><a href="#[117]">smprScActStoreDhCheck</a> from smpr_sc_act.o(i.smprScActStoreDhCheck) referenced from smpr_sc_sm.o(.constdata)
 <LI><a href="#[f6]">smprScActStoreLescPin</a> from smpr_sc_act.o(i.smprScActStoreLescPin) referenced from smpr_sc_sm.o(.constdata)
 <LI><a href="#[118]">smprScActWaitDhCheck</a> from smpr_sc_act.o(i.smprScActWaitDhCheck) referenced from smpr_sc_sm.o(.constdata)
 <LI><a href="#[5c]">vEventGroupSetBitsCallback</a> from event_groups.o(i.vEventGroupSetBitsCallback) referenced from wsf_os.o(i.WsfSetOsSpecificEvent)
</UL>
<P>
<H3>
Global Symbols
</H3>
<P><STRONG><a name="[f]"></a>Reset_Handler</STRONG> (Thumb, 28 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[10]"></a>NMI_Handler</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NMI_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NMI_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[12]"></a>MemManage_Handler</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[12]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MemManage_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[12]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MemManage_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[13]"></a>BusFault_Handler</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[13]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BusFault_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[13]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BusFault_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[14]"></a>UsageFault_Handler</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UsageFault_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UsageFault_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[15]"></a>SecureFault_Handler</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[15]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureFault_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[15]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureFault_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[17]"></a>DebugMon_Handler</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[17]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DebugMon_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[17]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DebugMon_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[2c]"></a>am_adc_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_adc_isr
</UL>
<BR>[Called By]<UL><LI><a href="#[2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_adc_isr
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[1a]"></a>am_brownout_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[39]"></a>am_clkgen_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[27]"></a>am_gpio_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[20]"></a>am_iomaster0_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[21]"></a>am_iomaster1_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[22]"></a>am_iomaster2_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[23]"></a>am_iomaster3_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[24]"></a>am_iomaster4_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[25]"></a>am_iomaster5_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[1f]"></a>am_ioslave_acc_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[1e]"></a>am_ioslave_ios_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[2e]"></a>am_mspi0_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[2d]"></a>am_pdm0_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[1c]"></a>am_rtc_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[2b]"></a>am_scard_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[2f]"></a>am_software0_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[33]"></a>am_stimer_cmpr2_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[34]"></a>am_stimer_cmpr3_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[35]"></a>am_stimer_cmpr4_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[36]"></a>am_stimer_cmpr5_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[37]"></a>am_stimer_cmpr6_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[38]"></a>am_stimer_cmpr7_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[30]"></a>am_stimer_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[12a]"></a>am_uart0_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_keil.o(RESET), UNUSED, KEPT)

<P><STRONG><a name="[2a]"></a>am_uart1_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[1d]"></a>am_vcomp_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[1b]"></a>am_watchdog_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_keil.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[129]"></a>__main</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, __main.o(!!!main))
<BR><BR>[Calls]<UL><LI><a href="#[12c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
<LI><a href="#[12b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__scatterload
</UL>

<P><STRONG><a name="[12b]"></a>__scatterload</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, __scatter.o(!!!scatter))
<BR><BR>[Called By]<UL><LI><a href="#[129]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__main
</UL>

<P><STRONG><a name="[12d]"></a>__scatterload_rt2</STRONG> (Thumb, 44 bytes, Stack size unknown bytes, __scatter.o(!!!scatter), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[12c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[451]"></a>__scatterload_rt2_thumb_only</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, __scatter.o(!!!scatter), UNUSED)

<P><STRONG><a name="[452]"></a>__scatterload_null</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, __scatter.o(!!!scatter), UNUSED)

<P><STRONG><a name="[453]"></a>__decompress</STRONG> (Thumb, 100 bytes, Stack size unknown bytes, __dclz77c.o(!!dclz77c), UNUSED)

<P><STRONG><a name="[454]"></a>__decompress2</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, __dclz77c.o(!!dclz77c), UNUSED)

<P><STRONG><a name="[455]"></a>__scatterload_zeroinit</STRONG> (Thumb, 28 bytes, Stack size unknown bytes, __scatter_zi.o(!!handler_zi), UNUSED)

<P><STRONG><a name="[133]"></a>__rt_lib_init</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit.o(.ARM.Collect$$libinit$$00000000))
<BR><BR>[Called By]<UL><LI><a href="#[132]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry_li
</UL>

<P><STRONG><a name="[12e]"></a>__rt_lib_init_fp_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$00000001))
<BR><BR>[Calls]<UL><LI><a href="#[12f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fp_init
</UL>

<P><STRONG><a name="[456]"></a>__rt_lib_init_alloca_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$0000002E))

<P><STRONG><a name="[457]"></a>__rt_lib_init_argv_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$0000002C))

<P><STRONG><a name="[458]"></a>__rt_lib_init_atexit_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$0000001B))

<P><STRONG><a name="[459]"></a>__rt_lib_init_clock_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$00000021))

<P><STRONG><a name="[45a]"></a>__rt_lib_init_cpp_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$00000032))

<P><STRONG><a name="[45b]"></a>__rt_lib_init_exceptions_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$00000030))

<P><STRONG><a name="[45c]"></a>__rt_lib_init_fp_trap_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$0000001F))

<P><STRONG><a name="[45d]"></a>__rt_lib_init_getenv_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$00000023))

<P><STRONG><a name="[45e]"></a>__rt_lib_init_heap_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$0000000A))

<P><STRONG><a name="[45f]"></a>__rt_lib_init_lc_collate_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$00000011))

<P><STRONG><a name="[460]"></a>__rt_lib_init_lc_ctype_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$00000013))

<P><STRONG><a name="[461]"></a>__rt_lib_init_lc_monetary_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$00000015))

<P><STRONG><a name="[462]"></a>__rt_lib_init_lc_numeric_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$00000017))

<P><STRONG><a name="[463]"></a>__rt_lib_init_lc_time_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$00000019))

<P><STRONG><a name="[464]"></a>__rt_lib_init_preinit_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$00000004))

<P><STRONG><a name="[465]"></a>__rt_lib_init_rand_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$0000000E))

<P><STRONG><a name="[466]"></a>__rt_lib_init_return</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$00000033))

<P><STRONG><a name="[467]"></a>__rt_lib_init_signal_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$0000001D))

<P><STRONG><a name="[468]"></a>__rt_lib_init_stdio_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$00000025))

<P><STRONG><a name="[469]"></a>__rt_lib_init_user_alloc_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$0000000C))

<P><STRONG><a name="[138]"></a>__rt_lib_shutdown</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libshutdown.o(.ARM.Collect$$libshutdown$$00000000))
<BR><BR>[Called By]<UL><LI><a href="#[137]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_exit_ls
</UL>

<P><STRONG><a name="[46a]"></a>__rt_lib_shutdown_cpp_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libshutdown2.o(.ARM.Collect$$libshutdown$$00000002))

<P><STRONG><a name="[46b]"></a>__rt_lib_shutdown_fp_trap_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libshutdown2.o(.ARM.Collect$$libshutdown$$00000007))

<P><STRONG><a name="[46c]"></a>__rt_lib_shutdown_heap_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libshutdown2.o(.ARM.Collect$$libshutdown$$0000000F))

<P><STRONG><a name="[46d]"></a>__rt_lib_shutdown_return</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libshutdown2.o(.ARM.Collect$$libshutdown$$00000010))

<P><STRONG><a name="[46e]"></a>__rt_lib_shutdown_signal_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libshutdown2.o(.ARM.Collect$$libshutdown$$0000000A))

<P><STRONG><a name="[46f]"></a>__rt_lib_shutdown_stdio_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libshutdown2.o(.ARM.Collect$$libshutdown$$00000004))

<P><STRONG><a name="[470]"></a>__rt_lib_shutdown_user_alloc_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libshutdown2.o(.ARM.Collect$$libshutdown$$0000000C))

<P><STRONG><a name="[12c]"></a>__rt_entry</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, __rtentry.o(.ARM.Collect$$rtentry$$00000000))
<BR><BR>[Called By]<UL><LI><a href="#[129]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__main
<LI><a href="#[12d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__scatterload_rt2
</UL>

<P><STRONG><a name="[471]"></a>__rt_entry_presh_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, __rtentry2.o(.ARM.Collect$$rtentry$$00000002))

<P><STRONG><a name="[130]"></a>__rt_entry_sh</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, __rtentry4.o(.ARM.Collect$$rtentry$$00000004))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = __rt_entry_sh &rArr; __user_setup_stackheap
</UL>
<BR>[Calls]<UL><LI><a href="#[131]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_setup_stackheap
</UL>

<P><STRONG><a name="[132]"></a>__rt_entry_li</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, __rtentry2.o(.ARM.Collect$$rtentry$$0000000A))
<BR><BR>[Calls]<UL><LI><a href="#[133]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init
</UL>

<P><STRONG><a name="[472]"></a>__rt_entry_postsh_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, __rtentry2.o(.ARM.Collect$$rtentry$$00000009))

<P><STRONG><a name="[134]"></a>__rt_entry_main</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, __rtentry2.o(.ARM.Collect$$rtentry$$0000000D))
<BR><BR>[Stack]<UL><LI>Max Depth = 292 + Unknown Stack Size
<LI>Call Chain = __rt_entry_main &rArr; main &rArr; am_util_stdio_printf &rArr; am_util_stdio_vsprintf &rArr; ftoa &rArr; uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[135]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[136]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exit
</UL>

<P><STRONG><a name="[473]"></a>__rt_entry_postli_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, __rtentry2.o(.ARM.Collect$$rtentry$$0000000C))

<P><STRONG><a name="[145]"></a>__rt_exit</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, rtexit.o(.ARM.Collect$$rtexit$$00000000))
<BR><BR>[Called By]<UL><LI><a href="#[136]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exit
</UL>

<P><STRONG><a name="[137]"></a>__rt_exit_ls</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, rtexit2.o(.ARM.Collect$$rtexit$$00000003))
<BR><BR>[Calls]<UL><LI><a href="#[138]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_shutdown
</UL>

<P><STRONG><a name="[474]"></a>__rt_exit_prels_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, rtexit2.o(.ARM.Collect$$rtexit$$00000002))

<P><STRONG><a name="[139]"></a>__rt_exit_exit</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, rtexit2.o(.ARM.Collect$$rtexit$$00000004))
<BR><BR>[Calls]<UL><LI><a href="#[13a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sys_exit
</UL>

<P><STRONG><a name="[16]"></a>SVC_Handler</STRONG> (Thumb, 28 bytes, Stack size 0 bytes, port.o(.emb_text))
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[449]"></a>__asm___6_port_c_39a90d8d__prvStartFirstTask</STRONG> (Thumb, 36 bytes, Stack size 0 bytes, port.o(.emb_text))
<BR><BR>[Called By]<UL><LI><a href="#[43b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xPortStartScheduler
</UL>

<P><STRONG><a name="[448]"></a>__asm___6_port_c_39a90d8d__prvEnableVFP</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, port.o(.emb_text))
<BR><BR>[Called By]<UL><LI><a href="#[43b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xPortStartScheduler
</UL>

<P><STRONG><a name="[18]"></a>PendSV_Handler</STRONG> (Thumb, 88 bytes, Stack size 0 bytes, port.o(.emb_text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = PendSV_Handler &rArr; vTaskSwitchContext
</UL>
<BR>[Calls]<UL><LI><a href="#[13b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSwitchContext
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[435]"></a>vPortGetIPSR</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, port.o(.emb_text))
<BR><BR>[Called By]<UL><LI><a href="#[434]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortValidateInterruptPriority
</UL>

<P><STRONG><a name="[11]"></a>HardFault_Handler</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, am_util_faultisr.o(.emb_text))
<BR><BR>[Stack]<UL><LI>Max Depth = 76<LI>Call Chain = HardFault_Handler &rArr; am_util_faultisr_collect_data &rArr; __aeabi_memclr4
</UL>
<BR>[Calls]<UL><LI><a href="#[13c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_faultisr_collect_data
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[320]"></a>getStackedReg</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, am_util_faultisr.o(.emb_text))
<BR><BR>[Called By]<UL><LI><a href="#[13c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_faultisr_collect_data
</UL>

<P><STRONG><a name="[475]"></a>am_hal_interrupt_master_enable</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, am_hal_interrupt.o(.emb_text), UNUSED)

<P><STRONG><a name="[305]"></a>am_hal_interrupt_master_disable</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, am_hal_interrupt.o(.emb_text))
<BR><BR>[Called By]<UL><LI><a href="#[31a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_stimer_compare_delta_set
<LI><a href="#[26a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_queue_item_get
<LI><a href="#[319]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_queue_item_add
<LI><a href="#[275]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_int_enable
<LI><a href="#[303]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_sysctrl_sleep
<LI><a href="#[2fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ctimer_int_status_get
<LI><a href="#[2fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ctimer_int_clear
<LI><a href="#[31b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_sysctrl_fpu_stacking_enable
<LI><a href="#[312]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_cachectrl_config
<LI><a href="#[2f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_state_write
<LI><a href="#[2f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_pinconfig
<LI><a href="#[313]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_cachectrl_control
<LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_periph_enable
<LI><a href="#[310]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_periph_disable
<LI><a href="#[30f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_blebuck_trim
<LI><a href="#[304]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_blocking_transfer
<LI><a href="#[2f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_low_power_init
</UL>

<P><STRONG><a name="[306]"></a>am_hal_interrupt_master_set</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, am_hal_interrupt.o(.emb_text))
<BR><BR>[Called By]<UL><LI><a href="#[31a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_stimer_compare_delta_set
<LI><a href="#[26a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_queue_item_get
<LI><a href="#[319]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_queue_item_add
<LI><a href="#[275]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_int_enable
<LI><a href="#[303]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_sysctrl_sleep
<LI><a href="#[2fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ctimer_int_status_get
<LI><a href="#[2fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ctimer_int_clear
<LI><a href="#[31b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_sysctrl_fpu_stacking_enable
<LI><a href="#[312]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_cachectrl_config
<LI><a href="#[2f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_state_write
<LI><a href="#[2f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_pinconfig
<LI><a href="#[313]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_cachectrl_control
<LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_periph_enable
<LI><a href="#[310]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_periph_disable
<LI><a href="#[30f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_blebuck_trim
<LI><a href="#[304]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_blocking_transfer
<LI><a href="#[2f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_low_power_init
</UL>

<P><STRONG><a name="[144]"></a>__user_initial_stackheap</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, startup_keil.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[131]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_setup_stackheap
</UL>

<P><STRONG><a name="[15c]"></a>memcmp</STRONG> (Thumb, 88 bytes, Stack size 8 bytes, memcmp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = memcmp
</UL>
<BR>[Called By]<UL><LI><a href="#[1f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaIsZeros
<LI><a href="#[15a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCmp
<LI><a href="#[34b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attUuidCmp16to128
<LI><a href="#[354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcUuidCmp
<LI><a href="#[366]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsUuidCmp
<LI><a href="#[6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadTypeReq
<LI><a href="#[5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcFindTypeReq
<LI><a href="#[ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmSecHciHandler
<LI><a href="#[db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmPrivActResAddrAesCmpl
<LI><a href="#[121]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprActCnfVerify
<LI><a href="#[113]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActPkSendRand
<LI><a href="#[116]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActOobSendRand
<LI><a href="#[11f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActDHKeyCheckSend
<LI><a href="#[15b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbFindByLtkReq
<LI><a href="#[171]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscProcAttMsg
<LI><a href="#[1bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSecFindLtk
<LI><a href="#[1f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerProcMsg
</UL>

<P><STRONG><a name="[163]"></a>__aeabi_memcpy</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, rt_memcpy_v6.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[292]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeStartEncryptionCmd
<LI><a href="#[291]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetScanRespDataCmd
<LI><a href="#[288]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetAdvDataCmd
<LI><a href="#[27c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeLtkReqReplCmd
<LI><a href="#[27a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeEncryptCmd
<LI><a href="#[277]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeAddDeviceToResolvingListCmd
<LI><a href="#[1a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsCsfGetFeatures
<LI><a href="#[92]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtParseReadPubKeyCmdCmpl
<LI><a href="#[88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtParseLeEncryptCmdCmpl
<LI><a href="#[93]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtParseGenDhKeyCmdCmpl
<LI><a href="#[256]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreAclReassembly
<LI><a href="#[3cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessLePerAdvReport
<LI><a href="#[3ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessLeExtAdvReport
<LI><a href="#[3cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessLeAdvReport
<LI><a href="#[7f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtParseVendorSpecCmdCmpl
<LI><a href="#[80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtParseVendorSpec
<LI><a href="#[206]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Calc128Cpy
<LI><a href="#[1f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsSetAttr
<LI><a href="#[35e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsCheckPendDbHashReadRsp
<LI><a href="#[1df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcWriteCmd
<LI><a href="#[a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendPrepWriteReq
<LI><a href="#[1e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcWriteReq
<LI><a href="#[1d3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcReadByTypeReq
<LI><a href="#[1d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcFindByTypeValueReq
<LI><a href="#[20d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmAdvSetData
<LI><a href="#[364]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsExecPrepWrite
<LI><a href="#[b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcWrite
<LI><a href="#[6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadTypeReq
<LI><a href="#[7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadReq
<LI><a href="#[9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadMultReq
<LI><a href="#[a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadGroupTypeReq
<LI><a href="#[8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadBlobReq
<LI><a href="#[c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcPrepWriteReq
<LI><a href="#[4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcFindInfoReq
<LI><a href="#[1e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsCalculateDbHash
<LI><a href="#[1f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsHandleValueIndNtf
<LI><a href="#[2d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScCat
<LI><a href="#[237]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecSetEccKey
<LI><a href="#[18e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecAuthRsp
<LI><a href="#[122]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprActSendPairRandom
<LI><a href="#[105]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprActProcPairCnf
<LI><a href="#[11a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActCalcF5TKey
<LI><a href="#[f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActSendPairCnf
<LI><a href="#[fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActPairCnfVerCalc1
<LI><a href="#[41c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActCalcSharedSecret
<LI><a href="#[58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScProcPairing
<LI><a href="#[f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActStorePin
<LI><a href="#[165]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbSetPeerDbHash
<LI><a href="#[164]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbSetKey
<LI><a href="#[162]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbSetHdlList
<LI><a href="#[2b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;secCmacProcessBlock
<LI><a href="#[17e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscStart
<LI><a href="#[171]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscProcAttMsg
<LI><a href="#[3e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvCopyDataToQueue
<LI><a href="#[3e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvCopyDataFromQueue
<LI><a href="#[43]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerAttCback
</UL>

<P><STRONG><a name="[13d]"></a>__rt_memcpy</STRONG> (Thumb, 138 bytes, Stack size 0 bytes, rt_memcpy_v6.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[13e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4
</UL>

<P><STRONG><a name="[476]"></a>_memcpy_lastbytes</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, rt_memcpy_v6.o(.text), UNUSED)

<P><STRONG><a name="[13e]"></a>__aeabi_memcpy4</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, rt_memcpy_w.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __aeabi_memcpy4
</UL>
<BR>[Called By]<UL><LI><a href="#[1b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvRadioBoot
<LI><a href="#[a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendPrepWriteReq
<LI><a href="#[a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendContinuingReq
<LI><a href="#[30a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_patch_apply
<LI><a href="#[42]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerDmCback
<LI><a href="#[13d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_memcpy
</UL>

<P><STRONG><a name="[477]"></a>__aeabi_memcpy8</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, rt_memcpy_w.o(.text), UNUSED)

<P><STRONG><a name="[478]"></a>__rt_memcpy_w</STRONG> (Thumb, 100 bytes, Stack size 8 bytes, rt_memcpy_w.o(.text), UNUSED)

<P><STRONG><a name="[479]"></a>_memcpy_lastbytes_aligned</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, rt_memcpy_w.o(.text), UNUSED)

<P><STRONG><a name="[13f]"></a>__aeabi_memset</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, aeabi_memset.o(.text))
<BR><BR>[Calls]<UL><LI><a href="#[140]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_memset
</UL>
<BR>[Called By]<UL><LI><a href="#[2b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecEccGenSharedSecret
<LI><a href="#[3ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvInitialiseNewTask
</UL>

<P><STRONG><a name="[1d2]"></a>__aeabi_memclr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, rt_memclr.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[291]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetScanRespDataCmd
<LI><a href="#[288]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetAdvDataCmd
<LI><a href="#[19e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsCccInitTable
<LI><a href="#[17d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcDiscCharCmpl
<LI><a href="#[da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmPrivActResolveAddr
<LI><a href="#[e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmPrivActGenAddr
<LI><a href="#[122]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprActSendPairRandom
<LI><a href="#[416]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpGenerateLtk
<LI><a href="#[f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActStorePin
<LI><a href="#[11f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActDHKeyCheckSend
<LI><a href="#[2b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;secCmacProcessBlock
<LI><a href="#[172]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscRestartDiscovery
<LI><a href="#[182]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscConnOpen
</UL>

<P><STRONG><a name="[141]"></a>__rt_memclr</STRONG> (Thumb, 68 bytes, Stack size 0 bytes, rt_memclr.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[142]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_memset_w
</UL>

<P><STRONG><a name="[140]"></a>_memset</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, rt_memclr.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[13f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memset
</UL>

<P><STRONG><a name="[160]"></a>__aeabi_memclr4</STRONG> (Thumb, 0 bytes, Stack size 4 bytes, rt_memclr_w.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = __aeabi_memclr4
</UL>
<BR>[Called By]<UL><LI><a href="#[2de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfOsInit
<LI><a href="#[383]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;curve_x_side
<LI><a href="#[389]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvGenConnCmpl
<LI><a href="#[395]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnCcbAlloc
<LI><a href="#[2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpDbInit
<LI><a href="#[414]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpDbAddDevice
<LI><a href="#[15f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbNewRecord
<LI><a href="#[13c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_faultisr_collect_data
</UL>

<P><STRONG><a name="[47a]"></a>__aeabi_memclr8</STRONG> (Thumb, 0 bytes, Stack size 4 bytes, rt_memclr_w.o(.text), UNUSED)

<P><STRONG><a name="[47b]"></a>__rt_memclr_w</STRONG> (Thumb, 78 bytes, Stack size 4 bytes, rt_memclr_w.o(.text), UNUSED)

<P><STRONG><a name="[142]"></a>_memset_w</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, rt_memclr_w.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[141]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_memclr
</UL>

<P><STRONG><a name="[47c]"></a>__use_two_region_memory</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, heapauxi.o(.text), UNUSED)

<P><STRONG><a name="[47d]"></a>__rt_heap_escrow$2region</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, heapauxi.o(.text), UNUSED)

<P><STRONG><a name="[47e]"></a>__rt_heap_expand$2region</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, heapauxi.o(.text), UNUSED)

<P><STRONG><a name="[47f]"></a>__user_libspace</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, libspace.o(.text), UNUSED)

<P><STRONG><a name="[143]"></a>__user_perproc_libspace</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, libspace.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[131]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_setup_stackheap
</UL>

<P><STRONG><a name="[480]"></a>__user_perthread_libspace</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, libspace.o(.text), UNUSED)

<P><STRONG><a name="[131]"></a>__user_setup_stackheap</STRONG> (Thumb, 74 bytes, Stack size 8 bytes, sys_stackheap_outer.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __user_setup_stackheap
</UL>
<BR>[Calls]<UL><LI><a href="#[144]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_initial_stackheap
<LI><a href="#[143]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_perproc_libspace
</UL>
<BR>[Called By]<UL><LI><a href="#[130]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry_sh
</UL>

<P><STRONG><a name="[136]"></a>exit</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, exit.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = exit
</UL>
<BR>[Calls]<UL><LI><a href="#[145]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_exit
</UL>
<BR>[Called By]<UL><LI><a href="#[134]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry_main
</UL>

<P><STRONG><a name="[13a]"></a>_sys_exit</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, sys_exit.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[139]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_exit_exit
</UL>

<P><STRONG><a name="[481]"></a>__I$use$semihosting</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, use_no_semi.o(.text), UNUSED)

<P><STRONG><a name="[482]"></a>__use_no_semihosting_swi</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, use_no_semi.o(.text), UNUSED)

<P><STRONG><a name="[483]"></a>__semihosting_library_function</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, indicate_semi.o(.text), UNUSED)

<P><STRONG><a name="[146]"></a>AppAddDevToResList</STRONG> (Thumb, 70 bytes, Stack size 32 bytes, app_main.o(i.AppAddDevToResList))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = AppAddDevToResList &rArr; DmPrivAddDevToResList &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[147]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLlPrivacySupported
<LI><a href="#[149]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecGetLocalIrk
<LI><a href="#[14a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmPrivAddDevToResList
<LI><a href="#[148]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetKey
</UL>
<BR>[Called By]<UL><LI><a href="#[1b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSecPairCmpl
</UL>

<P><STRONG><a name="[14b]"></a>AppAdvSetData</STRONG> (Thumb, 40 bytes, Stack size 24 bytes, app_slave_leg.o(i.AppAdvSetData))
<BR><BR>[Stack]<UL><LI>Max Depth = 280<LI>Call Chain = AppAdvSetData &rArr; appAdvSetData &rArr; appSetAdvScanDataFrag &rArr; DmAdvSetData &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[14c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveAdvMode
<LI><a href="#[14d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appAdvSetData
</UL>
<BR>[Called By]<UL><LI><a href="#[37e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerSetup
</UL>

<P><STRONG><a name="[14e]"></a>AppAdvStart</STRONG> (Thumb, 54 bytes, Stack size 32 bytes, app_slave_leg.o(i.AppAdvStart))
<BR><BR>[Stack]<UL><LI>Max Depth = 368<LI>Call Chain = AppAdvStart &rArr; appSlaveAdvStart &rArr; appAdvStart &rArr; appSetAdvScanData &rArr; appSetAdvScanDataFrag &rArr; DmAdvSetData &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[14c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveAdvMode
<LI><a href="#[14f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveAdvStart
</UL>
<BR>[Called By]<UL><LI><a href="#[37e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerSetup
<LI><a href="#[1f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerProcMsg
<LI><a href="#[46]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerBtnCback
</UL>

<P><STRONG><a name="[150]"></a>AppAdvStop</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, app_slave_leg.o(i.AppAdvStop))
<BR><BR>[Stack]<UL><LI>Max Depth = 200<LI>Call Chain = AppAdvStop &rArr; appAdvStop &rArr; DmAdvStop &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[14c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveAdvMode
<LI><a href="#[151]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appAdvStop
</UL>
<BR>[Called By]<UL><LI><a href="#[46]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerBtnCback
</UL>

<P><STRONG><a name="[16a]"></a>AppCheckBonded</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, app_main.o(i.AppCheckBonded))
<BR><BR>[Called By]<UL><LI><a href="#[44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppServerConnCback
<LI><a href="#[17e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscStart
<LI><a href="#[166]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscComplete
<LI><a href="#[184]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscPairCmpl
</UL>

<P><STRONG><a name="[152]"></a>AppConnAccept</STRONG> (Thumb, 74 bytes, Stack size 48 bytes, app_slave_leg.o(i.AppConnAccept))
<BR><BR>[Stack]<UL><LI>Max Depth = 344<LI>Call Chain = AppConnAccept &rArr; appConnAccept &rArr; DmConnAccept &rArr; dmConnOpenAccept &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[14c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveAdvMode
<LI><a href="#[153]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appConnAccept
</UL>
<BR>[Called By]<UL><LI><a href="#[46]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerBtnCback
</UL>

<P><STRONG><a name="[154]"></a>AppConnClose</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, app_main.o(i.AppConnClose))
<BR><BR>[Stack]<UL><LI>Max Depth = 184<LI>Call Chain = AppConnClose &rArr; DmConnClose &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[155]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnClose
</UL>
<BR>[Called By]<UL><LI><a href="#[46]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerBtnCback
</UL>

<P><STRONG><a name="[374]"></a>AppConnIsOpen</STRONG> (Thumb, 28 bytes, Stack size 0 bytes, app_main.o(i.AppConnIsOpen))
<BR><BR>[Called By]<UL><LI><a href="#[1f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerProcMsg
<LI><a href="#[46]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerBtnCback
</UL>

<P><STRONG><a name="[33f]"></a>AppDbCheckBonded</STRONG> (Thumb, 36 bytes, Stack size 0 bytes, app_db.o(i.AppDbCheckBonded))
<BR><BR>[Called By]<UL><LI><a href="#[1b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveSecConnOpen
<LI><a href="#[14f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveAdvStart
</UL>

<P><STRONG><a name="[156]"></a>AppDbCheckValidRecord</STRONG> (Thumb, 18 bytes, Stack size 4 bytes, app_db.o(i.AppDbCheckValidRecord))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = AppDbCheckValidRecord
</UL>
<BR>[Calls]<UL><LI><a href="#[157]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbDeleteRecord
</UL>
<BR>[Called By]<UL><LI><a href="#[1b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSecConnClose
</UL>

<P><STRONG><a name="[375]"></a>AppDbDeleteAllRecords</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, app_db.o(i.AppDbDeleteAllRecords))
<BR><BR>[Called By]<UL><LI><a href="#[46]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerBtnCback
</UL>

<P><STRONG><a name="[157]"></a>AppDbDeleteRecord</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, app_db.o(i.AppDbDeleteRecord))
<BR><BR>[Called By]<UL><LI><a href="#[156]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbCheckValidRecord
</UL>

<P><STRONG><a name="[158]"></a>AppDbFindByAddr</STRONG> (Thumb, 64 bytes, Stack size 24 bytes, app_db.o(i.AppDbFindByAddr))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = AppDbFindByAddr &rArr; BdaCmp &rArr; memcmp
</UL>
<BR>[Calls]<UL><LI><a href="#[15a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCmp
<LI><a href="#[159]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmHostAddrType
</UL>
<BR>[Called By]<UL><LI><a href="#[1b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveSecConnOpen
</UL>

<P><STRONG><a name="[15b]"></a>AppDbFindByLtkReq</STRONG> (Thumb, 62 bytes, Stack size 24 bytes, app_db.o(i.AppDbFindByLtkReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = AppDbFindByLtkReq &rArr; memcmp
</UL>
<BR>[Calls]<UL><LI><a href="#[15c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
</UL>
<BR>[Called By]<UL><LI><a href="#[1bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSecFindLtk
</UL>

<P><STRONG><a name="[19d]"></a>AppDbGetCccTbl</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, app_db.o(i.AppDbGetCccTbl))
<BR><BR>[Called By]<UL><LI><a href="#[44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppServerConnCback
</UL>

<P><STRONG><a name="[19b]"></a>AppDbGetCsfRecord</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, app_db.o(i.AppDbGetCsfRecord))
<BR><BR>[Called By]<UL><LI><a href="#[44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppServerConnCback
</UL>

<P><STRONG><a name="[179]"></a>AppDbGetDiscStatus</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, app_db.o(i.AppDbGetDiscStatus))
<BR><BR>[Called By]<UL><LI><a href="#[17e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscStart
<LI><a href="#[171]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscProcAttMsg
</UL>

<P><STRONG><a name="[169]"></a>AppDbGetHdl</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, app_main.o(i.AppDbGetHdl))
<BR><BR>[Called By]<UL><LI><a href="#[24e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GapValueUpdate
<LI><a href="#[44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppServerConnCback
<LI><a href="#[17e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscStart
<LI><a href="#[172]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscRestartDiscovery
<LI><a href="#[171]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscProcAttMsg
<LI><a href="#[166]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscComplete
<LI><a href="#[184]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscPairCmpl
<LI><a href="#[183]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscConnClose
<LI><a href="#[1a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appServerSetSigningInfo
<LI><a href="#[379]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerDiscGapCmpl
<LI><a href="#[45]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerCccCback
</UL>

<P><STRONG><a name="[178]"></a>AppDbGetHdlList</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, app_db.o(i.AppDbGetHdlList))
<BR><BR>[Called By]<UL><LI><a href="#[17e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscStart
<LI><a href="#[171]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscProcAttMsg
</UL>

<P><STRONG><a name="[148]"></a>AppDbGetKey</STRONG> (Thumb, 72 bytes, Stack size 8 bytes, app_db.o(i.AppDbGetKey))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = AppDbGetKey
</UL>
<BR>[Called By]<UL><LI><a href="#[1c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppUpdatePrivacyMode
<LI><a href="#[146]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppAddDevToResList
<LI><a href="#[1b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveResolvedAddrInd
<LI><a href="#[346]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveResolveAddr
<LI><a href="#[33b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSecRspLtk
<LI><a href="#[1a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appServerSetSigningInfo
<LI><a href="#[380]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerSecPairCmpl
</UL>

<P><STRONG><a name="[15d]"></a>AppDbGetNextRecord</STRONG> (Thumb, 58 bytes, Stack size 12 bytes, app_db.o(i.AppDbGetNextRecord))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = AppDbGetNextRecord
</UL>
<BR>[Calls]<UL><LI><a href="#[15e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbRecordInUse
</UL>
<BR>[Called By]<UL><LI><a href="#[1b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveResolvedAddrInd
<LI><a href="#[346]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveResolveAddr
</UL>

<P><STRONG><a name="[1c4]"></a>AppDbGetPeerAddedToRl</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, app_db.o(i.AppDbGetPeerAddedToRl))
<BR><BR>[Called By]<UL><LI><a href="#[1c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppUpdatePrivacyMode
</UL>

<P><STRONG><a name="[334]"></a>AppDbGetPeerAddrRes</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, app_db.o(i.AppDbGetPeerAddrRes))
<BR><BR>[Called By]<UL><LI><a href="#[153]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appConnAccept
</UL>

<P><STRONG><a name="[176]"></a>AppDbGetPeerDbHash</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, app_db.o(i.AppDbGetPeerDbHash))
<BR><BR>[Called By]<UL><LI><a href="#[171]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscProcAttMsg
</UL>

<P><STRONG><a name="[1c5]"></a>AppDbGetPeerRpao</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, app_db.o(i.AppDbGetPeerRpao))
<BR><BR>[Called By]<UL><LI><a href="#[1c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppUpdatePrivacyMode
</UL>

<P><STRONG><a name="[33e]"></a>AppDbGetPeerSignCounter</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, app_db.o(i.AppDbGetPeerSignCounter))
<BR><BR>[Called By]<UL><LI><a href="#[1a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appServerSetSigningInfo
</UL>

<P><STRONG><a name="[194]"></a>AppDbInit</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, app_db.o(i.AppDbInit))
<BR><BR>[Called By]<UL><LI><a href="#[193]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppHandlerInit
</UL>

<P><STRONG><a name="[337]"></a>AppDbIsCacheCheckedByHash</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, app_db.o(i.AppDbIsCacheCheckedByHash))
<BR><BR>[Called By]<UL><LI><a href="#[17e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscStart
<LI><a href="#[184]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscPairCmpl
</UL>

<P><STRONG><a name="[15f]"></a>AppDbNewRecord</STRONG> (Thumb, 110 bytes, Stack size 24 bytes, app_db.o(i.AppDbNewRecord))
<BR><BR>[Stack]<UL><LI>Max Depth = 28<LI>Call Chain = AppDbNewRecord &rArr; __aeabi_memclr4
</UL>
<BR>[Calls]<UL><LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCpy
<LI><a href="#[160]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Called By]<UL><LI><a href="#[171]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscProcAttMsg
<LI><a href="#[1bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSecPairInd
</UL>

<P><STRONG><a name="[15e]"></a>AppDbRecordInUse</STRONG> (Thumb, 42 bytes, Stack size 0 bytes, app_db.o(i.AppDbRecordInUse))
<BR><BR>[Called By]<UL><LI><a href="#[15d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetNextRecord
</UL>

<P><STRONG><a name="[177]"></a>AppDbSetCacheByHash</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, app_db.o(i.AppDbSetCacheByHash))
<BR><BR>[Called By]<UL><LI><a href="#[171]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscProcAttMsg
<LI><a href="#[184]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscPairCmpl
</UL>

<P><STRONG><a name="[1a3]"></a>AppDbSetCccTblValue</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, app_db.o(i.AppDbSetCccTblValue))
<BR><BR>[Called By]<UL><LI><a href="#[44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppServerConnCback
<LI><a href="#[45]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerCccCback
</UL>

<P><STRONG><a name="[1a6]"></a>AppDbSetCsfRecord</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, app_db.o(i.AppDbSetCsfRecord))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = AppDbSetCsfRecord
</UL>
<BR>[Called By]<UL><LI><a href="#[44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppServerConnCback
</UL>

<P><STRONG><a name="[16b]"></a>AppDbSetDiscStatus</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, app_db.o(i.AppDbSetDiscStatus))
<BR><BR>[Called By]<UL><LI><a href="#[172]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscRestartDiscovery
<LI><a href="#[166]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscComplete
<LI><a href="#[184]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscPairCmpl
<LI><a href="#[183]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscConnClose
</UL>

<P><STRONG><a name="[162]"></a>AppDbSetHdlList</STRONG> (Thumb, 20 bytes, Stack size 16 bytes, app_db.o(i.AppDbSetHdlList))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = AppDbSetHdlList
</UL>
<BR>[Calls]<UL><LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[172]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscRestartDiscovery
<LI><a href="#[166]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscComplete
<LI><a href="#[184]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscPairCmpl
</UL>

<P><STRONG><a name="[164]"></a>AppDbSetKey</STRONG> (Thumb, 118 bytes, Stack size 16 bytes, app_db.o(i.AppDbSetKey))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = AppDbSetKey
</UL>
<BR>[Calls]<UL><LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCpy
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[1bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSecStoreKey
</UL>

<P><STRONG><a name="[1c7]"></a>AppDbSetPeerAddedToRl</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, app_db.o(i.AppDbSetPeerAddedToRl))
<BR><BR>[Called By]<UL><LI><a href="#[1c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppUpdatePrivacyMode
<LI><a href="#[1c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appPrivRemDevFromResListInd
<LI><a href="#[1bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appPrivAddDevToResListInd
</UL>

<P><STRONG><a name="[24f]"></a>AppDbSetPeerAddrRes</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, app_db.o(i.AppDbSetPeerAddrRes))
<BR><BR>[Called By]<UL><LI><a href="#[24e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GapValueUpdate
</UL>

<P><STRONG><a name="[165]"></a>AppDbSetPeerDbHash</STRONG> (Thumb, 20 bytes, Stack size 16 bytes, app_db.o(i.AppDbSetPeerDbHash))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = AppDbSetPeerDbHash
</UL>
<BR>[Calls]<UL><LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[171]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscProcAttMsg
</UL>

<P><STRONG><a name="[37a]"></a>AppDbSetPeerRpao</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, app_db.o(i.AppDbSetPeerRpao))
<BR><BR>[Called By]<UL><LI><a href="#[379]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerDiscGapCmpl
</UL>

<P><STRONG><a name="[1a9]"></a>AppDbSetPeerSignCounter</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, app_db.o(i.AppDbSetPeerSignCounter))
<BR><BR>[Called By]<UL><LI><a href="#[44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppServerConnCback
</UL>

<P><STRONG><a name="[33c]"></a>AppDbValidateRecord</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, app_db.o(i.AppDbValidateRecord))
<BR><BR>[Called By]<UL><LI><a href="#[1b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSecPairCmpl
</UL>

<P><STRONG><a name="[166]"></a>AppDiscComplete</STRONG> (Thumb, 136 bytes, Stack size 24 bytes, app_disc.o(i.AppDiscComplete))
<BR><BR>[Stack]<UL><LI>Max Depth = 44<LI>Call Chain = AppDiscComplete &rArr; DmConnSetIdle &rArr; WsfTaskUnlock
</UL>
<BR>[Calls]<UL><LI><a href="#[169]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetHdl
<LI><a href="#[168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufFree
<LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnSetIdle
<LI><a href="#[16a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppCheckBonded
<LI><a href="#[162]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbSetHdlList
<LI><a href="#[16b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbSetDiscStatus
</UL>
<BR>[Called By]<UL><LI><a href="#[47]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerDiscCback
</UL>

<P><STRONG><a name="[16c]"></a>AppDiscConfigure</STRONG> (Thumb, 112 bytes, Stack size 40 bytes, app_disc.o(i.AppDiscConfigure))
<BR><BR>[Stack]<UL><LI>Max Depth = 312<LI>Call Chain = AppDiscConfigure &rArr; AttcDiscConfigStart &rArr; attcDiscConfigNext &rArr; AttcWriteReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[16d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufAlloc
<LI><a href="#[16e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcDiscConfigStart
<LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnSetIdle
</UL>
<BR>[Called By]<UL><LI><a href="#[47]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerDiscCback
</UL>

<P><STRONG><a name="[16f]"></a>AppDiscFindService</STRONG> (Thumb, 88 bytes, Stack size 32 bytes, app_disc.o(i.AppDiscFindService))
<BR><BR>[Stack]<UL><LI>Max Depth = 304<LI>Call Chain = AppDiscFindService &rArr; AttcDiscService &rArr; AttcFindByTypeValueReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[16d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufAlloc
<LI><a href="#[170]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcDiscService
<LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnSetIdle
</UL>
<BR>[Called By]<UL><LI><a href="#[250]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GattDiscover
<LI><a href="#[24d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GapDiscover
<LI><a href="#[24b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FmplIasDiscover
</UL>

<P><STRONG><a name="[1fb]"></a>AppDiscInit</STRONG> (Thumb, 32 bytes, Stack size 0 bytes, app_disc.o(i.AppDiscInit))
<BR><BR>[Called By]<UL><LI><a href="#[1f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BeaconScannerHandlerInit
</UL>

<P><STRONG><a name="[171]"></a>AppDiscProcAttMsg</STRONG> (Thumb, 420 bytes, Stack size 40 bytes, app_disc.o(i.AppDiscProcAttMsg))
<BR><BR>[Stack]<UL><LI>Max Depth = 352<LI>Call Chain = AppDiscProcAttMsg &rArr; AttcDiscCharCmpl &rArr; attcDiscProcDesc &rArr; attcDiscDescriptors &rArr; AttcFindInfoReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[169]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetHdl
<LI><a href="#[17f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnSecLevel
<LI><a href="#[173]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnRole
<LI><a href="#[17b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcDiscServiceCmpl
<LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcDiscConfigCmpl
<LI><a href="#[17c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcDiscCharStart
<LI><a href="#[17d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcDiscCharCmpl
<LI><a href="#[175]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnPeerAddrType
<LI><a href="#[174]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnPeerAddr
<LI><a href="#[165]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbSetPeerDbHash
<LI><a href="#[177]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbSetCacheByHash
<LI><a href="#[15f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbNewRecord
<LI><a href="#[176]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetPeerDbHash
<LI><a href="#[178]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetHdlList
<LI><a href="#[179]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetDiscStatus
<LI><a href="#[17e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscStart
<LI><a href="#[172]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscRestartDiscovery
<LI><a href="#[17a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscCfgStart
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
<LI><a href="#[15c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
</UL>
<BR>[Called By]<UL><LI><a href="#[67]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BeaconScannerHandler
</UL>

<P><STRONG><a name="[181]"></a>AppDiscProcDmMsg</STRONG> (Thumb, 68 bytes, Stack size 8 bytes, app_disc.o(i.AppDiscProcDmMsg))
<BR><BR>[Stack]<UL><LI>Max Depth = 296<LI>Call Chain = AppDiscProcDmMsg &rArr; appDiscPairCmpl &rArr; AttcDiscConfigResume &rArr; attcDiscConfigNext &rArr; AttcWriteReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[185]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscPairFail
<LI><a href="#[184]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscPairCmpl
<LI><a href="#[186]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscEncryptInd
<LI><a href="#[182]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscConnOpen
<LI><a href="#[183]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscConnClose
</UL>
<BR>[Called By]<UL><LI><a href="#[67]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BeaconScannerHandler
</UL>

<P><STRONG><a name="[202]"></a>AppDiscRegister</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, app_disc.o(i.AppDiscRegister))
<BR><BR>[Called By]<UL><LI><a href="#[1fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BeaconScannerStart
</UL>

<P><STRONG><a name="[187]"></a>AppDiscServiceChanged</STRONG> (Thumb, 148 bytes, Stack size 40 bytes, app_disc.o(i.AppDiscServiceChanged))
<BR><BR>[Stack]<UL><LI>Max Depth = 328<LI>Call Chain = AppDiscServiceChanged &rArr; appDiscRestartDiscovery &rArr; appDiscStart &rArr; AttcReadByTypeReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[172]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscRestartDiscovery
</UL>
<BR>[Called By]<UL><LI><a href="#[251]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GattValueUpdate
</UL>

<P><STRONG><a name="[378]"></a>AppDiscSetHdlList</STRONG> (Thumb, 16 bytes, Stack size 12 bytes, app_disc.o(i.AppDiscSetHdlList))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = AppDiscSetHdlList
</UL>
<BR>[Called By]<UL><LI><a href="#[47]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerDiscCback
</UL>

<P><STRONG><a name="[188]"></a>AppHandleNumericComparison</STRONG> (Thumb, 28 bytes, Stack size 16 bytes, app_main.o(i.AppHandleNumericComparison))
<BR><BR>[Stack]<UL><LI>Max Depth = 192<LI>Call Chain = AppHandleNumericComparison &rArr; DmSecCompareRsp &rArr; SmpDmMsgSend &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[189]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecGetCompareValue
<LI><a href="#[18b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecCompareRsp
<LI><a href="#[18a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppUiDisplayConfirmValue
</UL>
<BR>[Called By]<UL><LI><a href="#[1f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerProcMsg
</UL>

<P><STRONG><a name="[18c]"></a>AppHandlePasskey</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, app_main.o(i.AppHandlePasskey))
<BR><BR>[Stack]<UL><LI>Max Depth = 240<LI>Call Chain = AppHandlePasskey &rArr; SecRand &rArr; HciLeRandCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[18d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecRand
<LI><a href="#[18e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecAuthRsp
<LI><a href="#[190]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppUiAction
<LI><a href="#[18f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppUiDisplayPasskey
</UL>
<BR>[Called By]<UL><LI><a href="#[1f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerProcMsg
</UL>

<P><STRONG><a name="[66]"></a>AppHandler</STRONG> (Thumb, 60 bytes, Stack size 16 bytes, app_main.o(i.AppHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = AppHandler &rArr; appProcMsg &rArr; appUiBtnPoll
</UL>
<BR>[Calls]<UL><LI><a href="#[192]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppUiBtnPressed
<LI><a href="#[191]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appProcMsg
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio_task.o(i.exactle_stack_init)
</UL>
<P><STRONG><a name="[193]"></a>AppHandlerInit</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, app_main.o(i.AppHandlerInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = AppHandlerInit
</UL>
<BR>[Calls]<UL><LI><a href="#[194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbInit
</UL>
<BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[1fa]"></a>AppMasterInit</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, app_master.o(i.AppMasterInit))
<BR><BR>[Called By]<UL><LI><a href="#[1f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BeaconScannerHandlerInit
</UL>

<P><STRONG><a name="[195]"></a>AppScanStart</STRONG> (Thumb, 50 bytes, Stack size 32 bytes, app_master_leg.o(i.AppScanStart))
<BR><BR>[Stack]<UL><LI>Max Depth = 224<LI>Call Chain = AppScanStart &rArr; DmScanStart &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[198]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmScanStart
<LI><a href="#[197]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmScanSetInterval
<LI><a href="#[196]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appMasterScanMode
</UL>
<BR>[Called By]<UL><LI><a href="#[1f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerProcMsg
</UL>

<P><STRONG><a name="[199]"></a>AppScanStop</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, app_master_leg.o(i.AppScanStop))
<BR><BR>[Stack]<UL><LI>Max Depth = 168<LI>Call Chain = AppScanStop &rArr; DmScanStop &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[19a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmScanStop
<LI><a href="#[196]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appMasterScanMode
</UL>
<BR>[Called By]<UL><LI><a href="#[1f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerProcMsg
</UL>

<P><STRONG><a name="[44]"></a>AppServerConnCback</STRONG> (Thumb, 268 bytes, Stack size 40 bytes, app_server.o(i.AppServerConnCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 312<LI>Call Chain = AppServerConnCback &rArr; GattSendServiceChangedInd &rArr; AttsHandleValueInd &rArr; attsHandleValueIndNtf &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsCsfGetFeatures
<LI><a href="#[19f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GattSendServiceChangedInd
<LI><a href="#[169]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetHdl
<LI><a href="#[1a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsCsfGetChangeAwareState
<LI><a href="#[19c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsCsfConnOpen
<LI><a href="#[1a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsGetCccTableLen
<LI><a href="#[19e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsCccInitTable
<LI><a href="#[1a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsCccGet
<LI><a href="#[1a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsCccClearTable
<LI><a href="#[1a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsGetSignCounter
<LI><a href="#[1a3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbSetCccTblValue
<LI><a href="#[16a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppCheckBonded
<LI><a href="#[1a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbSetPeerSignCounter
<LI><a href="#[1a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbSetCsfRecord
<LI><a href="#[19b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetCsfRecord
<LI><a href="#[19d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetCccTbl
<LI><a href="#[1a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appServerSetSigningInfo
</UL>
<BR>[Address Reference Count : 1]<UL><LI> beaconscanner_main.o(i.BeaconScannerStart)
</UL>
<P><STRONG><a name="[33d]"></a>AppSetBondable</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, app_slave.o(i.AppSetBondable))
<BR><BR>[Called By]<UL><LI><a href="#[14f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveAdvStart
<LI><a href="#[1b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSecPairCmpl
<LI><a href="#[46]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerBtnCback
</UL>

<P><STRONG><a name="[1aa]"></a>AppSlaveInit</STRONG> (Thumb, 82 bytes, Stack size 8 bytes, app_slave.o(i.AppSlaveInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = AppSlaveInit
</UL>
<BR>[Calls]<UL><LI><a href="#[1ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveAdvModeInit
</UL>
<BR>[Called By]<UL><LI><a href="#[1f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BeaconScannerHandlerInit
</UL>

<P><STRONG><a name="[332]"></a>AppSlaveIsAdvertising</STRONG> (Thumb, 28 bytes, Stack size 0 bytes, app_slave.o(i.AppSlaveIsAdvertising))
<BR><BR>[Called By]<UL><LI><a href="#[151]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appAdvStop
</UL>

<P><STRONG><a name="[1ac]"></a>AppSlaveProcDmMsg</STRONG> (Thumb, 190 bytes, Stack size 16 bytes, app_slave.o(i.AppSlaveProcDmMsg))
<BR><BR>[Stack]<UL><LI>Max Depth = 380<LI>Call Chain = AppSlaveProcDmMsg &rArr; HciDrvRadioBoot &rArr; am_hal_ble_boot &rArr; am_hal_ble_patch_complete &rArr; am_hal_ble_plf_reg_read &rArr; am_hal_ble_blocking_hci_write &rArr; am_hal_ble_blocking_transfer &rArr; am_hal_ble_cmd_write
</UL>
<BR>[Calls]<UL><LI><a href="#[1b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvRadioBoot
<LI><a href="#[1b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmDevReset
<LI><a href="#[1b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveResolvedAddrInd
<LI><a href="#[1b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveRemoteConnParamReq
<LI><a href="#[1b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveConnUpdateTimeout
<LI><a href="#[1af]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveConnUpdate
<LI><a href="#[1ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveConnOpen
<LI><a href="#[1ae]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveConnClose
<LI><a href="#[1ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveAdvModeInit
</UL>
<BR>[Called By]<UL><LI><a href="#[67]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BeaconScannerHandler
</UL>

<P><STRONG><a name="[1b5]"></a>AppSlaveSecProcDmMsg</STRONG> (Thumb, 184 bytes, Stack size 16 bytes, app_slave.o(i.AppSlaveSecProcDmMsg))
<BR><BR>[Stack]<UL><LI>Max Depth = 248<LI>Call Chain = AppSlaveSecProcDmMsg &rArr; appSecPairCmpl &rArr; AppAddDevToResList &rArr; DmPrivAddDevToResList &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveSecConnOpen
<LI><a href="#[1b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSecConnClose
<LI><a href="#[1bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSecStoreKey
<LI><a href="#[1bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSecPairInd
<LI><a href="#[1b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSecPairFailed
<LI><a href="#[1b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSecPairCmpl
<LI><a href="#[1bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSecFindLtk
<LI><a href="#[1ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSecEncryptInd
<LI><a href="#[1be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appPrivSetAddrResEnableInd
<LI><a href="#[1c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appPrivRemDevFromResListInd
<LI><a href="#[1bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appPrivAddDevToResListInd
</UL>
<BR>[Called By]<UL><LI><a href="#[67]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BeaconScannerHandler
</UL>

<P><STRONG><a name="[1c1]"></a>AppSlaveSecurityReq</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, app_slave.o(i.AppSlaveSecurityReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 184<LI>Call Chain = AppSlaveSecurityReq &rArr; DmSecSlaveReq &rArr; SmpDmMsgSend &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[17f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnSecLevel
<LI><a href="#[1c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecSlaveReq
</UL>
<BR>[Called By]<UL><LI><a href="#[47]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerDiscCback
</UL>

<P><STRONG><a name="[190]"></a>AppUiAction</STRONG> (Thumb, 112 bytes, Stack size 8 bytes, app_ui.o(i.AppUiAction))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = AppUiAction
</UL>
<BR>[Called By]<UL><LI><a href="#[18c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppHandlePasskey
<LI><a href="#[1f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerProcMsg
<LI><a href="#[373]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerAlert
</UL>

<P><STRONG><a name="[192]"></a>AppUiBtnPressed</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, app_ui.o(i.AppUiBtnPressed))
<BR><BR>[Called By]<UL><LI><a href="#[66]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppHandler
</UL>

<P><STRONG><a name="[201]"></a>AppUiBtnRegister</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, app_ui.o(i.AppUiBtnRegister))
<BR><BR>[Called By]<UL><LI><a href="#[1fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BeaconScannerStart
</UL>

<P><STRONG><a name="[382]"></a>AppUiBtnTest</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, app_ui.o(i.AppUiBtnTest))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = AppUiBtnTest
</UL>
<BR>[Called By]<UL><LI><a href="#[68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;button_handler
</UL>

<P><STRONG><a name="[18a]"></a>AppUiDisplayConfirmValue</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, app_ui.o(i.AppUiDisplayConfirmValue))
<BR><BR>[Called By]<UL><LI><a href="#[188]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppHandleNumericComparison
</UL>

<P><STRONG><a name="[18f]"></a>AppUiDisplayPasskey</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, app_ui.o(i.AppUiDisplayPasskey))
<BR><BR>[Called By]<UL><LI><a href="#[18c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppHandlePasskey
</UL>

<P><STRONG><a name="[381]"></a>AppUiDisplayRssi</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, app_ui.o(i.AppUiDisplayRssi))
<BR><BR>[Called By]<UL><LI><a href="#[1f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerProcMsg
</UL>

<P><STRONG><a name="[1c3]"></a>AppUpdatePrivacyMode</STRONG> (Thumb, 60 bytes, Stack size 16 bytes, app_main.o(i.AppUpdatePrivacyMode))
<BR><BR>[Stack]<UL><LI>Max Depth = 192<LI>Call Chain = AppUpdatePrivacyMode &rArr; DmPrivSetPrivacyMode &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmPrivSetPrivacyMode
<LI><a href="#[1c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbSetPeerAddedToRl
<LI><a href="#[1c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetPeerRpao
<LI><a href="#[1c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetPeerAddedToRl
<LI><a href="#[148]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetKey
</UL>
<BR>[Called By]<UL><LI><a href="#[1ae]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveConnClose
</UL>

<P><STRONG><a name="[1ff]"></a>AttConnRegister</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, att_main.o(i.AttConnRegister))
<BR><BR>[Called By]<UL><LI><a href="#[1fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BeaconScannerStart
</UL>

<P><STRONG><a name="[64]"></a>AttHandler</STRONG> (Thumb, 42 bytes, Stack size 16 bytes, att_main.o(i.AttHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = AttHandler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio_task.o(i.exactle_stack_init)
</UL>
<P><STRONG><a name="[1c8]"></a>AttHandlerInit</STRONG> (Thumb, 38 bytes, Stack size 8 bytes, att_main.o(i.AttHandlerInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 28<LI>Call Chain = AttHandlerInit &rArr; DmConnRegister &rArr; WsfTaskUnlock
</UL>
<BR>[Calls]<UL><LI><a href="#[1c9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cRegister
<LI><a href="#[1ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnRegister
</UL>
<BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[1cb]"></a>AttMsgFree</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, att_main.o(i.AttMsgFree))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = AttMsgFree &rArr; WsfMsgFree &rArr; WsfBufFree
</UL>
<BR>[Calls]<UL><LI><a href="#[1cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgFree
</UL>
<BR>[Called By]<UL><LI><a href="#[1f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsHandleValueIndNtf
</UL>

<P><STRONG><a name="[1cd]"></a>AttRegister</STRONG> (Thumb, 40 bytes, Stack size 16 bytes, att_main.o(i.AttRegister))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = AttRegister &rArr; attExecCallback
</UL>
<BR>[Calls]<UL><LI><a href="#[1ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciGetMaxRxAclLen
<LI><a href="#[1cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attExecCallback
</UL>
<BR>[Called By]<UL><LI><a href="#[1fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BeaconScannerStart
</UL>

<P><STRONG><a name="[17d]"></a>AttcDiscCharCmpl</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, attc_disc.o(i.AttcDiscCharCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 312<LI>Call Chain = AttcDiscCharCmpl &rArr; attcDiscProcDesc &rArr; attcDiscDescriptors &rArr; AttcFindInfoReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcDiscProcDesc
<LI><a href="#[1d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcDiscProcChar
<LI><a href="#[1d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr
</UL>
<BR>[Called By]<UL><LI><a href="#[171]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscProcAttMsg
</UL>

<P><STRONG><a name="[17c]"></a>AttcDiscCharStart</STRONG> (Thumb, 36 bytes, Stack size 24 bytes, attc_disc.o(i.AttcDiscCharStart))
<BR><BR>[Stack]<UL><LI>Max Depth = 264<LI>Call Chain = AttcDiscCharStart &rArr; AttcReadByTypeReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1d3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcReadByTypeReq
</UL>
<BR>[Called By]<UL><LI><a href="#[171]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscProcAttMsg
</UL>

<P><STRONG><a name="[180]"></a>AttcDiscConfigCmpl</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, attc_disc.o(i.AttcDiscConfigCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 272<LI>Call Chain = AttcDiscConfigCmpl &rArr; attcDiscConfigNext &rArr; AttcWriteReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcDiscConfigNext
</UL>
<BR>[Called By]<UL><LI><a href="#[171]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscProcAttMsg
</UL>

<P><STRONG><a name="[1d5]"></a>AttcDiscConfigResume</STRONG> (Thumb, 16 bytes, Stack size 16 bytes, attc_disc.o(i.AttcDiscConfigResume))
<BR><BR>[Stack]<UL><LI>Max Depth = 272<LI>Call Chain = AttcDiscConfigResume &rArr; attcDiscConfigNext &rArr; AttcWriteReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcDiscConfigNext
</UL>
<BR>[Called By]<UL><LI><a href="#[184]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscPairCmpl
<LI><a href="#[186]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscEncryptInd
</UL>

<P><STRONG><a name="[16e]"></a>AttcDiscConfigStart</STRONG> (Thumb, 20 bytes, Stack size 16 bytes, attc_disc.o(i.AttcDiscConfigStart))
<BR><BR>[Stack]<UL><LI>Max Depth = 272<LI>Call Chain = AttcDiscConfigStart &rArr; attcDiscConfigNext &rArr; AttcWriteReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcDiscConfigNext
</UL>
<BR>[Called By]<UL><LI><a href="#[16c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscConfigure
</UL>

<P><STRONG><a name="[170]"></a>AttcDiscService</STRONG> (Thumb, 36 bytes, Stack size 32 bytes, attc_disc.o(i.AttcDiscService))
<BR><BR>[Stack]<UL><LI>Max Depth = 272<LI>Call Chain = AttcDiscService &rArr; AttcFindByTypeValueReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcFindByTypeValueReq
</UL>
<BR>[Called By]<UL><LI><a href="#[16f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscFindService
</UL>

<P><STRONG><a name="[17b]"></a>AttcDiscServiceCmpl</STRONG> (Thumb, 60 bytes, Stack size 8 bytes, attc_disc.o(i.AttcDiscServiceCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = AttcDiscServiceCmpl
</UL>
<BR>[Called By]<UL><LI><a href="#[171]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscProcAttMsg
</UL>

<P><STRONG><a name="[1d6]"></a>AttcFindByTypeValueReq</STRONG> (Thumb, 96 bytes, Stack size 40 bytes, attc_read.o(i.AttcFindByTypeValueReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 240<LI>Call Chain = AttcFindByTypeValueReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendMsg
<LI><a href="#[1d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attMsgAlloc
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[170]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcDiscService
</UL>

<P><STRONG><a name="[1d9]"></a>AttcFindInfoReq</STRONG> (Thumb, 58 bytes, Stack size 32 bytes, attc_proc.o(i.AttcFindInfoReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 232<LI>Call Chain = AttcFindInfoReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendMsg
<LI><a href="#[1d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attMsgAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[351]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcDiscDescriptors
</UL>

<P><STRONG><a name="[1da]"></a>AttcIndConfirm</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, attc_proc.o(i.AttcIndConfirm))
<BR><BR>[Stack]<UL><LI>Max Depth = 296<LI>Call Chain = AttcIndConfirm &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attMsgAlloc
<LI><a href="#[1dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cDataReq
<LI><a href="#[1db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcCcbByHandle
</UL>
<BR>[Called By]<UL><LI><a href="#[a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcCtrlCback
</UL>

<P><STRONG><a name="[3b3]"></a>AttcInit</STRONG> (Thumb, 62 bytes, Stack size 0 bytes, attc_main.o(i.AttcInit))
<BR><BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[1dd]"></a>AttcMtuReq</STRONG> (Thumb, 58 bytes, Stack size 24 bytes, attc_proc.o(i.AttcMtuReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 224<LI>Call Chain = AttcMtuReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendMsg
<LI><a href="#[1d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attMsgAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcConnCback
</UL>

<P><STRONG><a name="[1d3]"></a>AttcReadByTypeReq</STRONG> (Thumb, 80 bytes, Stack size 40 bytes, attc_read.o(i.AttcReadByTypeReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 240<LI>Call Chain = AttcReadByTypeReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendMsg
<LI><a href="#[1d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attMsgAlloc
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[17c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcDiscCharStart
<LI><a href="#[17e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscStart
<LI><a href="#[185]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscPairFail
</UL>

<P><STRONG><a name="[1de]"></a>AttcReadReq</STRONG> (Thumb, 58 bytes, Stack size 24 bytes, attc_proc.o(i.AttcReadReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 224<LI>Call Chain = AttcReadReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendMsg
<LI><a href="#[1d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attMsgAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[1d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcDiscConfigNext
</UL>

<P><STRONG><a name="[1df]"></a>AttcWriteCmd</STRONG> (Thumb, 80 bytes, Stack size 32 bytes, attc_write.o(i.AttcWriteCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 232<LI>Call Chain = AttcWriteCmd &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendMsg
<LI><a href="#[1d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attMsgAlloc
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[24c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FmplSendAlert
</UL>

<P><STRONG><a name="[1e0]"></a>AttcWriteReq</STRONG> (Thumb, 80 bytes, Stack size 32 bytes, attc_proc.o(i.AttcWriteReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 232<LI>Call Chain = AttcWriteReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendMsg
<LI><a href="#[1d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attMsgAlloc
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[1d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcDiscConfigNext
</UL>

<P><STRONG><a name="[1e1]"></a>AttsAddGroup</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, atts_main.o(i.AttsAddGroup))
<BR><BR>[Stack]<UL><LI>Max Depth = 368<LI>Call Chain = AttsAddGroup &rArr; attsCsfSetHashUpdateStatus &rArr; attsCheckPendDbHashReadRsp &rArr; attsErrRsp &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfQueueInsert
<LI><a href="#[1e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskUnlock
<LI><a href="#[1e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskLock
<LI><a href="#[1e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsCsfSetHashUpdateStatus
</UL>
<BR>[Called By]<UL><LI><a href="#[203]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SvcCoreAddGroup
<LI><a href="#[205]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SvcPxAddGroup
</UL>

<P><STRONG><a name="[1e6]"></a>AttsCalculateDbHash</STRONG> (Thumb, 250 bytes, Stack size 56 bytes, atts_main.o(i.AttsCalculateDbHash))
<BR><BR>[Stack]<UL><LI>Max Depth = 424<LI>Call Chain = AttsCalculateDbHash &rArr; AttsHashDatabaseString &rArr; SecCmac &rArr; secCmacGenSubkey1 &rArr; SecLeEncryptCmd &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[16d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufAlloc
<LI><a href="#[1e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsIsHashableAttr
<LI><a href="#[1e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsHashDatabaseString
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[1f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerProcMsg
</UL>

<P><STRONG><a name="[1a7]"></a>AttsCccClearTable</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, atts_ccc.o(i.AttsCccClearTable))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = AttsCccClearTable &rArr; attsCccFreeTbl &rArr; WsfBufFree
</UL>
<BR>[Calls]<UL><LI><a href="#[1e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsCccFreeTbl
</UL>
<BR>[Called By]<UL><LI><a href="#[44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppServerConnCback
</UL>

<P><STRONG><a name="[1ea]"></a>AttsCccEnabled</STRONG> (Thumb, 44 bytes, Stack size 16 bytes, atts_ccc.o(i.AttsCccEnabled))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = AttsCccEnabled &rArr; AttsCccGet
</UL>
<BR>[Calls]<UL><LI><a href="#[1a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsCccGet
<LI><a href="#[17f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnSecLevel
</UL>
<BR>[Called By]<UL><LI><a href="#[19f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GattSendServiceChangedInd
</UL>

<P><STRONG><a name="[1a2]"></a>AttsCccGet</STRONG> (Thumb, 26 bytes, Stack size 16 bytes, atts_ccc.o(i.AttsCccGet))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = AttsCccGet
</UL>
<BR>[Calls]<UL><LI><a href="#[1eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsCccGetTbl
</UL>
<BR>[Called By]<UL><LI><a href="#[1ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsCccEnabled
<LI><a href="#[44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppServerConnCback
</UL>

<P><STRONG><a name="[19e]"></a>AttsCccInitTable</STRONG> (Thumb, 78 bytes, Stack size 24 bytes, atts_ccc.o(i.AttsCccInitTable))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = AttsCccInitTable &rArr; attsCccCback
</UL>
<BR>[Calls]<UL><LI><a href="#[1ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsCccCback
<LI><a href="#[1ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsCccAllocTbl
<LI><a href="#[1d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr
</UL>
<BR>[Called By]<UL><LI><a href="#[44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppServerConnCback
</UL>

<P><STRONG><a name="[200]"></a>AttsCccRegister</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, atts_ccc.o(i.AttsCccRegister))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = AttsCccRegister
</UL>
<BR>[Called By]<UL><LI><a href="#[1fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BeaconScannerStart
</UL>

<P><STRONG><a name="[19c]"></a>AttsCsfConnOpen</STRONG> (Thumb, 40 bytes, Stack size 8 bytes, atts_csf.o(i.AttsCsfConnOpen))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = AttsCsfConnOpen
</UL>
<BR>[Called By]<UL><LI><a href="#[44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppServerConnCback
</UL>

<P><STRONG><a name="[1a5]"></a>AttsCsfGetChangeAwareState</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, atts_csf.o(i.AttsCsfGetChangeAwareState))
<BR><BR>[Called By]<UL><LI><a href="#[44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppServerConnCback
</UL>

<P><STRONG><a name="[1a4]"></a>AttsCsfGetFeatures</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, atts_csf.o(i.AttsCsfGetFeatures))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = AttsCsfGetFeatures
</UL>
<BR>[Calls]<UL><LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppServerConnCback
</UL>

<P><STRONG><a name="[1ee]"></a>AttsGetAttr</STRONG> (Thumb, 48 bytes, Stack size 32 bytes, atts_main.o(i.AttsGetAttr))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = AttsGetAttr &rArr; attsFindByHandle
</UL>
<BR>[Calls]<UL><LI><a href="#[1ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsFindByHandle
</UL>
<BR>[Called By]<UL><LI><a href="#[377]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerClose
</UL>

<P><STRONG><a name="[1a1]"></a>AttsGetCccTableLen</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, atts_ccc.o(i.AttsGetCccTableLen))
<BR><BR>[Called By]<UL><LI><a href="#[44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppServerConnCback
</UL>

<P><STRONG><a name="[1a8]"></a>AttsGetSignCounter</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, atts_sign.o(i.AttsGetSignCounter))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = AttsGetSignCounter
</UL>
<BR>[Calls]<UL><LI><a href="#[1f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsSignCcbByConnId
</UL>
<BR>[Called By]<UL><LI><a href="#[44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppServerConnCback
</UL>

<P><STRONG><a name="[1f1]"></a>AttsHandleValueInd</STRONG> (Thumb, 36 bytes, Stack size 32 bytes, atts_ind.o(i.AttsHandleValueInd))
<BR><BR>[Stack]<UL><LI>Max Depth = 248<LI>Call Chain = AttsHandleValueInd &rArr; attsHandleValueIndNtf &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsHandleValueIndNtf
</UL>
<BR>[Called By]<UL><LI><a href="#[19f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GattSendServiceChangedInd
</UL>

<P><STRONG><a name="[1e8]"></a>AttsHashDatabaseString</STRONG> (Thumb, 34 bytes, Stack size 24 bytes, atts_main.o(i.AttsHashDatabaseString))
<BR><BR>[Stack]<UL><LI>Max Depth = 368<LI>Call Chain = AttsHashDatabaseString &rArr; SecCmac &rArr; secCmacGenSubkey1 &rArr; SecLeEncryptCmd &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecCmac
</UL>
<BR>[Called By]<UL><LI><a href="#[1e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsCalculateDbHash
</UL>

<P><STRONG><a name="[3b2]"></a>AttsIndInit</STRONG> (Thumb, 46 bytes, Stack size 0 bytes, atts_ind.o(i.AttsIndInit))
<BR><BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[3b1]"></a>AttsInit</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, atts_main.o(i.AttsInit))
<BR><BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[1f4]"></a>AttsSetAttr</STRONG> (Thumb, 80 bytes, Stack size 32 bytes, atts_main.o(i.AttsSetAttr))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = AttsSetAttr &rArr; attsFindByHandle
</UL>
<BR>[Calls]<UL><LI><a href="#[1e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskUnlock
<LI><a href="#[1e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskLock
<LI><a href="#[1ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsFindByHandle
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[36d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcessDatabaseHashUpdate
</UL>

<P><STRONG><a name="[1f5]"></a>AttsSetCsrk</STRONG> (Thumb, 26 bytes, Stack size 16 bytes, atts_sign.o(i.AttsSetCsrk))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = AttsSetCsrk
</UL>
<BR>[Calls]<UL><LI><a href="#[1f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsSignCcbByConnId
</UL>
<BR>[Called By]<UL><LI><a href="#[1a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appServerSetSigningInfo
</UL>

<P><STRONG><a name="[1f6]"></a>AttsSetSignCounter</STRONG> (Thumb, 16 bytes, Stack size 16 bytes, atts_sign.o(i.AttsSetSignCounter))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = AttsSetSignCounter
</UL>
<BR>[Calls]<UL><LI><a href="#[1f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsSignCcbByConnId
</UL>
<BR>[Called By]<UL><LI><a href="#[1a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appServerSetSigningInfo
</UL>

<P><STRONG><a name="[28b]"></a>BdaClr</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, bda.o(i.BdaClr))
<BR><BR>[Called By]<UL><LI><a href="#[28a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetAdvParamCmd
</UL>

<P><STRONG><a name="[15a]"></a>BdaCmp</STRONG> (Thumb, 26 bytes, Stack size 16 bytes, bda.o(i.BdaCmp))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = BdaCmp &rArr; memcmp
</UL>
<BR>[Calls]<UL><LI><a href="#[15c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
</UL>
<BR>[Called By]<UL><LI><a href="#[396]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnCcbByBdAddr
<LI><a href="#[2be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpDbGetRecord
<LI><a href="#[158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbFindByAddr
</UL>

<P><STRONG><a name="[161]"></a>BdaCpy</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, bda.o(i.BdaCpy))
<BR><BR>[Called By]<UL><LI><a href="#[28e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetPrivacyModeCmd
<LI><a href="#[28a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetAdvParamCmd
<LI><a href="#[286]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeRemoveDeviceFromResolvingList
<LI><a href="#[277]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeAddDeviceToResolvingListCmd
<LI><a href="#[21b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeAddDevWhiteListCmd
<LI><a href="#[9b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtParseLeScanReqRcvd
<LI><a href="#[85]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtParseLeReadPeerResAddrCmdCmpl
<LI><a href="#[86]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtParseLeReadLocalResAddrCmdCmpl
<LI><a href="#[9c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtParseLePerAdvSyncEst
<LI><a href="#[70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtParseLeEnhancedConnCmpl
<LI><a href="#[6f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtParseLeConnCmpl
<LI><a href="#[255]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreResetSequence
<LI><a href="#[3ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessLeExtAdvReport
<LI><a href="#[3cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessLeDirectAdvReport
<LI><a href="#[3cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessLeAdvReport
<LI><a href="#[389]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvGenConnCmpl
<LI><a href="#[207]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmAdvConfig
<LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActConnOpened
<LI><a href="#[212]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnOpenAccept
<LI><a href="#[395]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnCcbAlloc
<LI><a href="#[38c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvStartDirected
<LI><a href="#[1c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmPrivSetPrivacyMode
<LI><a href="#[224]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmPrivResolveAddr
<LI><a href="#[14a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmPrivAddDevToResList
<LI><a href="#[426]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendKey
<LI><a href="#[418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpProcRcvKey
<LI><a href="#[414]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpDbAddDevice
<LI><a href="#[164]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbSetKey
<LI><a href="#[15f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbNewRecord
<LI><a href="#[380]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerSecPairCmpl
<LI><a href="#[37c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerOpen
</UL>

<P><STRONG><a name="[1f7]"></a>BdaIsZeros</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, bda.o(i.BdaIsZeros))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = BdaIsZeros &rArr; memcmp
</UL>
<BR>[Calls]<UL><LI><a href="#[15c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
</UL>
<BR>[Called By]<UL><LI><a href="#[408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCalcC1Part1
<LI><a href="#[41b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScCatResponderBdAddr
<LI><a href="#[41a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScCatInitiatorBdAddr
<LI><a href="#[409]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCalcC1Part2
</UL>

<P><STRONG><a name="[67]"></a>BeaconScannerHandler</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, beaconscanner_main.o(i.BeaconScannerHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 788<LI>Call Chain = BeaconScannerHandler &rArr; beaconScannerProcMsg &rArr; DmSecGenerateEccKeyReq &rArr; SecEccGenKey &rArr; uECC_make_key &rArr; EccPoint_compute_public_key &rArr; EccPoint_mult &rArr; XYcZ_initial_double &rArr; EccPoint_double_jacobian &rArr; vli_modSquare_fast &rArr; vli_square &rArr; mul2add
</UL>
<BR>[Calls]<UL><LI><a href="#[1b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppSlaveSecProcDmMsg
<LI><a href="#[1ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppSlaveProcDmMsg
<LI><a href="#[181]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscProcDmMsg
<LI><a href="#[171]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscProcAttMsg
<LI><a href="#[1f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerProcMsg
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio_task.o(i.exactle_stack_init)
</UL>
<P><STRONG><a name="[1f9]"></a>BeaconScannerHandlerInit</STRONG> (Thumb, 88 bytes, Stack size 8 bytes, beaconscanner_main.o(i.BeaconScannerHandlerInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = BeaconScannerHandlerInit &rArr; DmSecSetLocalIrk &rArr; WsfTaskUnlock
</UL>
<BR>[Calls]<UL><LI><a href="#[1fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecSetLocalIrk
<LI><a href="#[1aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppSlaveInit
<LI><a href="#[1fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppMasterInit
<LI><a href="#[1fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscInit
</UL>
<BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[1fd]"></a>BeaconScannerStart</STRONG> (Thumb, 72 bytes, Stack size 8 bytes, beaconscanner_main.o(i.BeaconScannerStart))
<BR><BR>[Stack]<UL><LI>Max Depth = 384<LI>Call Chain = BeaconScannerStart &rArr; SvcCoreAddGroup &rArr; AttsAddGroup &rArr; attsCsfSetHashUpdateStatus &rArr; attsCheckPendDbHashReadRsp &rArr; attsErrRsp &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmDevReset
<LI><a href="#[200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsCccRegister
<LI><a href="#[1ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnRegister
<LI><a href="#[1cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttRegister
<LI><a href="#[1ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttConnRegister
<LI><a href="#[1fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmRegister
<LI><a href="#[203]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SvcCoreAddGroup
<LI><a href="#[201]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppUiBtnRegister
<LI><a href="#[202]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscRegister
<LI><a href="#[204]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SvcPxCbackRegister
<LI><a href="#[205]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SvcPxAddGroup
</UL>
<BR>[Called By]<UL><LI><a href="#[6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioTask
</UL>

<P><STRONG><a name="[206]"></a>Calc128Cpy</STRONG> (Thumb, 18 bytes, Stack size 16 bytes, calc128.o(i.Calc128Cpy))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Calc128Cpy
</UL>
<BR>[Calls]<UL><LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[1f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecCmac
<LI><a href="#[235]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecLtkRsp
<LI><a href="#[ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmSecLescMsgHandler
<LI><a href="#[224]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmPrivResolveAddr
<LI><a href="#[14a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmPrivAddDevToResList
<LI><a href="#[41f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActJwncDisplay
<LI><a href="#[11e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActDHKeyCalcF6Eb
<LI><a href="#[11b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActCalcF5MacKey
<LI><a href="#[11c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActCalcF5Ltk
<LI><a href="#[426]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendKey
<LI><a href="#[418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpProcRcvKey
<LI><a href="#[2d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScCat128
<LI><a href="#[f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActStoreLescPin
<LI><a href="#[115]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActOobCalcCa
<LI><a href="#[106]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActJwncSetup
<LI><a href="#[11f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActDHKeyCheckSend
<LI><a href="#[52]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecCmacHciCback
<LI><a href="#[2b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;secCmacProcessBlock
<LI><a href="#[2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;secCmacGenSubkey2
<LI><a href="#[51]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecAesHciCback
</UL>

<P><STRONG><a name="[412]"></a>Calc128Cpy64</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, calc128.o(i.Calc128Cpy64))
<BR><BR>[Called By]<UL><LI><a href="#[411]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCalcS1
</UL>

<P><STRONG><a name="[403]"></a>Calc128Xor</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, calc128.o(i.Calc128Xor))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = Calc128Xor
</UL>
<BR>[Called By]<UL><LI><a href="#[2b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;secCmacProcessBlock
</UL>

<P><STRONG><a name="[207]"></a>DmAdvConfig</STRONG> (Thumb, 54 bytes, Stack size 24 bytes, dm_adv.o(i.DmAdvConfig))
<BR><BR>[Stack]<UL><LI>Max Depth = 176<LI>Call Chain = DmAdvConfig &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCpy
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
</UL>
<BR>[Called By]<UL><LI><a href="#[153]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appConnAccept
<LI><a href="#[32e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appAdvStart
</UL>

<P><STRONG><a name="[20a]"></a>DmAdvInit</STRONG> (Thumb, 32 bytes, Stack size 8 bytes, dm_adv_leg.o(i.DmAdvInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = DmAdvInit &rArr; WsfTaskUnlock
</UL>
<BR>[Calls]<UL><LI><a href="#[1e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskUnlock
<LI><a href="#[1e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskLock
<LI><a href="#[20c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciVsInit
<LI><a href="#[20b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvInit
</UL>
<BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[20d]"></a>DmAdvSetData</STRONG> (Thumb, 68 bytes, Stack size 32 bytes, dm_adv.o(i.DmAdvSetData))
<BR><BR>[Stack]<UL><LI>Max Depth = 184<LI>Call Chain = DmAdvSetData &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[32d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSetAdvScanDataFrag
</UL>

<P><STRONG><a name="[20e]"></a>DmAdvSetInterval</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, dm_adv.o(i.DmAdvSetInterval))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = DmAdvSetInterval &rArr; WsfTaskUnlock
</UL>
<BR>[Calls]<UL><LI><a href="#[1e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskUnlock
<LI><a href="#[1e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskLock
</UL>
<BR>[Called By]<UL><LI><a href="#[153]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appConnAccept
<LI><a href="#[32e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appAdvStart
</UL>

<P><STRONG><a name="[20f]"></a>DmAdvStart</STRONG> (Thumb, 78 bytes, Stack size 32 bytes, dm_adv.o(i.DmAdvStart))
<BR><BR>[Stack]<UL><LI>Max Depth = 184<LI>Call Chain = DmAdvStart &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
</UL>
<BR>[Called By]<UL><LI><a href="#[32e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appAdvStart
</UL>

<P><STRONG><a name="[210]"></a>DmAdvStop</STRONG> (Thumb, 56 bytes, Stack size 24 bytes, dm_adv.o(i.DmAdvStop))
<BR><BR>[Stack]<UL><LI>Max Depth = 176<LI>Call Chain = DmAdvStop &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
</UL>
<BR>[Called By]<UL><LI><a href="#[151]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appAdvStop
</UL>

<P><STRONG><a name="[211]"></a>DmConnAccept</STRONG> (Thumb, 48 bytes, Stack size 56 bytes, dm_conn_slave.o(i.DmConnAccept))
<BR><BR>[Stack]<UL><LI>Max Depth = 248<LI>Call Chain = DmConnAccept &rArr; dmConnOpenAccept &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[212]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnOpenAccept
</UL>
<BR>[Called By]<UL><LI><a href="#[153]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appConnAccept
</UL>

<P><STRONG><a name="[213]"></a>DmConnCheckIdle</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, dm_conn.o(i.DmConnCheckIdle))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = DmConnCheckIdle &rArr; WsfTaskUnlock
</UL>
<BR>[Calls]<UL><LI><a href="#[1e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskUnlock
<LI><a href="#[1e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskLock
</UL>
<BR>[Called By]<UL><LI><a href="#[b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsConnCback
<LI><a href="#[1b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveConnUpdateTimeout
</UL>

<P><STRONG><a name="[155]"></a>DmConnClose</STRONG> (Thumb, 46 bytes, Stack size 24 bytes, dm_conn.o(i.DmConnClose))
<BR><BR>[Stack]<UL><LI>Max Depth = 176<LI>Call Chain = DmConnClose &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
</UL>
<BR>[Called By]<UL><LI><a href="#[154]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppConnClose
</UL>

<P><STRONG><a name="[348]"></a>DmConnIdByHandle</STRONG> (Thumb, 36 bytes, Stack size 0 bytes, dm_conn.o(i.DmConnIdByHandle))
<BR><BR>[Called By]<UL><LI><a href="#[1db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcCcbByHandle
<LI><a href="#[347]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attCcbByHandle
<LI><a href="#[413]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCcbByHandle
<LI><a href="#[4e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;l2cHciFlowCback
<LI><a href="#[4b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;l2cRxSignalingPkt
</UL>

<P><STRONG><a name="[214]"></a>DmConnInUse</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, dm_conn.o(i.DmConnInUse))
<BR><BR>[Called By]<UL><LI><a href="#[34c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcCcbByConnId
<LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnSetIdle
<LI><a href="#[368]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsIndCcbByConnId
</UL>

<P><STRONG><a name="[3aa]"></a>DmConnInit</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, dm_conn.o(i.DmConnInit))
<BR><BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[410]"></a>DmConnLocalAddr</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, dm_conn.o(i.DmConnLocalAddr))
<BR><BR>[Called By]<UL><LI><a href="#[409]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCalcC1Part2
</UL>

<P><STRONG><a name="[40e]"></a>DmConnLocalAddrType</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, dm_conn.o(i.DmConnLocalAddrType))
<BR><BR>[Called By]<UL><LI><a href="#[408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCalcC1Part1
</UL>

<P><STRONG><a name="[40d]"></a>DmConnLocalRpa</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, dm_conn.o(i.DmConnLocalRpa))
<BR><BR>[Called By]<UL><LI><a href="#[408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCalcC1Part1
<LI><a href="#[409]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCalcC1Part2
</UL>

<P><STRONG><a name="[174]"></a>DmConnPeerAddr</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, dm_conn.o(i.DmConnPeerAddr))
<BR><BR>[Called By]<UL><LI><a href="#[2be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpDbGetRecord
<LI><a href="#[409]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCalcC1Part2
<LI><a href="#[171]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscProcAttMsg
<LI><a href="#[1b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveResolvedAddrInd
<LI><a href="#[1bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSecPairInd
<LI><a href="#[46]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerBtnCback
</UL>

<P><STRONG><a name="[175]"></a>DmConnPeerAddrType</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, dm_conn.o(i.DmConnPeerAddrType))
<BR><BR>[Called By]<UL><LI><a href="#[408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCalcC1Part1
<LI><a href="#[2be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpDbGetRecord
<LI><a href="#[171]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscProcAttMsg
<LI><a href="#[1bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSecPairInd
<LI><a href="#[46]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerBtnCback
</UL>

<P><STRONG><a name="[40f]"></a>DmConnPeerRpa</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, dm_conn.o(i.DmConnPeerRpa))
<BR><BR>[Called By]<UL><LI><a href="#[408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCalcC1Part1
<LI><a href="#[409]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCalcC1Part2
</UL>

<P><STRONG><a name="[1ca]"></a>DmConnRegister</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, dm_conn.o(i.DmConnRegister))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = DmConnRegister &rArr; WsfTaskUnlock
</UL>
<BR>[Calls]<UL><LI><a href="#[1e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskUnlock
<LI><a href="#[1e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskLock
</UL>
<BR>[Called By]<UL><LI><a href="#[1c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttHandlerInit
<LI><a href="#[2cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpHandlerInit
<LI><a href="#[1fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BeaconScannerStart
</UL>

<P><STRONG><a name="[173]"></a>DmConnRole</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, dm_conn.o(i.DmConnRole))
<BR><BR>[Called By]<UL><LI><a href="#[a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcConnCback
<LI><a href="#[215]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnUpdate
<LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
<LI><a href="#[426]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendKey
<LI><a href="#[415]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpResumeAttemptsState
<LI><a href="#[57]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpDmConnCback
<LI><a href="#[4b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;l2cRxSignalingPkt
<LI><a href="#[330]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appNumConns
<LI><a href="#[171]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscProcAttMsg
</UL>

<P><STRONG><a name="[17f]"></a>DmConnSecLevel</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, dm_conn.o(i.DmConnSecLevel))
<BR><BR>[Called By]<UL><LI><a href="#[1ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsCccEnabled
<LI><a href="#[36e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsPermissions
<LI><a href="#[171]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscProcAttMsg
<LI><a href="#[1c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppSlaveSecurityReq
<LI><a href="#[1bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSecPairInd
</UL>

<P><STRONG><a name="[167]"></a>DmConnSetIdle</STRONG> (Thumb, 90 bytes, Stack size 16 bytes, dm_conn.o(i.DmConnSetIdle))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = DmConnSetIdle &rArr; WsfTaskUnlock
</UL>
<BR>[Calls]<UL><LI><a href="#[1e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskUnlock
<LI><a href="#[1e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskLock
<LI><a href="#[214]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnInUse
</UL>
<BR>[Called By]<UL><LI><a href="#[16f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscFindService
<LI><a href="#[362]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsDiscBusy
<LI><a href="#[b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsMsgCback
<LI><a href="#[ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmSecMsgHandler
<LI><a href="#[ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmSecHciHandler
<LI><a href="#[103]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprActProcPairReq
<LI><a href="#[127]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActPairingFailed
<LI><a href="#[fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActPairingCmpl
<LI><a href="#[425]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendRand
<LI><a href="#[424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendPubKey
<LI><a href="#[423]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendPairCnf
<LI><a href="#[422]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendDHKeyCheck
<LI><a href="#[16c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscConfigure
<LI><a href="#[166]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscComplete
</UL>

<P><STRONG><a name="[3ab]"></a>DmConnSlaveInit</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, dm_conn_slave_leg.o(i.DmConnSlaveInit))
<BR><BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[215]"></a>DmConnUpdate</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, dm_conn.o(i.DmConnUpdate))
<BR><BR>[Stack]<UL><LI>Max Depth = 168<LI>Call Chain = DmConnUpdate &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
<LI><a href="#[173]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnRole
</UL>
<BR>[Called By]<UL><LI><a href="#[1b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveConnUpdateTimeout
</UL>

<P><STRONG><a name="[216]"></a>DmDevPrivStart</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, dm_dev_priv.o(i.DmDevPrivStart))
<BR><BR>[Stack]<UL><LI>Max Depth = 168<LI>Call Chain = DmDevPrivStart &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
</UL>
<BR>[Called By]<UL><LI><a href="#[46]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerBtnCback
</UL>

<P><STRONG><a name="[1b4]"></a>DmDevReset</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, dm_dev.o(i.DmDevReset))
<BR><BR>[Stack]<UL><LI>Max Depth = 160<LI>Call Chain = DmDevReset &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
</UL>
<BR>[Called By]<UL><LI><a href="#[253]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdTimeout
<LI><a href="#[69]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvHandler
<LI><a href="#[1ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppSlaveProcDmMsg
<LI><a href="#[1fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BeaconScannerStart
</UL>

<P><STRONG><a name="[217]"></a>DmDevSetFilterPolicy</STRONG> (Thumb, 18 bytes, Stack size 12 bytes, dm_dev.o(i.DmDevSetFilterPolicy))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = DmDevSetFilterPolicy &rArr; dmDevSetFilterPolicy
</UL>
<BR>[Calls]<UL><LI><a href="#[218]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmDevSetFilterPolicy
</UL>
<BR>[Called By]<UL><LI><a href="#[46]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerBtnCback
</UL>

<P><STRONG><a name="[219]"></a>DmDevVsInit</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, dm_dev.o(i.DmDevVsInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = DmDevVsInit
</UL>
<BR>[Calls]<UL><LI><a href="#[20c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciVsInit
</UL>
<BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[21a]"></a>DmDevWhiteListAdd</STRONG> (Thumb, 16 bytes, Stack size 16 bytes, dm_dev.o(i.DmDevWhiteListAdd))
<BR><BR>[Stack]<UL><LI>Max Depth = 232<LI>Call Chain = DmDevWhiteListAdd &rArr; HciLeAddDevWhiteListCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[21b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeAddDevWhiteListCmd
</UL>
<BR>[Called By]<UL><LI><a href="#[46]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerBtnCback
</UL>

<P><STRONG><a name="[21c]"></a>DmDevWhiteListClear</STRONG> (Thumb, 8 bytes, Stack size 8 bytes, dm_dev.o(i.DmDevWhiteListClear))
<BR><BR>[Stack]<UL><LI>Max Depth = 208<LI>Call Chain = DmDevWhiteListClear &rArr; HciLeClearWhiteListCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[21d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeClearWhiteListCmd
</UL>
<BR>[Called By]<UL><LI><a href="#[46]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerBtnCback
</UL>

<P><STRONG><a name="[37f]"></a>DmFindAdType</STRONG> (Thumb, 44 bytes, Stack size 0 bytes, dm_main.o(i.DmFindAdType))
<BR><BR>[Called By]<UL><LI><a href="#[3a3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmScanActHciReport
<LI><a href="#[1f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerProcMsg
</UL>

<P><STRONG><a name="[62]"></a>DmHandler</STRONG> (Thumb, 36 bytes, Stack size 16 bytes, dm_main.o(i.DmHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = DmHandler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio_task.o(i.exactle_stack_init)
</UL>
<P><STRONG><a name="[21e]"></a>DmHandlerInit</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, dm_main.o(i.DmHandlerInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = DmHandlerInit
</UL>
<BR>[Calls]<UL><LI><a href="#[21f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciEvtRegister
</UL>
<BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[159]"></a>DmHostAddrType</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, dm_main.o(i.DmHostAddrType))
<BR><BR>[Called By]<UL><LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActConnOpened
<LI><a href="#[2be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpDbGetRecord
<LI><a href="#[158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbFindByAddr
</UL>

<P><STRONG><a name="[3d1]"></a>DmL2cCmdRejInd</STRONG> (Thumb, 38 bytes, Stack size 24 bytes, dm_conn_slave.o(i.DmL2cCmdRejInd))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = DmL2cCmdRejInd
</UL>
<BR>[Called By]<UL><LI><a href="#[50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;l2cSlaveRxSignalingPkt
</UL>

<P><STRONG><a name="[220]"></a>DmL2cConnUpdateCnf</STRONG> (Thumb, 36 bytes, Stack size 24 bytes, dm_conn_slave.o(i.DmL2cConnUpdateCnf))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = DmL2cConnUpdateCnf &rArr; dmConnSmExecute
</UL>
<BR>[Calls]<UL><LI><a href="#[222]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmExecute
<LI><a href="#[221]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnCcbByHandle
</UL>
<BR>[Called By]<UL><LI><a href="#[50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;l2cSlaveRxSignalingPkt
<LI><a href="#[2a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;l2cSlaveReqTimeout
</UL>

<P><STRONG><a name="[385]"></a>DmLlAddrType</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, dm_main.o(i.DmLlAddrType))
<BR><BR>[Called By]<UL><LI><a href="#[384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvConfig
<LI><a href="#[e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmScanActStart
</UL>

<P><STRONG><a name="[333]"></a>DmLlPrivEnabled</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, dm_main.o(i.DmLlPrivEnabled))
<BR><BR>[Called By]<UL><LI><a href="#[153]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appConnAccept
<LI><a href="#[1be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appPrivSetAddrResEnableInd
<LI><a href="#[380]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerSecPairCmpl
<LI><a href="#[46]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerBtnCback
</UL>

<P><STRONG><a name="[14a]"></a>DmPrivAddDevToResList</STRONG> (Thumb, 82 bytes, Stack size 32 bytes, dm_priv.o(i.DmPrivAddDevToResList))
<BR><BR>[Stack]<UL><LI>Max Depth = 184<LI>Call Chain = DmPrivAddDevToResList &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCpy
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
<LI><a href="#[206]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Calc128Cpy
</UL>
<BR>[Called By]<UL><LI><a href="#[146]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppAddDevToResList
</UL>

<P><STRONG><a name="[223]"></a>DmPrivClearResList</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, dm_priv.o(i.DmPrivClearResList))
<BR><BR>[Stack]<UL><LI>Max Depth = 160<LI>Call Chain = DmPrivClearResList &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
</UL>
<BR>[Called By]<UL><LI><a href="#[46]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerBtnCback
</UL>

<P><STRONG><a name="[3ae]"></a>DmPrivInit</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, dm_priv.o(i.DmPrivInit))
<BR><BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[224]"></a>DmPrivResolveAddr</STRONG> (Thumb, 58 bytes, Stack size 24 bytes, dm_priv.o(i.DmPrivResolveAddr))
<BR><BR>[Stack]<UL><LI>Max Depth = 176<LI>Call Chain = DmPrivResolveAddr &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCpy
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
<LI><a href="#[206]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Calc128Cpy
</UL>
<BR>[Called By]<UL><LI><a href="#[1b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveResolvedAddrInd
<LI><a href="#[346]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveResolveAddr
</UL>

<P><STRONG><a name="[225]"></a>DmPrivSetAddrResEnable</STRONG> (Thumb, 36 bytes, Stack size 16 bytes, dm_priv.o(i.DmPrivSetAddrResEnable))
<BR><BR>[Stack]<UL><LI>Max Depth = 168<LI>Call Chain = DmPrivSetAddrResEnable &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
</UL>
<BR>[Called By]<UL><LI><a href="#[46]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerBtnCback
</UL>

<P><STRONG><a name="[1c6]"></a>DmPrivSetPrivacyMode</STRONG> (Thumb, 50 bytes, Stack size 24 bytes, dm_priv.o(i.DmPrivSetPrivacyMode))
<BR><BR>[Stack]<UL><LI>Max Depth = 176<LI>Call Chain = DmPrivSetPrivacyMode &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCpy
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
</UL>
<BR>[Called By]<UL><LI><a href="#[1c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppUpdatePrivacyMode
</UL>

<P><STRONG><a name="[226]"></a>DmReadRemoteFeatures</STRONG> (Thumb, 102 bytes, Stack size 32 bytes, dm_conn.o(i.DmReadRemoteFeatures))
<BR><BR>[Stack]<UL><LI>Max Depth = 240<LI>Call Chain = DmReadRemoteFeatures &rArr; HciLeReadRemoteFeatCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[228]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeReadRemoteFeatCmd
<LI><a href="#[227]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnCcbById
</UL>
<BR>[Called By]<UL><LI><a href="#[1ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveConnOpen
</UL>

<P><STRONG><a name="[1fe]"></a>DmRegister</STRONG> (Thumb, 62 bytes, Stack size 112 bytes, dm_main.o(i.DmRegister))
<BR><BR>[Stack]<UL><LI>Max Depth = 112<LI>Call Chain = DmRegister
</UL>
<BR>[Calls]<UL><LI><a href="#[1ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciGetMaxRxAclLen
</UL>
<BR>[Called By]<UL><LI><a href="#[1fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BeaconScannerStart
</UL>

<P><STRONG><a name="[229]"></a>DmRemoteConnParamReqNegReply</STRONG> (Thumb, 36 bytes, Stack size 16 bytes, dm_conn.o(i.DmRemoteConnParamReqNegReply))
<BR><BR>[Stack]<UL><LI>Max Depth = 168<LI>Call Chain = DmRemoteConnParamReqNegReply &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
</UL>
<BR>[Called By]<UL><LI><a href="#[1b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveRemoteConnParamReq
</UL>

<P><STRONG><a name="[22a]"></a>DmRemoteConnParamReqReply</STRONG> (Thumb, 46 bytes, Stack size 16 bytes, dm_conn.o(i.DmRemoteConnParamReqReply))
<BR><BR>[Stack]<UL><LI>Max Depth = 168<LI>Call Chain = DmRemoteConnParamReqReply &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
</UL>
<BR>[Called By]<UL><LI><a href="#[1b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveRemoteConnParamReq
</UL>

<P><STRONG><a name="[22b]"></a>DmScanInit</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, dm_scan_leg.o(i.DmScanInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = DmScanInit &rArr; WsfTaskUnlock
</UL>
<BR>[Calls]<UL><LI><a href="#[1e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskUnlock
<LI><a href="#[1e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskLock
<LI><a href="#[22c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmScanInit
</UL>
<BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[22d]"></a>DmScanPhyToIdx</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, dm_main.o(i.DmScanPhyToIdx))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = DmScanPhyToIdx
</UL>
<BR>[Calls]<UL><LI><a href="#[22e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmScanPhyToIdx
</UL>
<BR>[Called By]<UL><LI><a href="#[e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmScanActStart
<LI><a href="#[22f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmScanSetInterval
</UL>

<P><STRONG><a name="[197]"></a>DmScanSetInterval</STRONG> (Thumb, 62 bytes, Stack size 24 bytes, dm_scan.o(i.DmScanSetInterval))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = DmScanSetInterval &rArr; dmScanSetInterval &rArr; DmScanPhyToIdx
</UL>
<BR>[Calls]<UL><LI><a href="#[22f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmScanSetInterval
</UL>
<BR>[Called By]<UL><LI><a href="#[195]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppScanStart
</UL>

<P><STRONG><a name="[198]"></a>DmScanStart</STRONG> (Thumb, 100 bytes, Stack size 40 bytes, dm_scan.o(i.DmScanStart))
<BR><BR>[Stack]<UL><LI>Max Depth = 192<LI>Call Chain = DmScanStart &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
</UL>
<BR>[Called By]<UL><LI><a href="#[195]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppScanStart
</UL>

<P><STRONG><a name="[19a]"></a>DmScanStop</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, dm_scan.o(i.DmScanStop))
<BR><BR>[Stack]<UL><LI>Max Depth = 160<LI>Call Chain = DmScanStop &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
</UL>
<BR>[Called By]<UL><LI><a href="#[199]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppScanStop
</UL>

<P><STRONG><a name="[18e]"></a>DmSecAuthRsp</STRONG> (Thumb, 50 bytes, Stack size 24 bytes, dm_sec.o(i.DmSecAuthRsp))
<BR><BR>[Stack]<UL><LI>Max Depth = 184<LI>Call Chain = DmSecAuthRsp &rArr; SmpDmMsgSend &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpDmMsgSend
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[18c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppHandlePasskey
</UL>

<P><STRONG><a name="[231]"></a>DmSecCancelReq</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, dm_sec.o(i.DmSecCancelReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 176<LI>Call Chain = DmSecCancelReq &rArr; SmpDmMsgSend &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpDmMsgSend
</UL>
<BR>[Called By]<UL><LI><a href="#[1bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSecPairInd
</UL>

<P><STRONG><a name="[18b]"></a>DmSecCompareRsp</STRONG> (Thumb, 44 bytes, Stack size 16 bytes, dm_sec_lesc.o(i.DmSecCompareRsp))
<BR><BR>[Stack]<UL><LI>Max Depth = 176<LI>Call Chain = DmSecCompareRsp &rArr; SmpDmMsgSend &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[232]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScGetCancelMsgWithReattempt
<LI><a href="#[230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpDmMsgSend
</UL>
<BR>[Called By]<UL><LI><a href="#[188]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppHandleNumericComparison
</UL>

<P><STRONG><a name="[233]"></a>DmSecGenerateEccKeyReq</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, dm_sec_lesc.o(i.DmSecGenerateEccKeyReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 756<LI>Call Chain = DmSecGenerateEccKeyReq &rArr; SecEccGenKey &rArr; uECC_make_key &rArr; EccPoint_compute_public_key &rArr; EccPoint_mult &rArr; XYcZ_initial_double &rArr; EccPoint_double_jacobian &rArr; vli_modSquare_fast &rArr; vli_square &rArr; mul2add
</UL>
<BR>[Calls]<UL><LI><a href="#[234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecEccGenKey
</UL>
<BR>[Called By]<UL><LI><a href="#[1f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerProcMsg
</UL>

<P><STRONG><a name="[189]"></a>DmSecGetCompareValue</STRONG> (Thumb, 34 bytes, Stack size 0 bytes, dm_sec_lesc.o(i.DmSecGetCompareValue))
<BR><BR>[Called By]<UL><LI><a href="#[188]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppHandleNumericComparison
</UL>

<P><STRONG><a name="[421]"></a>DmSecGetEccKey</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, dm_sec_lesc.o(i.DmSecGetEccKey))
<BR><BR>[Called By]<UL><LI><a href="#[58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScProcPairing
</UL>

<P><STRONG><a name="[427]"></a>DmSecGetLocalCsrk</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, dm_sec.o(i.DmSecGetLocalCsrk))
<BR><BR>[Called By]<UL><LI><a href="#[426]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendKey
</UL>

<P><STRONG><a name="[149]"></a>DmSecGetLocalIrk</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, dm_sec.o(i.DmSecGetLocalIrk))
<BR><BR>[Called By]<UL><LI><a href="#[426]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendKey
<LI><a href="#[146]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppAddDevToResList
</UL>

<P><STRONG><a name="[3ac]"></a>DmSecInit</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, dm_sec.o(i.DmSecInit))
<BR><BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[3ad]"></a>DmSecLescInit</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, dm_sec_lesc.o(i.DmSecLescInit))
<BR><BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[235]"></a>DmSecLtkRsp</STRONG> (Thumb, 56 bytes, Stack size 24 bytes, dm_sec_slave.o(i.DmSecLtkRsp))
<BR><BR>[Stack]<UL><LI>Max Depth = 176<LI>Call Chain = DmSecLtkRsp &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
<LI><a href="#[206]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Calc128Cpy
</UL>
<BR>[Called By]<UL><LI><a href="#[33b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSecRspLtk
</UL>

<P><STRONG><a name="[236]"></a>DmSecPairRsp</STRONG> (Thumb, 58 bytes, Stack size 32 bytes, dm_sec_slave.o(i.DmSecPairRsp))
<BR><BR>[Stack]<UL><LI>Max Depth = 192<LI>Call Chain = DmSecPairRsp &rArr; SmpDmMsgSend &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpDmMsgSend
</UL>
<BR>[Called By]<UL><LI><a href="#[1bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSecPairInd
</UL>

<P><STRONG><a name="[237]"></a>DmSecSetEccKey</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, dm_sec_lesc.o(i.DmSecSetEccKey))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = DmSecSetEccKey
</UL>
<BR>[Calls]<UL><LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[42]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerDmCback
</UL>

<P><STRONG><a name="[1fc]"></a>DmSecSetLocalIrk</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, dm_sec.o(i.DmSecSetLocalIrk))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = DmSecSetLocalIrk &rArr; WsfTaskUnlock
</UL>
<BR>[Calls]<UL><LI><a href="#[1e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskUnlock
<LI><a href="#[1e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskLock
</UL>
<BR>[Called By]<UL><LI><a href="#[1f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BeaconScannerHandlerInit
</UL>

<P><STRONG><a name="[1c2]"></a>DmSecSlaveReq</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, dm_sec_slave.o(i.DmSecSlaveReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 176<LI>Call Chain = DmSecSlaveReq &rArr; SmpDmMsgSend &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpDmMsgSend
</UL>
<BR>[Called By]<UL><LI><a href="#[1b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveSecConnOpen
<LI><a href="#[1c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppSlaveSecurityReq
</UL>

<P><STRONG><a name="[37b]"></a>DmSizeOfEvt</STRONG> (Thumb, 30 bytes, Stack size 0 bytes, dm_main.o(i.DmSizeOfEvt))
<BR><BR>[Called By]<UL><LI><a href="#[42]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerDmCback
</UL>

<P><STRONG><a name="[3a4]"></a>DmSmpCbackExec</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, dm_sec.o(i.DmSmpCbackExec))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = DmSmpCbackExec
</UL>
<BR>[Called By]<UL><LI><a href="#[ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmSecHciHandler
<LI><a href="#[103]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprActProcPairReq
<LI><a href="#[5b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpAuthReq
<LI><a href="#[127]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActPairingFailed
<LI><a href="#[10a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActPkSetup
<LI><a href="#[10b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActPkKeypress
<LI><a href="#[41f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActJwncDisplay
<LI><a href="#[fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActPairingCmpl
<LI><a href="#[100]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActNotifyDmRspToFailure
<LI><a href="#[ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActNotifyDmAttemptsFailure
<LI><a href="#[426]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendKey
<LI><a href="#[418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpProcRcvKey
<LI><a href="#[59]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScAuthReq
<LI><a href="#[416]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpGenerateLtk
</UL>

<P><STRONG><a name="[24b]"></a>FmplIasDiscover</STRONG> (Thumb, 26 bytes, Stack size 24 bytes, fmpl_main.o(i.FmplIasDiscover))
<BR><BR>[Stack]<UL><LI>Max Depth = 328<LI>Call Chain = FmplIasDiscover &rArr; AppDiscFindService &rArr; AttcDiscService &rArr; AttcFindByTypeValueReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[16f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscFindService
</UL>
<BR>[Called By]<UL><LI><a href="#[47]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerDiscCback
</UL>

<P><STRONG><a name="[24c]"></a>FmplSendAlert</STRONG> (Thumb, 26 bytes, Stack size 24 bytes, fmpl_main.o(i.FmplSendAlert))
<BR><BR>[Stack]<UL><LI>Max Depth = 256<LI>Call Chain = FmplSendAlert &rArr; AttcWriteCmd &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcWriteCmd
</UL>
<BR>[Called By]<UL><LI><a href="#[46]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerBtnCback
</UL>

<P><STRONG><a name="[24d]"></a>GapDiscover</STRONG> (Thumb, 26 bytes, Stack size 24 bytes, gap_main.o(i.GapDiscover))
<BR><BR>[Stack]<UL><LI>Max Depth = 328<LI>Call Chain = GapDiscover &rArr; AppDiscFindService &rArr; AttcDiscService &rArr; AttcFindByTypeValueReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[16f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscFindService
</UL>
<BR>[Called By]<UL><LI><a href="#[47]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerDiscCback
</UL>

<P><STRONG><a name="[24e]"></a>GapValueUpdate</STRONG> (Thumb, 66 bytes, Stack size 24 bytes, gap_main.o(i.GapValueUpdate))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = GapValueUpdate
</UL>
<BR>[Calls]<UL><LI><a href="#[24f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbSetPeerAddrRes
<LI><a href="#[169]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetHdl
</UL>
<BR>[Called By]<UL><LI><a href="#[37d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerValueUpdate
</UL>

<P><STRONG><a name="[250]"></a>GattDiscover</STRONG> (Thumb, 26 bytes, Stack size 24 bytes, gatt_main.o(i.GattDiscover))
<BR><BR>[Stack]<UL><LI>Max Depth = 328<LI>Call Chain = GattDiscover &rArr; AppDiscFindService &rArr; AttcDiscService &rArr; AttcFindByTypeValueReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[16f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscFindService
</UL>
<BR>[Called By]<UL><LI><a href="#[47]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerDiscCback
</UL>

<P><STRONG><a name="[19f]"></a>GattSendServiceChangedInd</STRONG> (Thumb, 106 bytes, Stack size 24 bytes, gatt_main.o(i.GattSendServiceChangedInd))
<BR><BR>[Stack]<UL><LI>Max Depth = 272<LI>Call Chain = GattSendServiceChangedInd &rArr; AttsHandleValueInd &rArr; attsHandleValueIndNtf &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsHandleValueInd
<LI><a href="#[1ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsCccEnabled
</UL>
<BR>[Called By]<UL><LI><a href="#[44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppServerConnCback
</UL>

<P><STRONG><a name="[251]"></a>GattValueUpdate</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, gatt_main.o(i.GattValueUpdate))
<BR><BR>[Stack]<UL><LI>Max Depth = 344<LI>Call Chain = GattValueUpdate &rArr; AppDiscServiceChanged &rArr; appDiscRestartDiscovery &rArr; appDiscStart &rArr; AttcReadByTypeReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[187]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscServiceChanged
</UL>
<BR>[Called By]<UL><LI><a href="#[37d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerValueUpdate
</UL>

<P><STRONG><a name="[2a7]"></a>HciAclRegister</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, hci_main.o(i.HciAclRegister))
<BR><BR>[Called By]<UL><LI><a href="#[2a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cInit
</UL>

<P><STRONG><a name="[252]"></a>HciCoreHandler</STRONG> (Thumb, 96 bytes, Stack size 24 bytes, hci_core_ps.o(i.HciCoreHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 396<LI>Call Chain = HciCoreHandler &rArr; hciCmdTimeout &rArr; HciDrvRadioBoot &rArr; am_hal_ble_boot &rArr; am_hal_ble_patch_complete &rArr; am_hal_ble_plf_reg_read &rArr; am_hal_ble_blocking_hci_write &rArr; am_hal_ble_blocking_transfer &rArr; am_hal_ble_cmd_write
</UL>
<BR>[Calls]<UL><LI><a href="#[254]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessMsg
<LI><a href="#[255]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreResetSequence
<LI><a href="#[256]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreAclReassembly
<LI><a href="#[1cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgFree
<LI><a href="#[257]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgDeq
<LI><a href="#[253]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdTimeout
</UL>
<BR>[Called By]<UL><LI><a href="#[61]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciHandler
</UL>

<P><STRONG><a name="[258]"></a>HciCoreInit</STRONG> (Thumb, 110 bytes, Stack size 8 bytes, hci_core.o(i.HciCoreInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = HciCoreInit &rArr; hciCoreInit
</UL>
<BR>[Calls]<UL><LI><a href="#[259]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreInit
</UL>
<BR>[Called By]<UL><LI><a href="#[276]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciHandlerInit
</UL>

<P><STRONG><a name="[25a]"></a>HciDisconnectCmd</STRONG> (Thumb, 48 bytes, Stack size 24 bytes, hci_cmd.o(i.HciDisconnectCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = HciDisconnectCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActClose
</UL>

<P><STRONG><a name="[25d]"></a>HciDrvEmptyWriteQueue</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, hci_drv_apollo3.o(i.HciDrvEmptyWriteQueue))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = HciDrvEmptyWriteQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_queue_init
</UL>
<BR>[Called By]<UL><LI><a href="#[69]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvHandler
</UL>

<P><STRONG><a name="[69]"></a>HciDrvHandler</STRONG> (Thumb, 532 bytes, Stack size 40 bytes, hci_drv_apollo3.o(i.HciDrvHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 404<LI>Call Chain = HciDrvHandler &rArr; HciDrvRadioBoot &rArr; am_hal_ble_boot &rArr; am_hal_ble_patch_complete &rArr; am_hal_ble_plf_reg_read &rArr; am_hal_ble_blocking_hci_write &rArr; am_hal_ble_blocking_transfer &rArr; am_hal_ble_cmd_write
</UL>
<BR>[Calls]<UL><LI><a href="#[25f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciReadLocalVerInfoCmd
<LI><a href="#[262]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfSetEvent
<LI><a href="#[263]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStop
<LI><a href="#[268]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvRadioShutdown
<LI><a href="#[1b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvRadioBoot
<LI><a href="#[1b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmDevReset
<LI><a href="#[260]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStartMs
<LI><a href="#[261]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciTrSerialRxIncoming
<LI><a href="#[265]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_printf
<LI><a href="#[267]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_delay_us
<LI><a href="#[26a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_queue_item_get
<LI><a href="#[269]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_blocking_hci_write
<LI><a href="#[264]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_blocking_hci_read
<LI><a href="#[25d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvEmptyWriteQueue
<LI><a href="#[266]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;error_check
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio_task.o(i.exactle_stack_init)
</UL>
<P><STRONG><a name="[3b6]"></a>HciDrvHandlerInit</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, hci_drv_apollo3.o(i.HciDrvHandlerInit))
<BR><BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[26b]"></a>HciDrvIntService</STRONG> (Thumb, 46 bytes, Stack size 8 bytes, hci_drv_apollo3.o(i.HciDrvIntService))
<BR><BR>[Stack]<UL><LI>Max Depth = 144<LI>Call Chain = HciDrvIntService &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[262]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfSetEvent
<LI><a href="#[26c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_int_status
<LI><a href="#[26d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_int_clear
</UL>
<BR>[Called By]<UL><LI><a href="#[26]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_ble_isr
</UL>

<P><STRONG><a name="[1b3]"></a>HciDrvRadioBoot</STRONG> (Thumb, 386 bytes, Stack size 48 bytes, hci_drv_apollo3.o(i.HciDrvRadioBoot))
<BR><BR>[Stack]<UL><LI>Max Depth = 364<LI>Call Chain = HciDrvRadioBoot &rArr; am_hal_ble_boot &rArr; am_hal_ble_patch_complete &rArr; am_hal_ble_plf_reg_read &rArr; am_hal_ble_blocking_hci_write &rArr; am_hal_ble_blocking_transfer &rArr; am_hal_ble_cmd_write
</UL>
<BR>[Calls]<UL><LI><a href="#[265]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_printf
<LI><a href="#[271]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_delay_ms
<LI><a href="#[25e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_queue_init
<LI><a href="#[274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_tx_power_set
<LI><a href="#[26f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_power_control
<LI><a href="#[275]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_int_enable
<LI><a href="#[26d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_int_clear
<LI><a href="#[26e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_initialize
<LI><a href="#[273]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_deinitialize
<LI><a href="#[270]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_config
<LI><a href="#[272]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_boot
<LI><a href="#[266]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;error_check
<LI><a href="#[13e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4
</UL>
<BR>[Called By]<UL><LI><a href="#[253]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdTimeout
<LI><a href="#[69]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvHandler
<LI><a href="#[1ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppSlaveProcDmMsg
<LI><a href="#[2ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioTaskSetup
</UL>

<P><STRONG><a name="[268]"></a>HciDrvRadioShutdown</STRONG> (Thumb, 150 bytes, Stack size 8 bytes, hci_drv_apollo3.o(i.HciDrvRadioShutdown))
<BR><BR>[Stack]<UL><LI>Max Depth = 300<LI>Call Chain = HciDrvRadioShutdown &rArr; am_util_stdio_printf &rArr; am_util_stdio_vsprintf &rArr; ftoa &rArr; uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[263]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStop
<LI><a href="#[265]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_printf
<LI><a href="#[26f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_power_control
<LI><a href="#[273]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_deinitialize
<LI><a href="#[266]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;error_check
</UL>
<BR>[Called By]<UL><LI><a href="#[253]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdTimeout
<LI><a href="#[69]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvHandler
</UL>

<P><STRONG><a name="[21f]"></a>HciEvtRegister</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, hci_main.o(i.HciEvtRegister))
<BR><BR>[Called By]<UL><LI><a href="#[21e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmHandlerInit
</UL>

<P><STRONG><a name="[39c]"></a>HciGetBdAddr</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, hci_core_ps.o(i.HciGetBdAddr))
<BR><BR>[Called By]<UL><LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActConnOpened
<LI><a href="#[426]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendKey
</UL>

<P><STRONG><a name="[29f]"></a>HciGetBufSize</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, hci_core_ps.o(i.HciGetBufSize))
<BR><BR>[Called By]<UL><LI><a href="#[29d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreTxAclStart
<LI><a href="#[3c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreTxAclContinue
<LI><a href="#[29a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciSendAclData
</UL>

<P><STRONG><a name="[39e]"></a>HciGetLeSupFeat</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, hci_core_ps.o(i.HciGetLeSupFeat))
<BR><BR>[Called By]<UL><LI><a href="#[d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActUpdateSlave
</UL>

<P><STRONG><a name="[1ce]"></a>HciGetMaxRxAclLen</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, hci_core_ps.o(i.HciGetMaxRxAclLen))
<BR><BR>[Called By]<UL><LI><a href="#[a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcProcMtuRsp
<LI><a href="#[a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcConnCback
<LI><a href="#[1cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttRegister
<LI><a href="#[3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcMtuReq
<LI><a href="#[1fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmRegister
</UL>

<P><STRONG><a name="[61]"></a>HciHandler</STRONG> (Thumb, 16 bytes, Stack size 16 bytes, hci_main.o(i.HciHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 412<LI>Call Chain = HciHandler &rArr; HciCoreHandler &rArr; hciCmdTimeout &rArr; HciDrvRadioBoot &rArr; am_hal_ble_boot &rArr; am_hal_ble_patch_complete &rArr; am_hal_ble_plf_reg_read &rArr; am_hal_ble_blocking_hci_write &rArr; am_hal_ble_blocking_transfer &rArr; am_hal_ble_cmd_write
</UL>
<BR>[Calls]<UL><LI><a href="#[252]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciCoreHandler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio_task.o(i.exactle_stack_init)
</UL>
<P><STRONG><a name="[276]"></a>HciHandlerInit</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, hci_main.o(i.HciHandlerInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = HciHandlerInit &rArr; HciCoreInit &rArr; hciCoreInit
</UL>
<BR>[Calls]<UL><LI><a href="#[258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciCoreInit
</UL>
<BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[21b]"></a>HciLeAddDevWhiteListCmd</STRONG> (Thumb, 48 bytes, Stack size 24 bytes, hci_cmd.o(i.HciLeAddDevWhiteListCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = HciLeAddDevWhiteListCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCpy
<LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[21a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmDevWhiteListAdd
</UL>

<P><STRONG><a name="[277]"></a>HciLeAddDeviceToResolvingListCmd</STRONG> (Thumb, 78 bytes, Stack size 32 bytes, hci_cmd.o(i.HciLeAddDeviceToResolvingListCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 224<LI>Call Chain = HciLeAddDeviceToResolvingListCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCpy
<LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmPrivActAddDevToResList
</UL>

<P><STRONG><a name="[278]"></a>HciLeClearResolvingList</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, hci_cmd.o(i.HciLeClearResolvingList))
<BR><BR>[Stack]<UL><LI>Max Depth = 200<LI>Call Chain = HciLeClearResolvingList &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmPrivActClearResList
</UL>

<P><STRONG><a name="[21d]"></a>HciLeClearWhiteListCmd</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, hci_cmd.o(i.HciLeClearWhiteListCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 200<LI>Call Chain = HciLeClearWhiteListCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[21c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmDevWhiteListClear
</UL>

<P><STRONG><a name="[279]"></a>HciLeConnUpdateCmd</STRONG> (Thumb, 128 bytes, Stack size 24 bytes, hci_cmd.o(i.HciLeConnUpdateCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = HciLeConnUpdateCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActUpdateSlave
</UL>

<P><STRONG><a name="[27a]"></a>HciLeEncryptCmd</STRONG> (Thumb, 56 bytes, Stack size 24 bytes, hci_cmd.o(i.HciLeEncryptCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[2ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecAes
<LI><a href="#[2bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecLeEncryptCmd
</UL>

<P><STRONG><a name="[27b]"></a>HciLeLtkReqNegReplCmd</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, hci_cmd.o(i.HciLeLtkReqNegReplCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 208<LI>Call Chain = HciLeLtkReqNegReplCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmSecMsgHandler
</UL>

<P><STRONG><a name="[27c]"></a>HciLeLtkReqReplCmd</STRONG> (Thumb, 54 bytes, Stack size 24 bytes, hci_cmd.o(i.HciLeLtkReqReplCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = HciLeLtkReqReplCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmSecMsgHandler
<LI><a href="#[ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmSecHciHandler
</UL>

<P><STRONG><a name="[27d]"></a>HciLeRandCmd</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, hci_cmd.o(i.HciLeRandCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 200<LI>Call Chain = HciLeRandCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[255]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreResetSequence
<LI><a href="#[3bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreReadMaxDataLen
<LI><a href="#[18d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecRand
</UL>

<P><STRONG><a name="[27e]"></a>HciLeReadBufSizeCmd</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, hci_cmd.o(i.HciLeReadBufSizeCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 200<LI>Call Chain = HciLeReadBufSizeCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[255]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreResetSequence
</UL>

<P><STRONG><a name="[27f]"></a>HciLeReadLocalSupFeatCmd</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, hci_cmd.o(i.HciLeReadLocalSupFeatCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 200<LI>Call Chain = HciLeReadLocalSupFeatCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[255]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreResetSequence
</UL>

<P><STRONG><a name="[280]"></a>HciLeReadMaxDataLen</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, hci_cmd.o(i.HciLeReadMaxDataLen))
<BR><BR>[Stack]<UL><LI>Max Depth = 200<LI>Call Chain = HciLeReadMaxDataLen &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[3bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreReadMaxDataLen
</UL>

<P><STRONG><a name="[228]"></a>HciLeReadRemoteFeatCmd</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, hci_cmd.o(i.HciLeReadRemoteFeatCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 208<LI>Call Chain = HciLeReadRemoteFeatCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[226]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmReadRemoteFeatures
</UL>

<P><STRONG><a name="[281]"></a>HciLeReadResolvingListSize</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, hci_cmd.o(i.HciLeReadResolvingListSize))
<BR><BR>[Stack]<UL><LI>Max Depth = 200<LI>Call Chain = HciLeReadResolvingListSize &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[3c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreReadResolvingListSize
</UL>

<P><STRONG><a name="[282]"></a>HciLeReadSupStatesCmd</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, hci_cmd.o(i.HciLeReadSupStatesCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 200<LI>Call Chain = HciLeReadSupStatesCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[255]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreResetSequence
</UL>

<P><STRONG><a name="[283]"></a>HciLeReadWhiteListSizeCmd</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, hci_cmd.o(i.HciLeReadWhiteListSizeCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 200<LI>Call Chain = HciLeReadWhiteListSizeCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[255]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreResetSequence
</UL>

<P><STRONG><a name="[284]"></a>HciLeRemoteConnParamReqNegReply</STRONG> (Thumb, 48 bytes, Stack size 24 bytes, hci_cmd.o(i.HciLeRemoteConnParamReqNegReply))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = HciLeRemoteConnParamReqNegReply &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConn2MsgHandler
</UL>

<P><STRONG><a name="[285]"></a>HciLeRemoteConnParamReqReply</STRONG> (Thumb, 128 bytes, Stack size 40 bytes, hci_cmd.o(i.HciLeRemoteConnParamReqReply))
<BR><BR>[Stack]<UL><LI>Max Depth = 232<LI>Call Chain = HciLeRemoteConnParamReqReply &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConn2MsgHandler
</UL>

<P><STRONG><a name="[286]"></a>HciLeRemoveDeviceFromResolvingList</STRONG> (Thumb, 48 bytes, Stack size 24 bytes, hci_cmd.o(i.HciLeRemoveDeviceFromResolvingList))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = HciLeRemoveDeviceFromResolvingList &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCpy
<LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmPrivActRemDevFromResList
</UL>

<P><STRONG><a name="[287]"></a>HciLeSetAddrResolutionEnable</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, hci_cmd.o(i.HciLeSetAddrResolutionEnable))
<BR><BR>[Stack]<UL><LI>Max Depth = 208<LI>Call Chain = HciLeSetAddrResolutionEnable &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[3a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmPrivSetAddrResEnable
</UL>

<P><STRONG><a name="[288]"></a>HciLeSetAdvDataCmd</STRONG> (Thumb, 60 bytes, Stack size 24 bytes, hci_cmd.o(i.HciLeSetAdvDataCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = HciLeSetAdvDataCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
<LI><a href="#[1d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvActSetData
</UL>

<P><STRONG><a name="[289]"></a>HciLeSetAdvEnableCmd</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, hci_cmd.o(i.HciLeSetAdvEnableCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 208<LI>Call Chain = HciLeSetAdvEnableCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[38d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvStopDirected
<LI><a href="#[38c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvStartDirected
<LI><a href="#[c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvActTimeout
<LI><a href="#[bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvActStop
<LI><a href="#[bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvActStart
</UL>

<P><STRONG><a name="[28a]"></a>HciLeSetAdvParamCmd</STRONG> (Thumb, 116 bytes, Stack size 40 bytes, hci_cmd.o(i.HciLeSetAdvParamCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 232<LI>Call Chain = HciLeSetAdvParamCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCpy
<LI><a href="#[28b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaClr
<LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvConfig
</UL>

<P><STRONG><a name="[28c]"></a>HciLeSetDataLen</STRONG> (Thumb, 70 bytes, Stack size 24 bytes, hci_cmd.o(i.HciLeSetDataLen))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = HciLeSetDataLen &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConn2MsgHandler
</UL>

<P><STRONG><a name="[28d]"></a>HciLeSetEventMaskCmd</STRONG> (Thumb, 36 bytes, Stack size 16 bytes, hci_cmd.o(i.HciLeSetEventMaskCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 208<LI>Call Chain = HciLeSetEventMaskCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[255]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreResetSequence
</UL>

<P><STRONG><a name="[28e]"></a>HciLeSetPrivacyModeCmd</STRONG> (Thumb, 54 bytes, Stack size 24 bytes, hci_cmd.o(i.HciLeSetPrivacyModeCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = HciLeSetPrivacyModeCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCpy
<LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmPrivActSetPrivacyMode
</UL>

<P><STRONG><a name="[28f]"></a>HciLeSetScanEnableCmd</STRONG> (Thumb, 42 bytes, Stack size 24 bytes, hci_cmd.o(i.HciLeSetScanEnableCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = HciLeSetScanEnableCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmScanActStop
<LI><a href="#[e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmScanActStart
</UL>

<P><STRONG><a name="[290]"></a>HciLeSetScanParamCmd</STRONG> (Thumb, 78 bytes, Stack size 32 bytes, hci_cmd.o(i.HciLeSetScanParamCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 224<LI>Call Chain = HciLeSetScanParamCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmScanActStart
</UL>

<P><STRONG><a name="[291]"></a>HciLeSetScanRespDataCmd</STRONG> (Thumb, 60 bytes, Stack size 24 bytes, hci_cmd.o(i.HciLeSetScanRespDataCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = HciLeSetScanRespDataCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
<LI><a href="#[1d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvActSetData
</UL>

<P><STRONG><a name="[292]"></a>HciLeStartEncryptionCmd</STRONG> (Thumb, 82 bytes, Stack size 32 bytes, hci_cmd.o(i.HciLeStartEncryptionCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 224<LI>Call Chain = HciLeStartEncryptionCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmSecMsgHandler
</UL>

<P><STRONG><a name="[293]"></a>HciLeWriteDefDataLen</STRONG> (Thumb, 54 bytes, Stack size 24 bytes, hci_cmd.o(i.HciLeWriteDefDataLen))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = HciLeWriteDefDataLen &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[255]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreResetSequence
</UL>

<P><STRONG><a name="[147]"></a>HciLlPrivacySupported</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, hci_core_ps.o(i.HciLlPrivacySupported))
<BR><BR>[Called By]<UL><LI><a href="#[146]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppAddDevToResList
<LI><a href="#[46]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerBtnCback
</UL>

<P><STRONG><a name="[294]"></a>HciReadBdAddrCmd</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, hci_cmd.o(i.HciReadBdAddrCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 200<LI>Call Chain = HciReadBdAddrCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[255]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreResetSequence
</UL>

<P><STRONG><a name="[25f]"></a>HciReadLocalVerInfoCmd</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, hci_cmd.o(i.HciReadLocalVerInfoCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 200<LI>Call Chain = HciReadLocalVerInfoCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[69]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvHandler
</UL>

<P><STRONG><a name="[295]"></a>HciReadRssiCmd</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, hci_cmd.o(i.HciReadRssiCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 208<LI>Call Chain = HciReadRssiCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConn2MsgHandler
</UL>

<P><STRONG><a name="[296]"></a>HciResetCmd</STRONG> (Thumb, 66 bytes, Stack size 24 bytes, hci_cmd.o(i.HciResetCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = HciResetCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgFree
<LI><a href="#[257]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgDeq
<LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[299]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreResetStart
</UL>

<P><STRONG><a name="[297]"></a>HciResetSequence</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, hci_core.o(i.HciResetSequence))
<BR><BR>[Stack]<UL><LI>Max Depth = 288<LI>Call Chain = HciResetSequence &rArr; hciCoreTxReady &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[299]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreResetStart
<LI><a href="#[298]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreTxReady
<LI><a href="#[1cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgFree
<LI><a href="#[257]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgDeq
</UL>
<BR>[Called By]<UL><LI><a href="#[d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmDevActReset
</UL>

<P><STRONG><a name="[2ba]"></a>HciSecRegister</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, hci_main.o(i.HciSecRegister))
<BR><BR>[Called By]<UL><LI><a href="#[2b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecInit
</UL>

<P><STRONG><a name="[29a]"></a>HciSendAclData</STRONG> (Thumb, 140 bytes, Stack size 24 bytes, hci_core.o(i.HciSendAclData))
<BR><BR>[Stack]<UL><LI>Max Depth = 256<LI>Call Chain = HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[29c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfQueueEmpty
<LI><a href="#[29f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciGetBufSize
<LI><a href="#[29d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreTxAclStart
<LI><a href="#[29b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreConnByHandle
<LI><a href="#[1cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgFree
<LI><a href="#[29e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgEnq
</UL>
<BR>[Called By]<UL><LI><a href="#[1dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cDataReq
</UL>

<P><STRONG><a name="[2a0]"></a>HciSetEventMaskCmd</STRONG> (Thumb, 36 bytes, Stack size 16 bytes, hci_cmd.o(i.HciSetEventMaskCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 208<LI>Call Chain = HciSetEventMaskCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[255]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreResetSequence
</UL>

<P><STRONG><a name="[2a1]"></a>HciSetEventMaskPage2Cmd</STRONG> (Thumb, 36 bytes, Stack size 16 bytes, hci_cmd.o(i.HciSetEventMaskPage2Cmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 208<LI>Call Chain = HciSetEventMaskPage2Cmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[255]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreResetSequence
</UL>

<P><STRONG><a name="[3b5]"></a>HciSetMaxRxAclLen</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, hci_core.o(i.HciSetMaxRxAclLen))
<BR><BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[20c]"></a>HciVsInit</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, hci_vs.o(i.HciVsInit))
<BR><BR>[Called By]<UL><LI><a href="#[219]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmDevVsInit
<LI><a href="#[20a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmAdvInit
</UL>

<P><STRONG><a name="[2a2]"></a>HciWriteAuthPayloadTimeout</STRONG> (Thumb, 54 bytes, Stack size 24 bytes, hci_cmd.o(i.HciWriteAuthPayloadTimeout))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = HciWriteAuthPayloadTimeout &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConn2MsgHandler
</UL>

<P><STRONG><a name="[1dc]"></a>L2cDataReq</STRONG> (Thumb, 68 bytes, Stack size 24 bytes, l2c_main.o(i.L2cDataReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 280<LI>Call Chain = L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[29a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciSendAclData
</UL>
<BR>[Called By]<UL><LI><a href="#[35e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsCheckPendDbHashReadRsp
<LI><a href="#[350]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcProcInd
<LI><a href="#[1da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcIndConfirm
<LI><a href="#[a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendSimpleReq
<LI><a href="#[a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendPrepWriteReq
<LI><a href="#[a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendContinuingReq
<LI><a href="#[b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcWrite
<LI><a href="#[6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadTypeReq
<LI><a href="#[7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadReq
<LI><a href="#[9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadMultReq
<LI><a href="#[a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadGroupTypeReq
<LI><a href="#[8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadBlobReq
<LI><a href="#[c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcPrepWriteReq
<LI><a href="#[3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcMtuReq
<LI><a href="#[5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcFindTypeReq
<LI><a href="#[4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcFindInfoReq
<LI><a href="#[d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcExecWriteReq
<LI><a href="#[35f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsErrRsp
<LI><a href="#[36c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsSetupMsg
<LI><a href="#[2a3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cDmConnUpdateReq
<LI><a href="#[40c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendPkt
<LI><a href="#[3d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;l2cSendCmdReject
</UL>

<P><STRONG><a name="[2a3]"></a>L2cDmConnUpdateReq</STRONG> (Thumb, 182 bytes, Stack size 24 bytes, l2c_slave.o(i.L2cDmConnUpdateReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 304<LI>Call Chain = L2cDmConnUpdateReq &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[2a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStartSec
<LI><a href="#[1dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cDataReq
<LI><a href="#[2a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;l2cMsgAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActUpdateSlave
</UL>

<P><STRONG><a name="[2a6]"></a>L2cInit</STRONG> (Thumb, 42 bytes, Stack size 8 bytes, l2c_main.o(i.L2cInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = L2cInit
</UL>
<BR>[Calls]<UL><LI><a href="#[2a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciAclRegister
</UL>
<BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[1c9]"></a>L2cRegister</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, l2c_main.o(i.L2cRegister))
<BR><BR>[Called By]<UL><LI><a href="#[1c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttHandlerInit
<LI><a href="#[2cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpHandlerInit
</UL>

<P><STRONG><a name="[63]"></a>L2cSlaveHandler</STRONG> (Thumb, 26 bytes, Stack size 16 bytes, l2c_slave.o(i.L2cSlaveHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = L2cSlaveHandler &rArr; l2cSlaveReqTimeout &rArr; DmL2cConnUpdateCnf &rArr; dmConnSmExecute
</UL>
<BR>[Calls]<UL><LI><a href="#[2a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;l2cSlaveReqTimeout
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio_task.o(i.exactle_stack_init)
</UL>
<P><STRONG><a name="[3af]"></a>L2cSlaveHandlerInit</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, l2c_slave.o(i.L2cSlaveHandlerInit))
<BR><BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[3b0]"></a>L2cSlaveInit</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, l2c_slave.o(i.L2cSlaveInit))
<BR><BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[6c]"></a>RadioTask</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, radio_task.o(i.RadioTask))
<BR><BR>[Stack]<UL><LI>Max Depth = 384<LI>Call Chain = RadioTask &rArr; BeaconScannerStart &rArr; SvcCoreAddGroup &rArr; AttsAddGroup &rArr; attsCsfSetHashUpdateStatus &rArr; attsCheckPendDbHashReadRsp &rArr; attsErrRsp &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[2ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wsfOsDispatcher
<LI><a href="#[1fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BeaconScannerStart
<LI><a href="#[2aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;setup_buttons
<LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtos.o(i.setup_task)
</UL>
<P><STRONG><a name="[2ac]"></a>RadioTaskSetup</STRONG> (Thumb, 50 bytes, Stack size 8 bytes, radio_task.o(i.RadioTaskSetup))
<BR><BR>[Stack]<UL><LI>Max Depth = 372<LI>Call Chain = RadioTaskSetup &rArr; HciDrvRadioBoot &rArr; am_hal_ble_boot &rArr; am_hal_ble_patch_complete &rArr; am_hal_ble_plf_reg_read &rArr; am_hal_ble_blocking_hci_write &rArr; am_hal_ble_blocking_transfer &rArr; am_hal_ble_cmd_write
</UL>
<BR>[Calls]<UL><LI><a href="#[1b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvRadioBoot
<LI><a href="#[265]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_printf
</UL>
<BR>[Called By]<UL><LI><a href="#[6b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;setup_task
</UL>

<P><STRONG><a name="[2ad]"></a>SecAes</STRONG> (Thumb, 72 bytes, Stack size 32 bytes, sec_aes.o(i.SecAes))
<BR><BR>[Stack]<UL><LI>Max Depth = 248<LI>Call Chain = SecAes &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[27a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeEncryptCmd
<LI><a href="#[29e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgEnq
<LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[2ae]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getNextToken
</UL>
<BR>[Called By]<UL><LI><a href="#[da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmPrivActResolveAddr
<LI><a href="#[e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmPrivActGenAddr
<LI><a href="#[408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCalcC1Part1
<LI><a href="#[411]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCalcS1
<LI><a href="#[409]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCalcC1Part2
</UL>

<P><STRONG><a name="[51]"></a>SecAesHciCback</STRONG> (Thumb, 38 bytes, Stack size 24 bytes, sec_aes.o(i.SecAesHciCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 176<LI>Call Chain = SecAesHciCback &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
<LI><a href="#[206]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Calc128Cpy
</UL>
<BR>[Address Reference Count : 1]<UL><LI> sec_aes.o(i.SecAesInit)
</UL>
<P><STRONG><a name="[3a7]"></a>SecAesInit</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, sec_aes.o(i.SecAesInit))
<BR><BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[1f3]"></a>SecCmac</STRONG> (Thumb, 114 bytes, Stack size 40 bytes, sec_cmac_hci.o(i.SecCmac))
<BR><BR>[Stack]<UL><LI>Max Depth = 344<LI>Call Chain = SecCmac &rArr; secCmacGenSubkey1 &rArr; SecLeEncryptCmd &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[206]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Calc128Cpy
<LI><a href="#[2af]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;secCmacGenSubkey1
</UL>
<BR>[Called By]<UL><LI><a href="#[1e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsHashDatabaseString
<LI><a href="#[2d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScCmac
</UL>

<P><STRONG><a name="[52]"></a>SecCmacHciCback</STRONG> (Thumb, 70 bytes, Stack size 24 bytes, sec_cmac_hci.o(i.SecCmacHciCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 352<LI>Call Chain = SecCmacHciCback &rArr; secCmacGenSubkey2 &rArr; secCmacProcessBlock &rArr; SecLeEncryptCmd &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[206]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Calc128Cpy
<LI><a href="#[2b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;secCmacProcessBlock
<LI><a href="#[2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;secCmacGenSubkey2
<LI><a href="#[2b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;secCmacComplete
</UL>
<BR>[Address Reference Count : 1]<UL><LI> sec_cmac_hci.o(i.SecCmacInit)
</UL>
<P><STRONG><a name="[3a8]"></a>SecCmacInit</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, sec_cmac_hci.o(i.SecCmacInit))
<BR><BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[234]"></a>SecEccGenKey</STRONG> (Thumb, 56 bytes, Stack size 24 bytes, sec_ecc.o(i.SecEccGenKey))
<BR><BR>[Stack]<UL><LI>Max Depth = 748<LI>Call Chain = SecEccGenKey &rArr; uECC_make_key &rArr; EccPoint_compute_public_key &rArr; EccPoint_mult &rArr; XYcZ_initial_double &rArr; EccPoint_double_jacobian &rArr; vli_modSquare_fast &rArr; vli_square &rArr; mul2add
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
<LI><a href="#[2b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uECC_make_key
</UL>
<BR>[Called By]<UL><LI><a href="#[233]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecGenerateEccKeyReq
</UL>

<P><STRONG><a name="[2b4]"></a>SecEccGenSharedSecret</STRONG> (Thumb, 92 bytes, Stack size 32 bytes, sec_ecc.o(i.SecEccGenSharedSecret))
<BR><BR>[Stack]<UL><LI>Max Depth = 812 + Unknown Stack Size
<LI>Call Chain = SecEccGenSharedSecret &rArr; uECC_shared_secret &rArr; EccPoint_mult &rArr; XYcZ_initial_double &rArr; EccPoint_double_jacobian &rArr; vli_modSquare_fast &rArr; vli_square &rArr; mul2add
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
<LI><a href="#[2b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uECC_valid_public_key
<LI><a href="#[2b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uECC_shared_secret
<LI><a href="#[13f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memset
</UL>
<BR>[Called By]<UL><LI><a href="#[41c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActCalcSharedSecret
</UL>

<P><STRONG><a name="[2b7]"></a>SecEccInit</STRONG> (Thumb, 10 bytes, Stack size 8 bytes, sec_ecc.o(i.SecEccInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = SecEccInit
</UL>
<BR>[Calls]<UL><LI><a href="#[2b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uECC_set_rng
</UL>
<BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[2b9]"></a>SecInit</STRONG> (Thumb, 54 bytes, Stack size 8 bytes, sec_main.o(i.SecInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = SecInit
</UL>
<BR>[Calls]<UL><LI><a href="#[2ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciSecRegister
</UL>
<BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[2bb]"></a>SecLeEncryptCmd</STRONG> (Thumb, 54 bytes, Stack size 56 bytes, sec_main.o(i.SecLeEncryptCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 272<LI>Call Chain = SecLeEncryptCmd &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[27a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeEncryptCmd
<LI><a href="#[29e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgEnq
<LI><a href="#[2bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WStrReverseCpy
</UL>
<BR>[Called By]<UL><LI><a href="#[2b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;secCmacProcessBlock
<LI><a href="#[2af]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;secCmacGenSubkey1
</UL>

<P><STRONG><a name="[18d]"></a>SecRand</STRONG> (Thumb, 110 bytes, Stack size 24 bytes, sec_main.o(i.SecRand))
<BR><BR>[Stack]<UL><LI>Max Depth = 224<LI>Call Chain = SecRand &rArr; HciLeRandCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[27d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeRandCmd
</UL>
<BR>[Called By]<UL><LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;secEccRng
<LI><a href="#[e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmPrivActGenAddr
<LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprActProcPairCnfCalc1
<LI><a href="#[f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActPairCnfCalc1
<LI><a href="#[18c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppHandlePasskey
<LI><a href="#[416]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpGenerateLtk
<LI><a href="#[110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActPkCalcCb
<LI><a href="#[116]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActOobSendRand
<LI><a href="#[106]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActJwncSetup
</UL>

<P><STRONG><a name="[2bd]"></a>SmpDbGetFailureCount</STRONG> (Thumb, 16 bytes, Stack size 16 bytes, smp_db.o(i.SmpDbGetFailureCount))
<BR><BR>[Stack]<UL><LI>Max Depth = 76<LI>Call Chain = SmpDbGetFailureCount &rArr; smpDbGetRecord &rArr; smpDbAddDevice &rArr; __aeabi_memclr4
</UL>
<BR>[Calls]<UL><LI><a href="#[2be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpDbGetRecord
</UL>
<BR>[Called By]<UL><LI><a href="#[57]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpDmConnCback
</UL>

<P><STRONG><a name="[2bf]"></a>SmpDbGetPairingDisabledTime</STRONG> (Thumb, 16 bytes, Stack size 16 bytes, smp_db.o(i.SmpDbGetPairingDisabledTime))
<BR><BR>[Stack]<UL><LI>Max Depth = 76<LI>Call Chain = SmpDbGetPairingDisabledTime &rArr; smpDbGetRecord &rArr; smpDbAddDevice &rArr; __aeabi_memclr4
</UL>
<BR>[Calls]<UL><LI><a href="#[2be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpDbGetRecord
</UL>
<BR>[Called By]<UL><LI><a href="#[415]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpResumeAttemptsState
</UL>

<P><STRONG><a name="[2c0]"></a>SmpDbInit</STRONG> (Thumb, 48 bytes, Stack size 8 bytes, smp_db.o(i.SmpDbInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = SmpDbInit &rArr; WsfTimerStop &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[263]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStop
<LI><a href="#[160]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Called By]<UL><LI><a href="#[ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmSecReset
<LI><a href="#[2cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpHandlerInit
</UL>

<P><STRONG><a name="[2c1]"></a>SmpDbMaxAttemptReached</STRONG> (Thumb, 88 bytes, Stack size 16 bytes, smp_db.o(i.SmpDbMaxAttemptReached))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = SmpDbMaxAttemptReached &rArr; smpDbStartServiceTimer &rArr; WsfTimerStartMs &rArr; wsfTimerInsert &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[2c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpDbStartServiceTimer
<LI><a href="#[2be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpDbGetRecord
</UL>
<BR>[Called By]<UL><LI><a href="#[fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActMaxAttempts
</UL>

<P><STRONG><a name="[2c3]"></a>SmpDbPairingFailed</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, smp_db.o(i.SmpDbPairingFailed))
<BR><BR>[Stack]<UL><LI>Max Depth = 76<LI>Call Chain = SmpDbPairingFailed &rArr; smpDbGetRecord &rArr; smpDbAddDevice &rArr; __aeabi_memclr4
</UL>
<BR>[Calls]<UL><LI><a href="#[2be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpDbGetRecord
</UL>
<BR>[Called By]<UL><LI><a href="#[232]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScGetCancelMsgWithReattempt
<LI><a href="#[121]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprActCnfVerify
<LI><a href="#[11f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActDHKeyCheckSend
</UL>

<P><STRONG><a name="[2c4]"></a>SmpDbService</STRONG> (Thumb, 152 bytes, Stack size 16 bytes, smp_db.o(i.SmpDbService))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = SmpDbService &rArr; smpDbStartServiceTimer &rArr; WsfTimerStartMs &rArr; wsfTimerInsert &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[2c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpDbStartServiceTimer
<LI><a href="#[2c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpDbRecordInUse
</UL>
<BR>[Called By]<UL><LI><a href="#[65]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpHandler
</UL>

<P><STRONG><a name="[2c6]"></a>SmpDbSetFailureCount</STRONG> (Thumb, 28 bytes, Stack size 16 bytes, smp_db.o(i.SmpDbSetFailureCount))
<BR><BR>[Stack]<UL><LI>Max Depth = 76<LI>Call Chain = SmpDbSetFailureCount &rArr; smpDbGetRecord &rArr; smpDbAddDevice &rArr; __aeabi_memclr4
</UL>
<BR>[Calls]<UL><LI><a href="#[2be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpDbGetRecord
</UL>
<BR>[Called By]<UL><LI><a href="#[57]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpDmConnCback
</UL>

<P><STRONG><a name="[2c7]"></a>SmpDmEncryptInd</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, smp_main.o(i.SmpDmEncryptInd))
<BR><BR>[Stack]<UL><LI>Max Depth = 128<LI>Call Chain = SmpDmEncryptInd &rArr; SmpHandler &rArr; SmpDbService &rArr; smpDbStartServiceTimer &rArr; WsfTimerStartMs &rArr; wsfTimerInsert &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[65]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpHandler
</UL>
<BR>[Called By]<UL><LI><a href="#[ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmSecHciHandler
</UL>

<P><STRONG><a name="[2c8]"></a>SmpDmGetStk</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, smp_main.o(i.SmpDmGetStk))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = SmpDmGetStk
</UL>
<BR>[Calls]<UL><LI><a href="#[2ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpGetScSecLevel
<LI><a href="#[2c9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCcbByConnId
</UL>
<BR>[Called By]<UL><LI><a href="#[ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmSecHciHandler
</UL>

<P><STRONG><a name="[230]"></a>SmpDmMsgSend</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, smp_main.o(i.SmpDmMsgSend))
<BR><BR>[Stack]<UL><LI>Max Depth = 160<LI>Call Chain = SmpDmMsgSend &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
</UL>
<BR>[Called By]<UL><LI><a href="#[1c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecSlaveReq
<LI><a href="#[236]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecPairRsp
<LI><a href="#[18b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecCompareRsp
<LI><a href="#[231]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecCancelReq
<LI><a href="#[18e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecAuthRsp
</UL>

<P><STRONG><a name="[65]"></a>SmpHandler</STRONG> (Thumb, 88 bytes, Stack size 24 bytes, smp_main.o(i.SmpHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 120<LI>Call Chain = SmpHandler &rArr; SmpDbService &rArr; smpDbStartServiceTimer &rArr; WsfTimerStartMs &rArr; wsfTimerInsert &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufFree
<LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
<LI><a href="#[2c9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCcbByConnId
<LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpDbService
</UL>
<BR>[Called By]<UL><LI><a href="#[2c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpDmEncryptInd
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio_task.o(i.exactle_stack_init)
</UL>
<P><STRONG><a name="[2cc]"></a>SmpHandlerInit</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, smp_main.o(i.SmpHandlerInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = SmpHandlerInit &rArr; SmpDbInit &rArr; WsfTimerStop &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[1c9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cRegister
<LI><a href="#[1ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnRegister
<LI><a href="#[2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpDbInit
</UL>
<BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[2cd]"></a>SmpScAlloc</STRONG> (Thumb, 42 bytes, Stack size 24 bytes, smp_sc_main.o(i.SmpScAlloc))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = SmpScAlloc &rArr; WsfBufAlloc
</UL>
<BR>[Calls]<UL><LI><a href="#[16d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufAlloc
<LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
</UL>
<BR>[Called By]<UL><LI><a href="#[11e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActDHKeyCalcF6Eb
<LI><a href="#[11d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActDHKeyCalcF6Ea
<LI><a href="#[11a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActCalcF5TKey
<LI><a href="#[11b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActCalcF5MacKey
<LI><a href="#[11c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActCalcF5Ltk
<LI><a href="#[41e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActJwncCalcG2
<LI><a href="#[2cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScCalcF4
</UL>

<P><STRONG><a name="[2ce]"></a>SmpScAllocScratchBuffers</STRONG> (Thumb, 122 bytes, Stack size 8 bytes, smp_sc_main.o(i.SmpScAllocScratchBuffers))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = SmpScAllocScratchBuffers &rArr; WsfBufAlloc
</UL>
<BR>[Calls]<UL><LI><a href="#[16d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScProcPairing
</UL>

<P><STRONG><a name="[2cf]"></a>SmpScCalcF4</STRONG> (Thumb, 82 bytes, Stack size 40 bytes, smp_sc_main.o(i.SmpScCalcF4))
<BR><BR>[Stack]<UL><LI>Max Depth = 416<LI>Call Chain = SmpScCalcF4 &rArr; SmpScCmac &rArr; SecCmac &rArr; secCmacGenSubkey1 &rArr; SecLeEncryptCmd &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[2d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScCat
<LI><a href="#[2d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScCmac
<LI><a href="#[2cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[41d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActJwncCalcF4
<LI><a href="#[110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActPkCalcCb
<LI><a href="#[112]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActPkCalcCa
<LI><a href="#[115]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActOobCalcCa
</UL>

<P><STRONG><a name="[2d0]"></a>SmpScCat</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, smp_sc_main.o(i.SmpScCat))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = SmpScCat
</UL>
<BR>[Calls]<UL><LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[11b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActCalcF5MacKey
<LI><a href="#[11c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActCalcF5Ltk
<LI><a href="#[41e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActJwncCalcG2
<LI><a href="#[2cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScCalcF4
</UL>

<P><STRONG><a name="[2d2]"></a>SmpScCat128</STRONG> (Thumb, 20 bytes, Stack size 16 bytes, smp_sc_main.o(i.SmpScCat128))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = SmpScCat128 &rArr; Calc128Cpy
</UL>
<BR>[Calls]<UL><LI><a href="#[206]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Calc128Cpy
</UL>
<BR>[Called By]<UL><LI><a href="#[11e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActDHKeyCalcF6Eb
<LI><a href="#[11d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActDHKeyCalcF6Ea
<LI><a href="#[11b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActCalcF5MacKey
<LI><a href="#[11c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActCalcF5Ltk
<LI><a href="#[41e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActJwncCalcG2
</UL>

<P><STRONG><a name="[2d1]"></a>SmpScCmac</STRONG> (Thumb, 68 bytes, Stack size 32 bytes, smp_sc_main.o(i.SmpScCmac))
<BR><BR>[Stack]<UL><LI>Max Depth = 376<LI>Call Chain = SmpScCmac &rArr; SecCmac &rArr; secCmacGenSubkey1 &rArr; SecLeEncryptCmd &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufFree
<LI><a href="#[1f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecCmac
<LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
</UL>
<BR>[Called By]<UL><LI><a href="#[11e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActDHKeyCalcF6Eb
<LI><a href="#[11d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActDHKeyCalcF6Ea
<LI><a href="#[11a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActCalcF5TKey
<LI><a href="#[11b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActCalcF5MacKey
<LI><a href="#[11c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActCalcF5Ltk
<LI><a href="#[41e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActJwncCalcG2
<LI><a href="#[2cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScCalcF4
</UL>

<P><STRONG><a name="[2d3]"></a>SmpScFreeScratchBuffers</STRONG> (Thumb, 106 bytes, Stack size 8 bytes, smp_sc_main.o(i.SmpScFreeScratchBuffers))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = SmpScFreeScratchBuffers &rArr; WsfBufFree
</UL>
<BR>[Calls]<UL><LI><a href="#[168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufFree
</UL>
<BR>[Called By]<UL><LI><a href="#[f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActCleanup
</UL>

<P><STRONG><a name="[232]"></a>SmpScGetCancelMsgWithReattempt</STRONG> (Thumb, 64 bytes, Stack size 24 bytes, smp_sc_main.o(i.SmpScGetCancelMsgWithReattempt))
<BR><BR>[Stack]<UL><LI>Max Depth = 100<LI>Call Chain = SmpScGetCancelMsgWithReattempt &rArr; SmpDbPairingFailed &rArr; smpDbGetRecord &rArr; smpDbAddDevice &rArr; __aeabi_memclr4
</UL>
<BR>[Calls]<UL><LI><a href="#[2c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpDbPairingFailed
<LI><a href="#[2c9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCcbByConnId
</UL>
<BR>[Called By]<UL><LI><a href="#[18b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecCompareRsp
<LI><a href="#[11a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActCalcF5TKey
<LI><a href="#[420]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScFailWithReattempt
</UL>

<P><STRONG><a name="[2d5]"></a>SmpScInit</STRONG> (Thumb, 56 bytes, Stack size 0 bytes, smp_sc_main.o(i.SmpScInit))
<BR><BR>[Called By]<UL><LI><a href="#[2d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmprScInit
</UL>

<P><STRONG><a name="[3b4]"></a>SmprInit</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, smpr_sm.o(i.SmprInit))
<BR><BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[2d4]"></a>SmprScInit</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, smpr_sc_sm.o(i.SmprScInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = SmprScInit
</UL>
<BR>[Calls]<UL><LI><a href="#[2d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScInit
</UL>
<BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[203]"></a>SvcCoreAddGroup</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, svc_core.o(i.SvcCoreAddGroup))
<BR><BR>[Stack]<UL><LI>Max Depth = 376<LI>Call Chain = SvcCoreAddGroup &rArr; AttsAddGroup &rArr; attsCsfSetHashUpdateStatus &rArr; attsCheckPendDbHashReadRsp &rArr; attsErrRsp &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsAddGroup
</UL>
<BR>[Called By]<UL><LI><a href="#[1fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BeaconScannerStart
</UL>

<P><STRONG><a name="[376]"></a>SvcCoreGapAddRpaoCh</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, svc_core.o(i.SvcCoreGapAddRpaoCh))
<BR><BR>[Called By]<UL><LI><a href="#[46]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerBtnCback
</UL>

<P><STRONG><a name="[338]"></a>SvcCoreGapCentAddrResUpdate</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, svc_core.o(i.SvcCoreGapCentAddrResUpdate))
<BR><BR>[Called By]<UL><LI><a href="#[1be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appPrivSetAddrResEnableInd
</UL>

<P><STRONG><a name="[205]"></a>SvcPxAddGroup</STRONG> (Thumb, 10 bytes, Stack size 8 bytes, svc_px.o(i.SvcPxAddGroup))
<BR><BR>[Stack]<UL><LI>Max Depth = 376<LI>Call Chain = SvcPxAddGroup &rArr; AttsAddGroup &rArr; attsCsfSetHashUpdateStatus &rArr; attsCheckPendDbHashReadRsp &rArr; attsErrRsp &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsAddGroup
</UL>
<BR>[Called By]<UL><LI><a href="#[1fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BeaconScannerStart
</UL>

<P><STRONG><a name="[204]"></a>SvcPxCbackRegister</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, svc_px.o(i.SvcPxCbackRegister))
<BR><BR>[Called By]<UL><LI><a href="#[1fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BeaconScannerStart
</UL>

<P><STRONG><a name="[19]"></a>SysTick_Handler</STRONG> (Thumb, 46 bytes, Stack size 8 bytes, port.o(i.SysTick_Handler))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = SysTick_Handler &rArr; xTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[2d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskIncrementTick
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[404]"></a>WStrReverse</STRONG> (Thumb, 40 bytes, Stack size 12 bytes, wstr.o(i.WStrReverse))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = WStrReverse
</UL>
<BR>[Called By]<UL><LI><a href="#[54]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;secHciCback
</UL>

<P><STRONG><a name="[2bc]"></a>WStrReverseCpy</STRONG> (Thumb, 26 bytes, Stack size 12 bytes, wstr.o(i.WStrReverseCpy))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = WStrReverseCpy
</UL>
<BR>[Called By]<UL><LI><a href="#[11d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActDHKeyCalcF6Ea
<LI><a href="#[425]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendRand
<LI><a href="#[424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendPubKey
<LI><a href="#[423]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendPairCnf
<LI><a href="#[422]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendDHKeyCheck
<LI><a href="#[419]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActAuthSelect
<LI><a href="#[41b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScCatResponderBdAddr
<LI><a href="#[41a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScCatInitiatorBdAddr
<LI><a href="#[f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActStoreLescPin
<LI><a href="#[117]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActStoreDhCheck
<LI><a href="#[10d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActPkStoreCnf
<LI><a href="#[112]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActPkCalcCa
<LI><a href="#[115]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActOobCalcCa
<LI><a href="#[108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActJwncCalcG2
<LI><a href="#[119]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActCalcDHKey
<LI><a href="#[2bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecLeEncryptCmd
</UL>

<P><STRONG><a name="[16d]"></a>WsfBufAlloc</STRONG> (Thumb, 68 bytes, Stack size 24 bytes, wsf_buf.o(i.WsfBufAlloc))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = WsfBufAlloc
</UL>
<BR>[Calls]<UL><LI><a href="#[2d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfCsExit
<LI><a href="#[2d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfCsEnter
</UL>
<BR>[Called By]<UL><LI><a href="#[16f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscFindService
<LI><a href="#[254]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessMsg
<LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[3c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessCmdCmpl
<LI><a href="#[3cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessLePerAdvReport
<LI><a href="#[3ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessLeExtAdvReport
<LI><a href="#[3cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessLeDirectAdvReport
<LI><a href="#[3cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessLeAdvReport
<LI><a href="#[1ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsCccAllocTbl
<LI><a href="#[6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadTypeReq
<LI><a href="#[c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcPrepWriteReq
<LI><a href="#[1e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsCalculateDbHash
<LI><a href="#[103]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprActProcPairReq
<LI><a href="#[2ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScAllocScratchBuffers
<LI><a href="#[2cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScAlloc
<LI><a href="#[16c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscConfigure
</UL>

<P><STRONG><a name="[168]"></a>WsfBufFree</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, wsf_buf.o(i.WsfBufFree))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = WsfBufFree
</UL>
<BR>[Calls]<UL><LI><a href="#[2d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfCsExit
<LI><a href="#[2d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfCsEnter
</UL>
<BR>[Called By]<UL><LI><a href="#[254]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessMsg
<LI><a href="#[1cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgFree
<LI><a href="#[3c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessCmdCmpl
<LI><a href="#[3cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessLePerAdvReport
<LI><a href="#[3ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessLeExtAdvReport
<LI><a href="#[3cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessLeDirectAdvReport
<LI><a href="#[3cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessLeAdvReport
<LI><a href="#[35e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsCheckPendDbHashReadRsp
<LI><a href="#[1e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsCccFreeTbl
<LI><a href="#[3f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attDmConnCback
<LI><a href="#[d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcExecWriteReq
<LI><a href="#[36d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcessDatabaseHashUpdate
<LI><a href="#[360]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsClearPrepWrites
<LI><a href="#[ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmSecLescMsgHandler
<LI><a href="#[2d3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScFreeScratchBuffers
<LI><a href="#[2d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScCmac
<LI><a href="#[65]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpHandler
<LI><a href="#[407]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCleanup
<LI><a href="#[166]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscComplete
<LI><a href="#[183]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscConnClose
</UL>

<P><STRONG><a name="[3a6]"></a>WsfBufInit</STRONG> (Thumb, 234 bytes, Stack size 24 bytes, wsf_buf.o(i.WsfBufInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = WsfBufInit
</UL>
<BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[2d7]"></a>WsfCsEnter</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, wsf_os.o(i.WsfCsEnter))
<BR><BR>[Called By]<UL><LI><a href="#[262]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfSetEvent
<LI><a href="#[29c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfQueueEmpty
<LI><a href="#[2e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfQueueRemove
<LI><a href="#[2e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfQueuePush
<LI><a href="#[1e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfQueueInsert
<LI><a href="#[2e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfQueueCount
<LI><a href="#[2ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wsfOsDispatcher
<LI><a href="#[1e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskLock
<LI><a href="#[2dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskSetReady
<LI><a href="#[2db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfQueueEnq
<LI><a href="#[2da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfQueueDeq
<LI><a href="#[168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufFree
<LI><a href="#[16d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufAlloc
</UL>

<P><STRONG><a name="[2d8]"></a>WsfCsExit</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, wsf_os.o(i.WsfCsExit))
<BR><BR>[Called By]<UL><LI><a href="#[262]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfSetEvent
<LI><a href="#[29c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfQueueEmpty
<LI><a href="#[2e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfQueueRemove
<LI><a href="#[2e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfQueuePush
<LI><a href="#[1e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfQueueInsert
<LI><a href="#[2e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfQueueCount
<LI><a href="#[2ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wsfOsDispatcher
<LI><a href="#[1e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskUnlock
<LI><a href="#[2dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskSetReady
<LI><a href="#[2db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfQueueEnq
<LI><a href="#[2da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfQueueDeq
<LI><a href="#[168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufFree
<LI><a href="#[16d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufAlloc
</UL>

<P><STRONG><a name="[208]"></a>WsfMsgAlloc</STRONG> (Thumb, 24 bytes, Stack size 16 bytes, wsf_msg.o(i.WsfMsgAlloc))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = WsfMsgAlloc &rArr; WsfBufAlloc
</UL>
<BR>[Calls]<UL><LI><a href="#[16d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[2d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgDataAlloc
<LI><a href="#[1b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmDevReset
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdAlloc
<LI><a href="#[261]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciTrSerialRxIncoming
<LI><a href="#[2b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecEccGenSharedSecret
<LI><a href="#[234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecEccGenKey
<LI><a href="#[1f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecCmac
<LI><a href="#[1d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendMsg
<LI><a href="#[210]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmAdvStop
<LI><a href="#[20f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmAdvStart
<LI><a href="#[20d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmAdvSetData
<LI><a href="#[207]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmAdvConfig
<LI><a href="#[1f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsHandleValueIndNtf
<LI><a href="#[2ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecAes
<LI><a href="#[223]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmPrivClearResList
<LI><a href="#[216]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmDevPrivStart
<LI><a href="#[212]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnOpenAccept
<LI><a href="#[22a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmRemoteConnParamReqReply
<LI><a href="#[229]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmRemoteConnParamReqNegReply
<LI><a href="#[215]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnUpdate
<LI><a href="#[155]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnClose
<LI><a href="#[1c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecSlaveReq
<LI><a href="#[236]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecPairRsp
<LI><a href="#[235]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecLtkRsp
<LI><a href="#[18b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecCompareRsp
<LI><a href="#[231]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecCancelReq
<LI><a href="#[18e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecAuthRsp
<LI><a href="#[19a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmScanStop
<LI><a href="#[198]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmScanStart
<LI><a href="#[1c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmPrivSetPrivacyMode
<LI><a href="#[225]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmPrivSetAddrResEnable
<LI><a href="#[224]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmPrivResolveAddr
<LI><a href="#[14a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmPrivAddDevToResList
<LI><a href="#[426]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendKey
<LI><a href="#[42]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerDmCback
<LI><a href="#[45]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerCccCback
<LI><a href="#[43]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerAttCback
</UL>

<P><STRONG><a name="[2d9]"></a>WsfMsgDataAlloc</STRONG> (Thumb, 16 bytes, Stack size 16 bytes, wsf_msg.o(i.WsfMsgDataAlloc))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = WsfMsgDataAlloc &rArr; WsfMsgAlloc &rArr; WsfBufAlloc
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[256]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreAclReassembly
<LI><a href="#[261]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciTrSerialRxIncoming
<LI><a href="#[1d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attMsgAlloc
<LI><a href="#[40b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpMsgAlloc
<LI><a href="#[2a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;l2cMsgAlloc
</UL>

<P><STRONG><a name="[257]"></a>WsfMsgDeq</STRONG> (Thumb, 26 bytes, Stack size 16 bytes, wsf_msg.o(i.WsfMsgDeq))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = WsfMsgDeq &rArr; WsfQueueDeq
</UL>
<BR>[Calls]<UL><LI><a href="#[2da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfQueueDeq
</UL>
<BR>[Called By]<UL><LI><a href="#[296]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciResetCmd
<LI><a href="#[252]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciCoreHandler
<LI><a href="#[298]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreTxReady
<LI><a href="#[297]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciResetSequence
<LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[2ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wsfOsDispatcher
<LI><a href="#[54]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;secHciCback
</UL>

<P><STRONG><a name="[29e]"></a>WsfMsgEnq</STRONG> (Thumb, 28 bytes, Stack size 24 bytes, wsf_msg.o(i.WsfMsgEnq))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = WsfMsgEnq &rArr; WsfQueueEnq
</UL>
<BR>[Calls]<UL><LI><a href="#[2db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfQueueEnq
</UL>
<BR>[Called By]<UL><LI><a href="#[3c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreRecv
<LI><a href="#[29a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciSendAclData
<LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
<LI><a href="#[2ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecAes
<LI><a href="#[2bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecLeEncryptCmd
</UL>

<P><STRONG><a name="[1cc]"></a>WsfMsgFree</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, wsf_msg.o(i.WsfMsgFree))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = WsfMsgFree &rArr; WsfBufFree
</UL>
<BR>[Calls]<UL><LI><a href="#[168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufFree
</UL>
<BR>[Called By]<UL><LI><a href="#[296]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciResetCmd
<LI><a href="#[252]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciCoreHandler
<LI><a href="#[298]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreTxReady
<LI><a href="#[3c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreTxAclComplete
<LI><a href="#[256]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreAclReassembly
<LI><a href="#[29a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciSendAclData
<LI><a href="#[297]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciResetSequence
<LI><a href="#[3ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreConnFree
<LI><a href="#[3b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciTrSendCmd
<LI><a href="#[2ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wsfOsDispatcher
<LI><a href="#[1d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendMsg
<LI><a href="#[357]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcFreePkt
<LI><a href="#[9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadMultReq
<LI><a href="#[5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcFindTypeReq
<LI><a href="#[4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcFindInfoReq
<LI><a href="#[1cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttMsgFree
<LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsIndMsgCback
<LI><a href="#[1f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsHandleValueIndNtf
<LI><a href="#[40c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendPkt
<LI><a href="#[426]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendKey
<LI><a href="#[57]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpDmConnCback
<LI><a href="#[4f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;l2cHciAclCback
</UL>

<P><STRONG><a name="[209]"></a>WsfMsgSend</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, wsf_msg.o(i.WsfMsgSend))
<BR><BR>[Stack]<UL><LI>Max Depth = 152<LI>Call Chain = WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[29e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgEnq
<LI><a href="#[2dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskSetReady
<LI><a href="#[2dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskMsgQueue
</UL>
<BR>[Called By]<UL><LI><a href="#[1b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmDevReset
<LI><a href="#[2b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecEccGenSharedSecret
<LI><a href="#[234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecEccGenKey
<LI><a href="#[1d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendMsg
<LI><a href="#[210]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmAdvStop
<LI><a href="#[20f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmAdvStart
<LI><a href="#[20d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmAdvSetData
<LI><a href="#[207]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmAdvConfig
<LI><a href="#[1f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsHandleValueIndNtf
<LI><a href="#[223]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmPrivClearResList
<LI><a href="#[216]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmDevPrivStart
<LI><a href="#[212]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnOpenAccept
<LI><a href="#[22a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmRemoteConnParamReqReply
<LI><a href="#[229]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmRemoteConnParamReqNegReply
<LI><a href="#[215]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnUpdate
<LI><a href="#[155]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnClose
<LI><a href="#[235]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecLtkRsp
<LI><a href="#[230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpDmMsgSend
<LI><a href="#[19a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmScanStop
<LI><a href="#[198]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmScanStart
<LI><a href="#[1c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmPrivSetPrivacyMode
<LI><a href="#[225]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmPrivSetAddrResEnable
<LI><a href="#[224]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmPrivResolveAddr
<LI><a href="#[14a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmPrivAddDevToResList
<LI><a href="#[426]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendKey
<LI><a href="#[2b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;secCmacComplete
<LI><a href="#[51]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecAesHciCback
<LI><a href="#[42]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerDmCback
<LI><a href="#[45]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerCccCback
<LI><a href="#[43]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerAttCback
</UL>

<P><STRONG><a name="[2de]"></a>WsfOsInit</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, wsf_os.o(i.WsfOsInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = WsfOsInit &rArr; xEventGroupCreate &rArr; pvPortMalloc &rArr; xTaskResumeAll &rArr; xTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[2df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xEventGroupCreate
<LI><a href="#[160]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[3a9]"></a>WsfOsSetNextHandler</STRONG> (Thumb, 28 bytes, Stack size 0 bytes, wsf_os.o(i.WsfOsSetNextHandler))
<BR><BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[2e0]"></a>WsfQueueCount</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, wsf_queue.o(i.WsfQueueCount))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = WsfQueueCount
</UL>
<BR>[Calls]<UL><LI><a href="#[2d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfCsExit
<LI><a href="#[2d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfCsEnter
</UL>
<BR>[Called By]<UL><LI><a href="#[c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcPrepWriteReq
</UL>

<P><STRONG><a name="[2da]"></a>WsfQueueDeq</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, wsf_queue.o(i.WsfQueueDeq))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = WsfQueueDeq
</UL>
<BR>[Calls]<UL><LI><a href="#[2d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfCsExit
<LI><a href="#[2d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfCsEnter
</UL>
<BR>[Called By]<UL><LI><a href="#[257]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgDeq
<LI><a href="#[d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcExecWriteReq
<LI><a href="#[360]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsClearPrepWrites
</UL>

<P><STRONG><a name="[29c]"></a>WsfQueueEmpty</STRONG> (Thumb, 28 bytes, Stack size 16 bytes, wsf_queue.o(i.WsfQueueEmpty))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = WsfQueueEmpty
</UL>
<BR>[Calls]<UL><LI><a href="#[2d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfCsExit
<LI><a href="#[2d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfCsEnter
</UL>
<BR>[Called By]<UL><LI><a href="#[29a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciSendAclData
</UL>

<P><STRONG><a name="[2db]"></a>WsfQueueEnq</STRONG> (Thumb, 36 bytes, Stack size 16 bytes, wsf_queue.o(i.WsfQueueEnq))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = WsfQueueEnq
</UL>
<BR>[Calls]<UL><LI><a href="#[2d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfCsExit
<LI><a href="#[2d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfCsEnter
</UL>
<BR>[Called By]<UL><LI><a href="#[29e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgEnq
<LI><a href="#[1e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfQueueInsert
<LI><a href="#[c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcPrepWriteReq
</UL>

<P><STRONG><a name="[1e3]"></a>WsfQueueInsert</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, wsf_queue.o(i.WsfQueueInsert))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = WsfQueueInsert &rArr; WsfQueuePush
</UL>
<BR>[Calls]<UL><LI><a href="#[2e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfQueuePush
<LI><a href="#[2db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfQueueEnq
<LI><a href="#[2d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfCsExit
<LI><a href="#[2d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfCsEnter
</UL>
<BR>[Called By]<UL><LI><a href="#[2ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wsfTimerInsert
<LI><a href="#[1e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsAddGroup
</UL>

<P><STRONG><a name="[2e1]"></a>WsfQueuePush</STRONG> (Thumb, 28 bytes, Stack size 16 bytes, wsf_queue.o(i.WsfQueuePush))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = WsfQueuePush
</UL>
<BR>[Calls]<UL><LI><a href="#[2d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfCsExit
<LI><a href="#[2d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfCsEnter
</UL>
<BR>[Called By]<UL><LI><a href="#[1e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfQueueInsert
</UL>

<P><STRONG><a name="[2e2]"></a>WsfQueueRemove</STRONG> (Thumb, 44 bytes, Stack size 16 bytes, wsf_queue.o(i.WsfQueueRemove))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[2d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfCsExit
<LI><a href="#[2d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfCsEnter
</UL>
<BR>[Called By]<UL><LI><a href="#[2eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wsfTimerRemove
<LI><a href="#[2e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerServiceExpired
</UL>

<P><STRONG><a name="[262]"></a>WsfSetEvent</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, wsf_os.o(i.WsfSetEvent))
<BR><BR>[Stack]<UL><LI>Max Depth = 136<LI>Call Chain = WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[2e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfSetOsSpecificEvent
<LI><a href="#[2d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfCsExit
<LI><a href="#[2d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfCsEnter
</UL>
<BR>[Called By]<UL><LI><a href="#[3c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreRecv
<LI><a href="#[3c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciDrvWrite
<LI><a href="#[26b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvIntService
<LI><a href="#[69]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvHandler
</UL>

<P><STRONG><a name="[2e3]"></a>WsfSetOsSpecificEvent</STRONG> (Thumb, 108 bytes, Stack size 16 bytes, wsf_os.o(i.WsfSetOsSpecificEvent))
<BR><BR>[Stack]<UL><LI>Max Depth = 120<LI>Call Chain = WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[2e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTimerPendFunctionCallFromISR
<LI><a href="#[2e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xEventGroupSetBits
</UL>
<BR>[Called By]<UL><LI><a href="#[262]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfSetEvent
<LI><a href="#[2dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskSetReady
</UL>

<P><STRONG><a name="[1e2]"></a>WsfTaskLock</STRONG> (Thumb, 8 bytes, Stack size 4 bytes, wsf_os.o(i.WsfTaskLock))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = WsfTaskLock
</UL>
<BR>[Calls]<UL><LI><a href="#[2d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfCsEnter
</UL>
<BR>[Called By]<UL><LI><a href="#[263]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStop
<LI><a href="#[2ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerUpdate
<LI><a href="#[2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerNextExpiration
<LI><a href="#[2ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wsfTimerInsert
<LI><a href="#[2e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerServiceExpired
<LI><a href="#[1f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsSetAttr
<LI><a href="#[1d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendMsg
<LI><a href="#[20e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmAdvSetInterval
<LI><a href="#[1ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnRegister
<LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnSetIdle
<LI><a href="#[213]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnCheckIdle
<LI><a href="#[1f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsHandleValueIndNtf
<LI><a href="#[1e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsAddGroup
<LI><a href="#[212]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnOpenAccept
<LI><a href="#[20a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmAdvInit
<LI><a href="#[1fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecSetLocalIrk
<LI><a href="#[22b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmScanInit
<LI><a href="#[22f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmScanSetInterval
</UL>

<P><STRONG><a name="[2dc]"></a>WsfTaskMsgQueue</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, wsf_os.o(i.WsfTaskMsgQueue))
<BR><BR>[Called By]<UL><LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
</UL>

<P><STRONG><a name="[2dd]"></a>WsfTaskSetReady</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, wsf_os.o(i.WsfTaskSetReady))
<BR><BR>[Stack]<UL><LI>Max Depth = 136<LI>Call Chain = WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[2e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfSetOsSpecificEvent
<LI><a href="#[2d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfCsExit
<LI><a href="#[2d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfCsEnter
</UL>
<BR>[Called By]<UL><LI><a href="#[2ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerUpdate
<LI><a href="#[5d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimer_handler
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
<LI><a href="#[29]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_uart_isr
<LI><a href="#[26]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_ble_isr
</UL>

<P><STRONG><a name="[1e5]"></a>WsfTaskUnlock</STRONG> (Thumb, 8 bytes, Stack size 4 bytes, wsf_os.o(i.WsfTaskUnlock))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = WsfTaskUnlock
</UL>
<BR>[Calls]<UL><LI><a href="#[2d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfCsExit
</UL>
<BR>[Called By]<UL><LI><a href="#[263]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStop
<LI><a href="#[2ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerUpdate
<LI><a href="#[2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerNextExpiration
<LI><a href="#[2ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wsfTimerInsert
<LI><a href="#[2e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerServiceExpired
<LI><a href="#[1f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsSetAttr
<LI><a href="#[1d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendMsg
<LI><a href="#[20e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmAdvSetInterval
<LI><a href="#[1ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnRegister
<LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnSetIdle
<LI><a href="#[213]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnCheckIdle
<LI><a href="#[1f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsHandleValueIndNtf
<LI><a href="#[1e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsAddGroup
<LI><a href="#[212]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnOpenAccept
<LI><a href="#[20a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmAdvInit
<LI><a href="#[1fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecSetLocalIrk
<LI><a href="#[22b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmScanInit
<LI><a href="#[22f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmScanSetInterval
</UL>

<P><STRONG><a name="[2e6]"></a>WsfTimerInit</STRONG> (Thumb, 48 bytes, Stack size 8 bytes, wsf_timer.o(i.WsfTimerInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 184<LI>Call Chain = WsfTimerInit &rArr; xTimerCreate &rArr; prvInitialiseNewTimer &rArr; prvCheckForValidListAndQueue &rArr; xQueueGenericCreate &rArr; pvPortMalloc &rArr; xTaskResumeAll &rArr; xTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[2e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTimerCreate
</UL>
<BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
</UL>

<P><STRONG><a name="[2e8]"></a>WsfTimerNextExpiration</STRONG> (Thumb, 40 bytes, Stack size 16 bytes, wsf_timer.o(i.WsfTimerNextExpiration))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = WsfTimerNextExpiration &rArr; WsfTaskUnlock
</UL>
<BR>[Calls]<UL><LI><a href="#[1e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskUnlock
<LI><a href="#[1e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskLock
</UL>
<BR>[Called By]<UL><LI><a href="#[2ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerUpdateTicks
</UL>

<P><STRONG><a name="[2e9]"></a>WsfTimerServiceExpired</STRONG> (Thumb, 52 bytes, Stack size 16 bytes, wsf_timer.o(i.WsfTimerServiceExpired))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = WsfTimerServiceExpired &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[2e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfQueueRemove
<LI><a href="#[1e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskUnlock
<LI><a href="#[1e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskLock
</UL>
<BR>[Called By]<UL><LI><a href="#[2ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wsfOsDispatcher
</UL>

<P><STRONG><a name="[260]"></a>WsfTimerStartMs</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, wsf_timer.o(i.WsfTimerStartMs))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = WsfTimerStartMs &rArr; wsfTimerInsert &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[2ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wsfTimerInsert
</UL>
<BR>[Called By]<UL><LI><a href="#[c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvHciHandler
<LI><a href="#[ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmScanHciHandler
<LI><a href="#[fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActMaxAttempts
<LI><a href="#[69]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvHandler
<LI><a href="#[415]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpResumeAttemptsState
<LI><a href="#[2c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpDbStartServiceTimer
<LI><a href="#[68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;button_handler
<LI><a href="#[335]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appConnUpdateTimerStart
<LI><a href="#[1f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerProcMsg
</UL>

<P><STRONG><a name="[2a4]"></a>WsfTimerStartSec</STRONG> (Thumb, 20 bytes, Stack size 16 bytes, wsf_timer.o(i.WsfTimerStartSec))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = WsfTimerStartSec &rArr; wsfTimerInsert &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[2ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wsfTimerInsert
</UL>
<BR>[Called By]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
<LI><a href="#[a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendSimpleReq
<LI><a href="#[a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendPrepWriteReq
<LI><a href="#[a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendContinuingReq
<LI><a href="#[362]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsDiscBusy
<LI><a href="#[36c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsSetupMsg
<LI><a href="#[2a3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cDmConnUpdateReq
<LI><a href="#[40a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpStartRspTimer
<LI><a href="#[2aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;setup_buttons
<LI><a href="#[1f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerProcMsg
</UL>

<P><STRONG><a name="[263]"></a>WsfTimerStop</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, wsf_timer.o(i.WsfTimerStop))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = WsfTimerStop &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[2eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wsfTimerRemove
<LI><a href="#[1e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskUnlock
<LI><a href="#[1e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskLock
</UL>
<BR>[Called By]<UL><LI><a href="#[268]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvRadioShutdown
<LI><a href="#[3b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdRecvCmpl
<LI><a href="#[34f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcProcRsp
<LI><a href="#[a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcMsgCback
<LI><a href="#[a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcConnCback
<LI><a href="#[b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsConnCback
<LI><a href="#[e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcValueCnf
<LI><a href="#[b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsIndConnCback
<LI><a href="#[c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvReset
<LI><a href="#[c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvHciHandler
<LI><a href="#[388]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvConnected
<LI><a href="#[386]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvConnectFailed
<LI><a href="#[2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpDbInit
<LI><a href="#[e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmScanReset
<LI><a href="#[ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmScanHciHandler
<LI><a href="#[69]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvHandler
<LI><a href="#[407]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCleanup
<LI><a href="#[50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;l2cSlaveRxSignalingPkt
<LI><a href="#[336]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appConnUpdateTimerStop
</UL>

<P><STRONG><a name="[2ec]"></a>WsfTimerUpdate</STRONG> (Thumb, 52 bytes, Stack size 16 bytes, wsf_timer.o(i.WsfTimerUpdate))
<BR><BR>[Stack]<UL><LI>Max Depth = 152<LI>Call Chain = WsfTimerUpdate &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskUnlock
<LI><a href="#[1e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskLock
<LI><a href="#[2dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskSetReady
</UL>
<BR>[Called By]<UL><LI><a href="#[2ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerUpdateTicks
</UL>

<P><STRONG><a name="[2ed]"></a>WsfTimerUpdateTicks</STRONG> (Thumb, 102 bytes, Stack size 32 bytes, wsf_timer.o(i.WsfTimerUpdateTicks))
<BR><BR>[Stack]<UL><LI>Max Depth = 184<LI>Call Chain = WsfTimerUpdateTicks &rArr; xTimerGenericCommand &rArr; xQueueGenericSend &rArr; vTaskPlaceOnEventList &rArr; prvAddCurrentTaskToDelayedList &rArr; vListInsert
</UL>
<BR>[Calls]<UL><LI><a href="#[2ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTimerGenericCommand
<LI><a href="#[2ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskGetTickCount
<LI><a href="#[2ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerUpdate
<LI><a href="#[2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerNextExpiration
</UL>
<BR>[Called By]<UL><LI><a href="#[2ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wsfOsDispatcher
</UL>

<P><STRONG><a name="[26]"></a>am_ble_isr</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, radio_task.o(i.am_ble_isr))
<BR><BR>[Stack]<UL><LI>Max Depth = 152<LI>Call Chain = am_ble_isr &rArr; HciDrvIntService &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[2dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskSetReady
<LI><a href="#[26b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvIntService
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[2f1]"></a>am_bsp_itm_printf_enable</STRONG> (Thumb, 44 bytes, Stack size 24 bytes, am_bsp.o(i.am_bsp_itm_printf_enable))
<BR><BR>[Stack]<UL><LI>Max Depth = 104<LI>Call Chain = am_bsp_itm_printf_enable &rArr; am_hal_gpio_pinconfig
</UL>
<BR>[Calls]<UL><LI><a href="#[2f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_pinconfig
<LI><a href="#[2f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_printf_init
<LI><a href="#[2f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_tpiu_enable
<LI><a href="#[2f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_itm_enable
</UL>
<BR>[Called By]<UL><LI><a href="#[3a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;enable_print_interface
</UL>

<P><STRONG><a name="[2f6]"></a>am_bsp_low_power_init</STRONG> (Thumb, 58 bytes, Stack size 24 bytes, am_bsp.o(i.am_bsp_low_power_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 104<LI>Call Chain = am_bsp_low_power_init &rArr; am_hal_gpio_pinconfig
</UL>
<BR>[Calls]<UL><LI><a href="#[2f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_state_write
<LI><a href="#[2f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_pinconfig
<LI><a href="#[2f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_rtc_osc_disable
<LI><a href="#[2f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_low_power_init
</UL>
<BR>[Called By]<UL><LI><a href="#[135]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[28]"></a>am_ctimer_isr</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, rtos.o(i.am_ctimer_isr))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = am_ctimer_isr &rArr; am_hal_ctimer_int_status_get
</UL>
<BR>[Calls]<UL><LI><a href="#[2fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ctimer_int_status_get
<LI><a href="#[2fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ctimer_int_service
<LI><a href="#[2fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ctimer_int_clear
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[2fd]"></a>am_devices_button_array_init</STRONG> (Thumb, 26 bytes, Stack size 16 bytes, am_devices_button.o(i.am_devices_button_array_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 104<LI>Call Chain = am_devices_button_array_init &rArr; am_devices_button_init &rArr; am_hal_gpio_pinconfig
</UL>
<BR>[Calls]<UL><LI><a href="#[2fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_button_init
</UL>
<BR>[Called By]<UL><LI><a href="#[2aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;setup_buttons
</UL>

<P><STRONG><a name="[2ff]"></a>am_devices_button_array_tick</STRONG> (Thumb, 26 bytes, Stack size 16 bytes, am_devices_button.o(i.am_devices_button_array_tick))
<BR><BR>[Stack]<UL><LI>Max Depth = 112<LI>Call Chain = am_devices_button_array_tick &rArr; am_devices_button_tick &rArr; am_hal_gpio_pinconfig
</UL>
<BR>[Calls]<UL><LI><a href="#[300]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_button_tick
</UL>
<BR>[Called By]<UL><LI><a href="#[68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;button_handler
</UL>

<P><STRONG><a name="[2fe]"></a>am_devices_button_init</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, am_devices_button.o(i.am_devices_button_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = am_devices_button_init &rArr; am_hal_gpio_pinconfig
</UL>
<BR>[Calls]<UL><LI><a href="#[2f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_pinconfig
</UL>
<BR>[Called By]<UL><LI><a href="#[2fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_button_array_init
</UL>

<P><STRONG><a name="[300]"></a>am_devices_button_tick</STRONG> (Thumb, 92 bytes, Stack size 16 bytes, am_devices_button.o(i.am_devices_button_tick))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = am_devices_button_tick &rArr; am_hal_gpio_pinconfig
</UL>
<BR>[Calls]<UL><LI><a href="#[301]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_state_read
<LI><a href="#[2f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_pinconfig
</UL>
<BR>[Called By]<UL><LI><a href="#[2ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_button_array_tick
</UL>

<P><STRONG><a name="[302]"></a>am_freertos_sleep</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, rtos.o(i.am_freertos_sleep))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = am_freertos_sleep &rArr; am_hal_sysctrl_sleep
</UL>
<BR>[Calls]<UL><LI><a href="#[303]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_sysctrl_sleep
</UL>
<BR>[Called By]<UL><LI><a href="#[3e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortSuppressTicksAndSleep
</UL>

<P><STRONG><a name="[432]"></a>am_freertos_wakeup</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, rtos.o(i.am_freertos_wakeup))
<BR><BR>[Called By]<UL><LI><a href="#[3e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortSuppressTicksAndSleep
</UL>

<P><STRONG><a name="[264]"></a>am_hal_ble_blocking_hci_read</STRONG> (Thumb, 142 bytes, Stack size 48 bytes, am_hal_ble.o(i.am_hal_ble_blocking_hci_read))
<BR><BR>[Stack]<UL><LI>Max Depth = 92<LI>Call Chain = am_hal_ble_blocking_hci_read &rArr; am_hal_ble_blocking_transfer &rArr; am_hal_ble_cmd_write
</UL>
<BR>[Calls]<UL><LI><a href="#[304]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_blocking_transfer
</UL>
<BR>[Called By]<UL><LI><a href="#[69]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvHandler
<LI><a href="#[30e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_plf_reg_write
<LI><a href="#[30d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_plf_reg_read
</UL>

<P><STRONG><a name="[269]"></a>am_hal_ble_blocking_hci_write</STRONG> (Thumb, 70 bytes, Stack size 48 bytes, am_hal_ble.o(i.am_hal_ble_blocking_hci_write))
<BR><BR>[Stack]<UL><LI>Max Depth = 92<LI>Call Chain = am_hal_ble_blocking_hci_write &rArr; am_hal_ble_blocking_transfer &rArr; am_hal_ble_cmd_write
</UL>
<BR>[Calls]<UL><LI><a href="#[304]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_blocking_transfer
</UL>
<BR>[Called By]<UL><LI><a href="#[69]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvHandler
<LI><a href="#[30e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_plf_reg_write
<LI><a href="#[30d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_plf_reg_read
<LI><a href="#[30a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_patch_apply
</UL>

<P><STRONG><a name="[304]"></a>am_hal_ble_blocking_transfer</STRONG> (Thumb, 1110 bytes, Stack size 40 bytes, am_hal_ble.o(i.am_hal_ble_blocking_transfer))
<BR><BR>[Stack]<UL><LI>Max Depth = 44<LI>Call Chain = am_hal_ble_blocking_transfer &rArr; am_hal_ble_cmd_write
</UL>
<BR>[Calls]<UL><LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[305]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
<LI><a href="#[308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_wakeup_set
<LI><a href="#[309]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_cmd_write
<LI><a href="#[307]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_delay
</UL>
<BR>[Called By]<UL><LI><a href="#[269]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_blocking_hci_write
<LI><a href="#[264]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_blocking_hci_read
<LI><a href="#[30b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_patch_copy_end_apply
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_patch_complete
<LI><a href="#[30a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_patch_apply
</UL>

<P><STRONG><a name="[272]"></a>am_hal_ble_boot</STRONG> (Thumb, 454 bytes, Stack size 40 bytes, am_hal_ble.o(i.am_hal_ble_boot))
<BR><BR>[Stack]<UL><LI>Max Depth = 316<LI>Call Chain = am_hal_ble_boot &rArr; am_hal_ble_patch_complete &rArr; am_hal_ble_plf_reg_read &rArr; am_hal_ble_blocking_hci_write &rArr; am_hal_ble_blocking_transfer &rArr; am_hal_ble_cmd_write
</UL>
<BR>[Calls]<UL><LI><a href="#[30d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_plf_reg_read
<LI><a href="#[30b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_patch_copy_end_apply
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_patch_complete
<LI><a href="#[30a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_patch_apply
</UL>
<BR>[Called By]<UL><LI><a href="#[1b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvRadioBoot
</UL>

<P><STRONG><a name="[270]"></a>am_hal_ble_config</STRONG> (Thumb, 306 bytes, Stack size 12 bytes, am_hal_ble.o(i.am_hal_ble_config))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = am_hal_ble_config
</UL>
<BR>[Called By]<UL><LI><a href="#[1b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvRadioBoot
</UL>

<P><STRONG><a name="[273]"></a>am_hal_ble_deinitialize</STRONG> (Thumb, 84 bytes, Stack size 0 bytes, am_hal_ble.o(i.am_hal_ble_deinitialize))
<BR><BR>[Called By]<UL><LI><a href="#[268]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvRadioShutdown
<LI><a href="#[1b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvRadioBoot
</UL>

<P><STRONG><a name="[26e]"></a>am_hal_ble_initialize</STRONG> (Thumb, 110 bytes, Stack size 0 bytes, am_hal_ble.o(i.am_hal_ble_initialize))
<BR><BR>[Called By]<UL><LI><a href="#[1b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvRadioBoot
</UL>

<P><STRONG><a name="[26d]"></a>am_hal_ble_int_clear</STRONG> (Thumb, 36 bytes, Stack size 0 bytes, am_hal_ble.o(i.am_hal_ble_int_clear))
<BR><BR>[Called By]<UL><LI><a href="#[1b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvRadioBoot
<LI><a href="#[26b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvIntService
</UL>

<P><STRONG><a name="[275]"></a>am_hal_ble_int_enable</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, am_hal_ble.o(i.am_hal_ble_int_enable))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = am_hal_ble_int_enable
</UL>
<BR>[Calls]<UL><LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[305]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
</UL>
<BR>[Called By]<UL><LI><a href="#[1b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvRadioBoot
</UL>

<P><STRONG><a name="[26c]"></a>am_hal_ble_int_status</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, am_hal_ble.o(i.am_hal_ble_int_status))
<BR><BR>[Called By]<UL><LI><a href="#[26b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvIntService
</UL>

<P><STRONG><a name="[30a]"></a>am_hal_ble_patch_apply</STRONG> (Thumb, 804 bytes, Stack size 104 bytes, am_hal_ble.o(i.am_hal_ble_patch_apply))
<BR><BR>[Stack]<UL><LI>Max Depth = 196<LI>Call Chain = am_hal_ble_patch_apply &rArr; am_hal_ble_blocking_hci_write &rArr; am_hal_ble_blocking_transfer &rArr; am_hal_ble_cmd_write
</UL>
<BR>[Calls]<UL><LI><a href="#[269]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_blocking_hci_write
<LI><a href="#[304]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_blocking_transfer
<LI><a href="#[307]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_delay
<LI><a href="#[13e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4
</UL>
<BR>[Called By]<UL><LI><a href="#[272]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_boot
</UL>

<P><STRONG><a name="[30c]"></a>am_hal_ble_patch_complete</STRONG> (Thumb, 656 bytes, Stack size 112 bytes, am_hal_ble.o(i.am_hal_ble_patch_complete))
<BR><BR>[Stack]<UL><LI>Max Depth = 276<LI>Call Chain = am_hal_ble_patch_complete &rArr; am_hal_ble_plf_reg_read &rArr; am_hal_ble_blocking_hci_write &rArr; am_hal_ble_blocking_transfer &rArr; am_hal_ble_cmd_write
</UL>
<BR>[Calls]<UL><LI><a href="#[30e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_plf_reg_write
<LI><a href="#[30d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_plf_reg_read
<LI><a href="#[308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_wakeup_set
<LI><a href="#[304]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_blocking_transfer
<LI><a href="#[307]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_delay
</UL>
<BR>[Called By]<UL><LI><a href="#[272]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_boot
</UL>

<P><STRONG><a name="[30b]"></a>am_hal_ble_patch_copy_end_apply</STRONG> (Thumb, 318 bytes, Stack size 120 bytes, am_hal_ble.o(i.am_hal_ble_patch_copy_end_apply))
<BR><BR>[Stack]<UL><LI>Max Depth = 164<LI>Call Chain = am_hal_ble_patch_copy_end_apply &rArr; am_hal_ble_blocking_transfer &rArr; am_hal_ble_cmd_write
</UL>
<BR>[Calls]<UL><LI><a href="#[304]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_blocking_transfer
<LI><a href="#[307]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_delay
</UL>
<BR>[Called By]<UL><LI><a href="#[272]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_boot
</UL>

<P><STRONG><a name="[30d]"></a>am_hal_ble_plf_reg_read</STRONG> (Thumb, 212 bytes, Stack size 72 bytes, am_hal_ble.o(i.am_hal_ble_plf_reg_read))
<BR><BR>[Stack]<UL><LI>Max Depth = 164<LI>Call Chain = am_hal_ble_plf_reg_read &rArr; am_hal_ble_blocking_hci_write &rArr; am_hal_ble_blocking_transfer &rArr; am_hal_ble_cmd_write
</UL>
<BR>[Calls]<UL><LI><a href="#[269]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_blocking_hci_write
<LI><a href="#[264]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_blocking_hci_read
<LI><a href="#[307]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_delay
</UL>
<BR>[Called By]<UL><LI><a href="#[274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_tx_power_set
<LI><a href="#[272]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_boot
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_patch_complete
</UL>

<P><STRONG><a name="[30e]"></a>am_hal_ble_plf_reg_write</STRONG> (Thumb, 214 bytes, Stack size 64 bytes, am_hal_ble.o(i.am_hal_ble_plf_reg_write))
<BR><BR>[Stack]<UL><LI>Max Depth = 156<LI>Call Chain = am_hal_ble_plf_reg_write &rArr; am_hal_ble_blocking_hci_write &rArr; am_hal_ble_blocking_transfer &rArr; am_hal_ble_cmd_write
</UL>
<BR>[Calls]<UL><LI><a href="#[269]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_blocking_hci_write
<LI><a href="#[264]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_blocking_hci_read
<LI><a href="#[307]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_delay
</UL>
<BR>[Called By]<UL><LI><a href="#[274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_tx_power_set
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_patch_complete
</UL>

<P><STRONG><a name="[26f]"></a>am_hal_ble_power_control</STRONG> (Thumb, 340 bytes, Stack size 32 bytes, am_hal_ble.o(i.am_hal_ble_power_control))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = am_hal_ble_power_control &rArr; am_hal_pwrctrl_periph_enable
</UL>
<BR>[Calls]<UL><LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_periph_enable
<LI><a href="#[310]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_periph_disable
<LI><a href="#[30f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_blebuck_trim
<LI><a href="#[307]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_delay
</UL>
<BR>[Called By]<UL><LI><a href="#[268]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvRadioShutdown
<LI><a href="#[1b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvRadioBoot
</UL>

<P><STRONG><a name="[274]"></a>am_hal_ble_tx_power_set</STRONG> (Thumb, 154 bytes, Stack size 40 bytes, am_hal_ble.o(i.am_hal_ble_tx_power_set))
<BR><BR>[Stack]<UL><LI>Max Depth = 204<LI>Call Chain = am_hal_ble_tx_power_set &rArr; am_hal_ble_plf_reg_read &rArr; am_hal_ble_blocking_hci_write &rArr; am_hal_ble_blocking_transfer &rArr; am_hal_ble_cmd_write
</UL>
<BR>[Calls]<UL><LI><a href="#[30e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_plf_reg_write
<LI><a href="#[30d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_plf_reg_read
</UL>
<BR>[Called By]<UL><LI><a href="#[1b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvRadioBoot
</UL>

<P><STRONG><a name="[308]"></a>am_hal_ble_wakeup_set</STRONG> (Thumb, 54 bytes, Stack size 0 bytes, am_hal_ble.o(i.am_hal_ble_wakeup_set))
<BR><BR>[Called By]<UL><LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_patch_complete
<LI><a href="#[304]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_blocking_transfer
</UL>

<P><STRONG><a name="[312]"></a>am_hal_cachectrl_config</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, am_hal_cachectrl.o(i.am_hal_cachectrl_config))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = am_hal_cachectrl_config
</UL>
<BR>[Calls]<UL><LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[305]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
</UL>
<BR>[Called By]<UL><LI><a href="#[135]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[313]"></a>am_hal_cachectrl_control</STRONG> (Thumb, 710 bytes, Stack size 16 bytes, am_hal_cachectrl.o(i.am_hal_cachectrl_control))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = am_hal_cachectrl_control &rArr; am_hal_flash_store_ui32
</UL>
<BR>[Calls]<UL><LI><a href="#[315]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_store_ui32
<LI><a href="#[314]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_load_ui32
<LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[305]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
</UL>
<BR>[Called By]<UL><LI><a href="#[2f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_low_power_init
</UL>

<P><STRONG><a name="[3d2]"></a>am_hal_cachectrl_enable</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, am_hal_cachectrl.o(i.am_hal_cachectrl_enable))
<BR><BR>[Called By]<UL><LI><a href="#[135]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[316]"></a>am_hal_clkgen_control</STRONG> (Thumb, 236 bytes, Stack size 8 bytes, am_hal_clkgen.o(i.am_hal_clkgen_control))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = am_hal_clkgen_control
</UL>
<BR>[Calls]<UL><LI><a href="#[307]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_delay
</UL>
<BR>[Called By]<UL><LI><a href="#[135]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[31c]"></a>am_hal_clkgen_status_get</STRONG> (Thumb, 44 bytes, Stack size 0 bytes, am_hal_clkgen.o(i.am_hal_clkgen_status_get))
<BR><BR>[Called By]<UL><LI><a href="#[267]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_delay_us
<LI><a href="#[271]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_delay_ms
<LI><a href="#[2f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_tpiu_enable
</UL>

<P><STRONG><a name="[2fb]"></a>am_hal_ctimer_int_clear</STRONG> (Thumb, 26 bytes, Stack size 16 bytes, am_hal_ctimer.o(i.am_hal_ctimer_int_clear))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = am_hal_ctimer_int_clear
</UL>
<BR>[Calls]<UL><LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[305]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
</UL>
<BR>[Called By]<UL><LI><a href="#[28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_ctimer_isr
</UL>

<P><STRONG><a name="[2fc]"></a>am_hal_ctimer_int_service</STRONG> (Thumb, 46 bytes, Stack size 16 bytes, am_hal_ctimer.o(i.am_hal_ctimer_int_service))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = am_hal_ctimer_int_service
</UL>
<BR>[Called By]<UL><LI><a href="#[28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_ctimer_isr
</UL>

<P><STRONG><a name="[2fa]"></a>am_hal_ctimer_int_status_get</STRONG> (Thumb, 44 bytes, Stack size 16 bytes, am_hal_ctimer.o(i.am_hal_ctimer_int_status_get))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = am_hal_ctimer_int_status_get
</UL>
<BR>[Calls]<UL><LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[305]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
</UL>
<BR>[Called By]<UL><LI><a href="#[28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_ctimer_isr
</UL>

<P><STRONG><a name="[307]"></a>am_hal_flash_delay</STRONG> (Thumb, 30 bytes, Stack size 0 bytes, am_hal_flash.o(i.am_hal_flash_delay))
<BR><BR>[Called By]<UL><LI><a href="#[267]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_delay_us
<LI><a href="#[271]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_delay_ms
<LI><a href="#[26f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_power_control
<LI><a href="#[318]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_memory_enable
<LI><a href="#[316]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_clkgen_control
<LI><a href="#[30e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_plf_reg_write
<LI><a href="#[30d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_plf_reg_read
<LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_periph_enable
<LI><a href="#[310]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_periph_disable
<LI><a href="#[30b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_patch_copy_end_apply
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_patch_complete
<LI><a href="#[30a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_patch_apply
<LI><a href="#[304]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_blocking_transfer
<LI><a href="#[2f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_tpiu_enable
<LI><a href="#[2f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_low_power_init
</UL>

<P><STRONG><a name="[317]"></a>am_hal_flash_delay_status_check</STRONG> (Thumb, 86 bytes, Stack size 32 bytes, am_hal_flash.o(i.am_hal_flash_delay_status_check))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = am_hal_flash_delay_status_check
</UL>
<BR>[Called By]<UL><LI><a href="#[2f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_low_power_init
</UL>

<P><STRONG><a name="[314]"></a>am_hal_flash_load_ui32</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, am_hal_flash.o(i.am_hal_flash_load_ui32))
<BR><BR>[Called By]<UL><LI><a href="#[313]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_cachectrl_control
</UL>

<P><STRONG><a name="[315]"></a>am_hal_flash_store_ui32</STRONG> (Thumb, 36 bytes, Stack size 16 bytes, am_hal_flash.o(i.am_hal_flash_store_ui32))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = am_hal_flash_store_ui32
</UL>
<BR>[Called By]<UL><LI><a href="#[313]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_cachectrl_control
</UL>

<P><STRONG><a name="[2f4]"></a>am_hal_gpio_pinconfig</STRONG> (Thumb, 586 bytes, Stack size 80 bytes, am_hal_gpio.o(i.am_hal_gpio_pinconfig))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = am_hal_gpio_pinconfig
</UL>
<BR>[Calls]<UL><LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[305]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
</UL>
<BR>[Called By]<UL><LI><a href="#[2f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_bsp_low_power_init
<LI><a href="#[2f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_bsp_itm_printf_enable
<LI><a href="#[300]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_button_tick
<LI><a href="#[2fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_button_init
</UL>

<P><STRONG><a name="[301]"></a>am_hal_gpio_state_read</STRONG> (Thumb, 90 bytes, Stack size 0 bytes, am_hal_gpio.o(i.am_hal_gpio_state_read))
<BR><BR>[Called By]<UL><LI><a href="#[300]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_button_tick
</UL>

<P><STRONG><a name="[2f9]"></a>am_hal_gpio_state_write</STRONG> (Thumb, 128 bytes, Stack size 24 bytes, am_hal_gpio.o(i.am_hal_gpio_state_write))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = am_hal_gpio_state_write
</UL>
<BR>[Calls]<UL><LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[305]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
</UL>
<BR>[Called By]<UL><LI><a href="#[2f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_bsp_low_power_init
</UL>

<P><STRONG><a name="[2f2]"></a>am_hal_itm_enable</STRONG> (Thumb, 44 bytes, Stack size 0 bytes, am_hal_itm.o(i.am_hal_itm_enable))
<BR><BR>[Called By]<UL><LI><a href="#[2f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_bsp_itm_printf_enable
</UL>

<P><STRONG><a name="[5e]"></a>am_hal_itm_print</STRONG> (Thumb, 48 bytes, Stack size 0 bytes, am_hal_itm.o(i.am_hal_itm_print))
<BR>[Address Reference Count : 1]<UL><LI> am_bsp.o(i.am_bsp_itm_printf_enable)
</UL>
<P><STRONG><a name="[321]"></a>am_hal_mcuctrl_info_get</STRONG> (Thumb, 278 bytes, Stack size 0 bytes, am_hal_mcuctrl.o(i.am_hal_mcuctrl_info_get))
<BR><BR>[Called By]<UL><LI><a href="#[13c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_faultisr_collect_data
</UL>

<P><STRONG><a name="[30f]"></a>am_hal_pwrctrl_blebuck_trim</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, am_hal_pwrctrl.o(i.am_hal_pwrctrl_blebuck_trim))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = am_hal_pwrctrl_blebuck_trim
</UL>
<BR>[Calls]<UL><LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[305]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
</UL>
<BR>[Called By]<UL><LI><a href="#[26f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_power_control
</UL>

<P><STRONG><a name="[2f7]"></a>am_hal_pwrctrl_low_power_init</STRONG> (Thumb, 386 bytes, Stack size 32 bytes, am_hal_pwrctrl.o(i.am_hal_pwrctrl_low_power_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = am_hal_pwrctrl_low_power_init &rArr; am_hal_flash_delay_status_check
</UL>
<BR>[Calls]<UL><LI><a href="#[317]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_delay_status_check
<LI><a href="#[313]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_cachectrl_control
<LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[305]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
<LI><a href="#[307]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_delay
</UL>
<BR>[Called By]<UL><LI><a href="#[2f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_bsp_low_power_init
</UL>

<P><STRONG><a name="[318]"></a>am_hal_pwrctrl_memory_enable</STRONG> (Thumb, 98 bytes, Stack size 24 bytes, am_hal_pwrctrl.o(i.am_hal_pwrctrl_memory_enable))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = am_hal_pwrctrl_memory_enable
</UL>
<BR>[Calls]<UL><LI><a href="#[307]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_delay
</UL>
<BR>[Called By]<UL><LI><a href="#[135]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[310]"></a>am_hal_pwrctrl_periph_disable</STRONG> (Thumb, 70 bytes, Stack size 24 bytes, am_hal_pwrctrl.o(i.am_hal_pwrctrl_periph_disable))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = am_hal_pwrctrl_periph_disable
</UL>
<BR>[Calls]<UL><LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[305]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
<LI><a href="#[307]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_delay
</UL>
<BR>[Called By]<UL><LI><a href="#[26f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_power_control
</UL>

<P><STRONG><a name="[311]"></a>am_hal_pwrctrl_periph_enable</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, am_hal_pwrctrl.o(i.am_hal_pwrctrl_periph_enable))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = am_hal_pwrctrl_periph_enable
</UL>
<BR>[Calls]<UL><LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[305]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
<LI><a href="#[307]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_delay
</UL>
<BR>[Called By]<UL><LI><a href="#[26f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_power_control
</UL>

<P><STRONG><a name="[25e]"></a>am_hal_queue_init</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, am_hal_queue.o(i.am_hal_queue_init))
<BR><BR>[Called By]<UL><LI><a href="#[1b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvRadioBoot
<LI><a href="#[25d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvEmptyWriteQueue
</UL>

<P><STRONG><a name="[319]"></a>am_hal_queue_item_add</STRONG> (Thumb, 164 bytes, Stack size 24 bytes, am_hal_queue.o(i.am_hal_queue_item_add))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = am_hal_queue_item_add
</UL>
<BR>[Calls]<UL><LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[305]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
</UL>
<BR>[Called By]<UL><LI><a href="#[3c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciDrvWrite
</UL>

<P><STRONG><a name="[26a]"></a>am_hal_queue_item_get</STRONG> (Thumb, 152 bytes, Stack size 24 bytes, am_hal_queue.o(i.am_hal_queue_item_get))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = am_hal_queue_item_get
</UL>
<BR>[Calls]<UL><LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[305]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
</UL>
<BR>[Called By]<UL><LI><a href="#[69]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvHandler
</UL>

<P><STRONG><a name="[2f8]"></a>am_hal_rtc_osc_disable</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, am_hal_rtc.o(i.am_hal_rtc_osc_disable))
<BR><BR>[Called By]<UL><LI><a href="#[2f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_bsp_low_power_init
</UL>

<P><STRONG><a name="[31a]"></a>am_hal_stimer_compare_delta_set</STRONG> (Thumb, 166 bytes, Stack size 24 bytes, am_hal_stimer.o(i.am_hal_stimer_compare_delta_set))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = am_hal_stimer_compare_delta_set
</UL>
<BR>[Calls]<UL><LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[305]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
</UL>
<BR>[Called By]<UL><LI><a href="#[31f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xPortStimerTickHandler
<LI><a href="#[3e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortSuppressTicksAndSleep
<LI><a href="#[42b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortSetupTimerInterrupt
</UL>

<P><STRONG><a name="[42f]"></a>am_hal_stimer_config</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, am_hal_stimer.o(i.am_hal_stimer_config))
<BR><BR>[Called By]<UL><LI><a href="#[42b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortSetupTimerInterrupt
</UL>

<P><STRONG><a name="[430]"></a>am_hal_stimer_counter_get</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, am_hal_stimer.o(i.am_hal_stimer_counter_get))
<BR><BR>[Called By]<UL><LI><a href="#[31f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xPortStimerTickHandler
<LI><a href="#[3e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortSuppressTicksAndSleep
<LI><a href="#[42b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortSetupTimerInterrupt
</UL>

<P><STRONG><a name="[31e]"></a>am_hal_stimer_int_clear</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, am_hal_stimer.o(i.am_hal_stimer_int_clear))
<BR><BR>[Called By]<UL><LI><a href="#[3e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortSuppressTicksAndSleep
<LI><a href="#[32]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_stimer_cmpr1_isr
<LI><a href="#[31]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_stimer_cmpr0_isr
</UL>

<P><STRONG><a name="[42c]"></a>am_hal_stimer_int_enable</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, am_hal_stimer.o(i.am_hal_stimer_int_enable))
<BR><BR>[Called By]<UL><LI><a href="#[42b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortSetupTimerInterrupt
</UL>

<P><STRONG><a name="[31d]"></a>am_hal_stimer_int_status_get</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, am_hal_stimer.o(i.am_hal_stimer_int_status_get))
<BR><BR>[Called By]<UL><LI><a href="#[32]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_stimer_cmpr1_isr
<LI><a href="#[31]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_stimer_cmpr0_isr
</UL>

<P><STRONG><a name="[3d3]"></a>am_hal_sysctrl_fpu_enable</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, am_hal_sysctrl.o(i.am_hal_sysctrl_fpu_enable))
<BR><BR>[Called By]<UL><LI><a href="#[135]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[31b]"></a>am_hal_sysctrl_fpu_stacking_enable</STRONG> (Thumb, 44 bytes, Stack size 16 bytes, am_hal_sysctrl.o(i.am_hal_sysctrl_fpu_stacking_enable))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = am_hal_sysctrl_fpu_stacking_enable
</UL>
<BR>[Calls]<UL><LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[305]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
</UL>
<BR>[Called By]<UL><LI><a href="#[135]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[303]"></a>am_hal_sysctrl_sleep</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, am_hal_sysctrl.o(i.am_hal_sysctrl_sleep))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = am_hal_sysctrl_sleep
</UL>
<BR>[Calls]<UL><LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[305]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
</UL>
<BR>[Called By]<UL><LI><a href="#[302]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_freertos_sleep
</UL>

<P><STRONG><a name="[2f3]"></a>am_hal_tpiu_enable</STRONG> (Thumb, 122 bytes, Stack size 40 bytes, am_hal_tpiu.o(i.am_hal_tpiu_enable))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = am_hal_tpiu_enable
</UL>
<BR>[Calls]<UL><LI><a href="#[31c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_clkgen_status_get
<LI><a href="#[307]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_delay
</UL>
<BR>[Called By]<UL><LI><a href="#[2f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_bsp_itm_printf_enable
</UL>

<P><STRONG><a name="[31]"></a>am_stimer_cmpr0_isr</STRONG> (Thumb, 30 bytes, Stack size 8 bytes, port.o(i.am_stimer_cmpr0_isr))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = am_stimer_cmpr0_isr &rArr; xPortStimerTickHandler &rArr; am_hal_stimer_compare_delta_set
</UL>
<BR>[Calls]<UL><LI><a href="#[31d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_stimer_int_status_get
<LI><a href="#[31e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_stimer_int_clear
<LI><a href="#[31f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xPortStimerTickHandler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[32]"></a>am_stimer_cmpr1_isr</STRONG> (Thumb, 40 bytes, Stack size 8 bytes, port.o(i.am_stimer_cmpr1_isr))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = am_stimer_cmpr1_isr &rArr; xPortStimerTickHandler &rArr; am_hal_stimer_compare_delta_set
</UL>
<BR>[Calls]<UL><LI><a href="#[31d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_stimer_int_status_get
<LI><a href="#[31e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_stimer_int_clear
<LI><a href="#[31f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xPortStimerTickHandler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[29]"></a>am_uart_isr</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, radio_task.o(i.am_uart_isr))
<BR><BR>[Stack]<UL><LI>Max Depth = 144<LI>Call Chain = am_uart_isr &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[2dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskSetReady
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_keil.o(RESET)
</UL>
<P><STRONG><a name="[271]"></a>am_util_delay_ms</STRONG> (Thumb, 32 bytes, Stack size 32 bytes, am_util_delay.o(i.am_util_delay_ms))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = am_util_delay_ms
</UL>
<BR>[Calls]<UL><LI><a href="#[31c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_clkgen_status_get
<LI><a href="#[307]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_delay
</UL>
<BR>[Called By]<UL><LI><a href="#[1b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvRadioBoot
</UL>

<P><STRONG><a name="[267]"></a>am_util_delay_us</STRONG> (Thumb, 30 bytes, Stack size 32 bytes, am_util_delay.o(i.am_util_delay_us))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = am_util_delay_us
</UL>
<BR>[Calls]<UL><LI><a href="#[31c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_clkgen_status_get
<LI><a href="#[307]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_delay
</UL>
<BR>[Called By]<UL><LI><a href="#[69]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvHandler
</UL>

<P><STRONG><a name="[13c]"></a>am_util_faultisr_collect_data</STRONG> (Thumb, 180 bytes, Stack size 72 bytes, am_util_faultisr.o(i.am_util_faultisr_collect_data))
<BR><BR>[Stack]<UL><LI>Max Depth = 76<LI>Call Chain = am_util_faultisr_collect_data &rArr; __aeabi_memclr4
</UL>
<BR>[Calls]<UL><LI><a href="#[321]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_mcuctrl_info_get
<LI><a href="#[320]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getStackedReg
<LI><a href="#[160]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Called By]<UL><LI><a href="#[11]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HardFault_Handler
</UL>

<P><STRONG><a name="[265]"></a>am_util_stdio_printf</STRONG> (Thumb, 50 bytes, Stack size 32 bytes, am_util_stdio.o(i.am_util_stdio_printf))
<BR><BR>[Stack]<UL><LI>Max Depth = 292<LI>Call Chain = am_util_stdio_printf &rArr; am_util_stdio_vsprintf &rArr; ftoa &rArr; uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[322]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_vsprintf
</UL>
<BR>[Called By]<UL><LI><a href="#[268]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvRadioShutdown
<LI><a href="#[1b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvRadioBoot
<LI><a href="#[69]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvHandler
<LI><a href="#[6b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;setup_task
<LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exactle_stack_init
<LI><a href="#[68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;button_handler
<LI><a href="#[2ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioTaskSetup
<LI><a href="#[135]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[2f5]"></a>am_util_stdio_printf_init</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, am_util_stdio.o(i.am_util_stdio_printf_init))
<BR><BR>[Called By]<UL><LI><a href="#[2f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_bsp_itm_printf_enable
</UL>

<P><STRONG><a name="[322]"></a>am_util_stdio_vsprintf</STRONG> (Thumb, 932 bytes, Stack size 96 bytes, am_util_stdio.o(i.am_util_stdio_vsprintf))
<BR><BR>[Stack]<UL><LI>Max Depth = 260<LI>Call Chain = am_util_stdio_vsprintf &rArr; ftoa &rArr; uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[329]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uint64_to_str
<LI><a href="#[327]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uint64_to_hexstr
<LI><a href="#[324]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;simple_strlen
<LI><a href="#[325]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;padbuffer
<LI><a href="#[328]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ndigits_in_u64
<LI><a href="#[32a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ndigits_in_i64
<LI><a href="#[326]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ndigits_in_hex
<LI><a href="#[32c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ftoa
<LI><a href="#[323]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;decstr_to_int
<LI><a href="#[32b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_d2f
</UL>
<BR>[Called By]<UL><LI><a href="#[265]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_printf
</UL>

<P><STRONG><a name="[14d]"></a>appAdvSetData</STRONG> (Thumb, 126 bytes, Stack size 32 bytes, app_slave.o(i.appAdvSetData))
<BR><BR>[Stack]<UL><LI>Max Depth = 256<LI>Call Chain = appAdvSetData &rArr; appSetAdvScanDataFrag &rArr; DmAdvSetData &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[32d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSetAdvScanDataFrag
</UL>
<BR>[Called By]<UL><LI><a href="#[14b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppAdvSetData
</UL>

<P><STRONG><a name="[32e]"></a>appAdvStart</STRONG> (Thumb, 186 bytes, Stack size 40 bytes, app_slave.o(i.appAdvStart))
<BR><BR>[Stack]<UL><LI>Max Depth = 288<LI>Call Chain = appAdvStart &rArr; appSetAdvScanData &rArr; appSetAdvScanDataFrag &rArr; DmAdvSetData &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[20f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmAdvStart
<LI><a href="#[20e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmAdvSetInterval
<LI><a href="#[207]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmAdvConfig
<LI><a href="#[330]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appNumConns
<LI><a href="#[32f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveConnectableAdv
<LI><a href="#[331]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSetAdvScanData
</UL>
<BR>[Called By]<UL><LI><a href="#[343]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveLegAdvStart
<LI><a href="#[14f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveAdvStart
</UL>

<P><STRONG><a name="[151]"></a>appAdvStop</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, app_slave.o(i.appAdvStop))
<BR><BR>[Stack]<UL><LI>Max Depth = 192<LI>Call Chain = appAdvStop &rArr; DmAdvStop &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[210]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmAdvStop
<LI><a href="#[332]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppSlaveIsAdvertising
</UL>
<BR>[Called By]<UL><LI><a href="#[150]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppAdvStop
</UL>

<P><STRONG><a name="[153]"></a>appConnAccept</STRONG> (Thumb, 200 bytes, Stack size 48 bytes, app_slave.o(i.appConnAccept))
<BR><BR>[Stack]<UL><LI>Max Depth = 296<LI>Call Chain = appConnAccept &rArr; DmConnAccept &rArr; dmConnOpenAccept &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[20e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmAdvSetInterval
<LI><a href="#[207]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmAdvConfig
<LI><a href="#[333]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmLlPrivEnabled
<LI><a href="#[211]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnAccept
<LI><a href="#[334]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetPeerAddrRes
<LI><a href="#[331]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSetAdvScanData
</UL>
<BR>[Called By]<UL><LI><a href="#[152]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppConnAccept
</UL>

<P><STRONG><a name="[336]"></a>appConnUpdateTimerStop</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, app_slave.o(i.appConnUpdateTimerStop))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = appConnUpdateTimerStop &rArr; WsfTimerStop &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[263]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStop
</UL>
<BR>[Called By]<UL><LI><a href="#[341]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveProcConnClose
<LI><a href="#[1af]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveConnUpdate
</UL>

<P><STRONG><a name="[172]"></a>appDiscRestartDiscovery</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, app_disc.o(i.appDiscRestartDiscovery))
<BR><BR>[Stack]<UL><LI>Max Depth = 288<LI>Call Chain = appDiscRestartDiscovery &rArr; appDiscStart &rArr; AttcReadByTypeReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[169]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetHdl
<LI><a href="#[162]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbSetHdlList
<LI><a href="#[16b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbSetDiscStatus
<LI><a href="#[17e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscStart
<LI><a href="#[1d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr
</UL>
<BR>[Called By]<UL><LI><a href="#[187]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscServiceChanged
<LI><a href="#[171]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscProcAttMsg
</UL>

<P><STRONG><a name="[17e]"></a>appDiscStart</STRONG> (Thumb, 166 bytes, Stack size 32 bytes, app_disc.o(i.appDiscStart))
<BR><BR>[Stack]<UL><LI>Max Depth = 272<LI>Call Chain = appDiscStart &rArr; AttcReadByTypeReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[169]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetHdl
<LI><a href="#[1d3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcReadByTypeReq
<LI><a href="#[16a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppCheckBonded
<LI><a href="#[337]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbIsCacheCheckedByHash
<LI><a href="#[178]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetHdlList
<LI><a href="#[179]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetDiscStatus
<LI><a href="#[17a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscCfgStart
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[172]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscRestartDiscovery
<LI><a href="#[171]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscProcAttMsg
<LI><a href="#[184]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscPairCmpl
<LI><a href="#[186]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscEncryptInd
<LI><a href="#[182]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscConnOpen
</UL>

<P><STRONG><a name="[3b]"></a>appMasterProcMsg</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, app_master.o(i.appMasterProcMsg))
<BR>[Address Reference Count : 1]<UL><LI> app_master.o(i.AppMasterInit)
</UL>
<P><STRONG><a name="[330]"></a>appNumConns</STRONG> (Thumb, 48 bytes, Stack size 24 bytes, app_main.o(i.appNumConns))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = appNumConns
</UL>
<BR>[Calls]<UL><LI><a href="#[173]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnRole
</UL>
<BR>[Called By]<UL><LI><a href="#[32e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appAdvStart
</UL>

<P><STRONG><a name="[1b7]"></a>appSecConnClose</STRONG> (Thumb, 18 bytes, Stack size 16 bytes, app_slave.o(i.appSecConnClose))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = appSecConnClose &rArr; AppDbCheckValidRecord
</UL>
<BR>[Calls]<UL><LI><a href="#[156]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbCheckValidRecord
</UL>
<BR>[Called By]<UL><LI><a href="#[1b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppSlaveSecProcDmMsg
</UL>

<P><STRONG><a name="[14f]"></a>appSlaveAdvStart</STRONG> (Thumb, 128 bytes, Stack size 48 bytes, app_slave.o(i.appSlaveAdvStart))
<BR><BR>[Stack]<UL><LI>Max Depth = 336<LI>Call Chain = appSlaveAdvStart &rArr; appAdvStart &rArr; appSetAdvScanData &rArr; appSetAdvScanDataFrag &rArr; DmAdvSetData &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[33d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppSetBondable
<LI><a href="#[33f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbCheckBonded
<LI><a href="#[32e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appAdvStart
<LI><a href="#[340]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveForceAdvDataSync
</UL>
<BR>[Called By]<UL><LI><a href="#[14e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppAdvStart
</UL>

<P><STRONG><a name="[3c]"></a>appSlaveProcMsg</STRONG> (Thumb, 48 bytes, Stack size 16 bytes, app_slave.o(i.appSlaveProcMsg))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = appSlaveProcMsg &rArr; appSlaveConnUpdateTimeout &rArr; DmConnUpdate &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveConnUpdateTimeout
</UL>
<BR>[Address Reference Count : 1]<UL><LI> app_slave.o(i.AppSlaveInit)
</UL>
<P><STRONG><a name="[1b6]"></a>appSlaveSecConnOpen</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, app_slave.o(i.appSlaveSecConnOpen))
<BR><BR>[Stack]<UL><LI>Max Depth = 208<LI>Call Chain = appSlaveSecConnOpen &rArr; appSlaveResolveAddr &rArr; DmPrivResolveAddr &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecSlaveReq
<LI><a href="#[158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbFindByAddr
<LI><a href="#[33f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbCheckBonded
<LI><a href="#[346]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveResolveAddr
</UL>
<BR>[Called By]<UL><LI><a href="#[1b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppSlaveSecProcDmMsg
</UL>

<P><STRONG><a name="[339]"></a>appUiBtnPoll</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, app_ui.o(i.appUiBtnPoll))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = appUiBtnPoll
</UL>
<BR>[Called By]<UL><LI><a href="#[191]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appProcMsg
</UL>

<P><STRONG><a name="[33a]"></a>appUiTimerExpired</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, app_ui.o(i.appUiTimerExpired))
<BR><BR>[Called By]<UL><LI><a href="#[191]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appProcMsg
</UL>

<P><STRONG><a name="[349]"></a>attCcbByConnId</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, att_main.o(i.attCcbByConnId))
<BR><BR>[Called By]<UL><LI><a href="#[3d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attL2cCtrlCback
<LI><a href="#[3f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attDmConnCback
</UL>

<P><STRONG><a name="[347]"></a>attCcbByHandle</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, att_main.o(i.attCcbByHandle))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = attCcbByHandle
</UL>
<BR>[Calls]<UL><LI><a href="#[348]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnIdByHandle
</UL>
<BR>[Called By]<UL><LI><a href="#[b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsDataCback
</UL>

<P><STRONG><a name="[b8]"></a>attEmptyConnCback</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, att_main.o(i.attEmptyConnCback))
<BR>[Address Reference Count : 1]<UL><LI> att_main.o(.constdata)
</UL>
<P><STRONG><a name="[b0]"></a>attEmptyDataCback</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, att_main.o(i.attEmptyDataCback))
<BR>[Address Reference Count : 2]<UL><LI> atts_ind.o(.constdata)
<LI> att_main.o(.constdata)
</UL>
<P><STRONG><a name="[41]"></a>attEmptyHandler</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, att_main.o(i.attEmptyHandler))
<BR>[Address Reference Count : 2]<UL><LI> atts_main.o(i.AttsInit)
<LI> att_main.o(.constdata)
</UL>
<P><STRONG><a name="[1cf]"></a>attExecCallback</STRONG> (Thumb, 66 bytes, Stack size 40 bytes, att_main.o(i.attExecCallback))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = attExecCallback
</UL>
<BR>[Called By]<UL><LI><a href="#[34a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attSetMtu
<LI><a href="#[356]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcExecCallback
<LI><a href="#[1cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttRegister
<LI><a href="#[363]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsExecCallback
</UL>

<P><STRONG><a name="[1d7]"></a>attMsgAlloc</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, att_main.o(i.attMsgAlloc))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = attMsgAlloc &rArr; WsfMsgDataAlloc &rArr; WsfMsgAlloc &rArr; WsfBufAlloc
</UL>
<BR>[Calls]<UL><LI><a href="#[2d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgDataAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[35e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsCheckPendDbHashReadRsp
<LI><a href="#[1df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcWriteCmd
<LI><a href="#[350]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcProcInd
<LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcMtuReq
<LI><a href="#[1da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcIndConfirm
<LI><a href="#[a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendPrepWriteReq
<LI><a href="#[a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendContinuingReq
<LI><a href="#[1e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcWriteReq
<LI><a href="#[1de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcReadReq
<LI><a href="#[1d3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcReadByTypeReq
<LI><a href="#[1d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcFindInfoReq
<LI><a href="#[1d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcFindByTypeValueReq
<LI><a href="#[b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcWrite
<LI><a href="#[6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadTypeReq
<LI><a href="#[7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadReq
<LI><a href="#[9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadMultReq
<LI><a href="#[a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadGroupTypeReq
<LI><a href="#[8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadBlobReq
<LI><a href="#[c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcPrepWriteReq
<LI><a href="#[3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcMtuReq
<LI><a href="#[5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcFindTypeReq
<LI><a href="#[4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcFindInfoReq
<LI><a href="#[d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcExecWriteReq
<LI><a href="#[35f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsErrRsp
<LI><a href="#[1f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsHandleValueIndNtf
</UL>

<P><STRONG><a name="[34a]"></a>attSetMtu</STRONG> (Thumb, 44 bytes, Stack size 24 bytes, att_main.o(i.attSetMtu))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = attSetMtu &rArr; attExecCallback
</UL>
<BR>[Calls]<UL><LI><a href="#[1cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attExecCallback
</UL>
<BR>[Called By]<UL><LI><a href="#[a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcProcMtuRsp
<LI><a href="#[3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcMtuReq
</UL>

<P><STRONG><a name="[34b]"></a>attUuidCmp16to128</STRONG> (Thumb, 36 bytes, Stack size 16 bytes, att_main.o(i.attUuidCmp16to128))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = attUuidCmp16to128 &rArr; memcmp
</UL>
<BR>[Calls]<UL><LI><a href="#[15c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
</UL>
<BR>[Called By]<UL><LI><a href="#[354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcUuidCmp
<LI><a href="#[366]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsUuidCmp
<LI><a href="#[370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsUuid16Cmp
</UL>

<P><STRONG><a name="[34c]"></a>attcCcbByConnId</STRONG> (Thumb, 30 bytes, Stack size 8 bytes, attc_main.o(i.attcCcbByConnId))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = attcCcbByConnId
</UL>
<BR>[Calls]<UL><LI><a href="#[214]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnInUse
</UL>
<BR>[Called By]<UL><LI><a href="#[1d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendMsg
<LI><a href="#[a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcMsgCback
<LI><a href="#[a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcCtrlCback
</UL>

<P><STRONG><a name="[1db]"></a>attcCcbByHandle</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, attc_main.o(i.attcCcbByHandle))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = attcCcbByHandle
</UL>
<BR>[Calls]<UL><LI><a href="#[348]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnIdByHandle
</UL>
<BR>[Called By]<UL><LI><a href="#[1da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcIndConfirm
<LI><a href="#[9f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcDataCback
</UL>

<P><STRONG><a name="[356]"></a>attcExecCallback</STRONG> (Thumb, 32 bytes, Stack size 24 bytes, attc_main.o(i.attcExecCallback))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = attcExecCallback &rArr; attExecCallback
</UL>
<BR>[Calls]<UL><LI><a href="#[1cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attExecCallback
</UL>
<BR>[Called By]<UL><LI><a href="#[1d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendMsg
<LI><a href="#[34d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcReqClear
<LI><a href="#[34e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcWriteCmdCallback
<LI><a href="#[a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendWriteCmd
</UL>

<P><STRONG><a name="[357]"></a>attcFreePkt</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, attc_main.o(i.attcFreePkt))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = attcFreePkt &rArr; WsfMsgFree &rArr; WsfBufFree
</UL>
<BR>[Calls]<UL><LI><a href="#[1cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgFree
</UL>
<BR>[Called By]<UL><LI><a href="#[34f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcProcRsp
<LI><a href="#[34d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcReqClear
<LI><a href="#[a3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendMtuReq
<LI><a href="#[a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcMsgCback
</UL>

<P><STRONG><a name="[a8]"></a>attcProcErrRsp</STRONG> (Thumb, 76 bytes, Stack size 16 bytes, attc_proc.o(i.attcProcErrRsp))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = attcProcErrRsp
</UL>
<BR>[Address Reference Count : 1]<UL><LI> attc_proc.o(.constdata)
</UL>
<P><STRONG><a name="[ab]"></a>attcProcFindByTypeRsp</STRONG> (Thumb, 176 bytes, Stack size 28 bytes, attc_read.o(i.attcProcFindByTypeRsp))
<BR><BR>[Stack]<UL><LI>Max Depth = 28<LI>Call Chain = attcProcFindByTypeRsp
</UL>
<BR>[Address Reference Count : 1]<UL><LI> attc_proc.o(.constdata)
</UL>
<P><STRONG><a name="[aa]"></a>attcProcFindOrReadRsp</STRONG> (Thumb, 286 bytes, Stack size 32 bytes, attc_proc.o(i.attcProcFindOrReadRsp))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = attcProcFindOrReadRsp
</UL>
<BR>[Address Reference Count : 1]<UL><LI> attc_proc.o(.constdata)
</UL>
<P><STRONG><a name="[350]"></a>attcProcInd</STRONG> (Thumb, 160 bytes, Stack size 40 bytes, attc_proc.o(i.attcProcInd))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = attcProcInd &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attMsgAlloc
<LI><a href="#[1dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cDataReq
</UL>
<BR>[Called By]<UL><LI><a href="#[9f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcDataCback
</UL>

<P><STRONG><a name="[a9]"></a>attcProcMtuRsp</STRONG> (Thumb, 74 bytes, Stack size 32 bytes, attc_proc.o(i.attcProcMtuRsp))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = attcProcMtuRsp &rArr; attSetMtu &rArr; attExecCallback
</UL>
<BR>[Calls]<UL><LI><a href="#[1ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciGetMaxRxAclLen
<LI><a href="#[34a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attSetMtu
</UL>
<BR>[Address Reference Count : 1]<UL><LI> attc_proc.o(.constdata)
</UL>
<P><STRONG><a name="[af]"></a>attcProcPrepWriteRsp</STRONG> (Thumb, 30 bytes, Stack size 12 bytes, attc_write.o(i.attcProcPrepWriteRsp))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = attcProcPrepWriteRsp
</UL>
<BR>[Address Reference Count : 1]<UL><LI> attc_proc.o(.constdata)
</UL>
<P><STRONG><a name="[ad]"></a>attcProcReadLongRsp</STRONG> (Thumb, 32 bytes, Stack size 12 bytes, attc_read.o(i.attcProcReadLongRsp))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = attcProcReadLongRsp
</UL>
<BR>[Address Reference Count : 1]<UL><LI> attc_proc.o(.constdata)
</UL>
<P><STRONG><a name="[ac]"></a>attcProcReadRsp</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, attc_proc.o(i.attcProcReadRsp))
<BR>[Address Reference Count : 1]<UL><LI> attc_proc.o(.constdata)
</UL>
<P><STRONG><a name="[34f]"></a>attcProcRsp</STRONG> (Thumb, 200 bytes, Stack size 40 bytes, attc_proc.o(i.attcProcRsp))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = attcProcRsp &rArr; WsfTimerStop &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[263]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStop
<LI><a href="#[359]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSetupReq
<LI><a href="#[35a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendReq
<LI><a href="#[357]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcFreePkt
</UL>
<BR>[Called By]<UL><LI><a href="#[9f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcDataCback
</UL>

<P><STRONG><a name="[ae]"></a>attcProcWriteRsp</STRONG> (Thumb, 8 bytes, Stack size 8 bytes, attc_proc.o(i.attcProcWriteRsp))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = attcProcWriteRsp
</UL>
<BR>[Address Reference Count : 1]<UL><LI> attc_proc.o(.constdata)
</UL>
<P><STRONG><a name="[34d]"></a>attcReqClear</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, attc_main.o(i.attcReqClear))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = attcReqClear &rArr; attcExecCallback &rArr; attExecCallback
</UL>
<BR>[Calls]<UL><LI><a href="#[357]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcFreePkt
<LI><a href="#[356]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcExecCallback
</UL>
<BR>[Called By]<UL><LI><a href="#[a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendPrepWriteReq
<LI><a href="#[a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendContinuingReq
<LI><a href="#[a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcMsgCback
<LI><a href="#[a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcConnCback
</UL>

<P><STRONG><a name="[1d8]"></a>attcSendMsg</STRONG> (Thumb, 184 bytes, Stack size 48 bytes, attc_proc.o(i.attcSendMsg))
<BR><BR>[Stack]<UL><LI>Max Depth = 200<LI>Call Chain = attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgFree
<LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[1e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskUnlock
<LI><a href="#[1e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskLock
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
<LI><a href="#[356]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcExecCallback
<LI><a href="#[34c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcCcbByConnId
</UL>
<BR>[Called By]<UL><LI><a href="#[1df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcWriteCmd
<LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcMtuReq
<LI><a href="#[1e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcWriteReq
<LI><a href="#[1de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcReadReq
<LI><a href="#[1d3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcReadByTypeReq
<LI><a href="#[1d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcFindInfoReq
<LI><a href="#[1d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcFindByTypeValueReq
</UL>

<P><STRONG><a name="[35a]"></a>attcSendReq</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, attc_main.o(i.attcSendReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = attcSendReq
</UL>
<BR>[Called By]<UL><LI><a href="#[34f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcProcRsp
<LI><a href="#[359]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSetupReq
</UL>

<P><STRONG><a name="[359]"></a>attcSetupReq</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, attc_main.o(i.attcSetupReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = attcSetupReq &rArr; attcSendReq
</UL>
<BR>[Calls]<UL><LI><a href="#[35a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendReq
</UL>
<BR>[Called By]<UL><LI><a href="#[34f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcProcRsp
<LI><a href="#[a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcMsgCback
</UL>

<P><STRONG><a name="[35e]"></a>attsCheckPendDbHashReadRsp</STRONG> (Thumb, 186 bytes, Stack size 32 bytes, atts_main.o(i.attsCheckPendDbHashReadRsp))
<BR><BR>[Stack]<UL><LI>Max Depth = 344<LI>Call Chain = attsCheckPendDbHashReadRsp &rArr; attsErrRsp &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufFree
<LI><a href="#[1d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attMsgAlloc
<LI><a href="#[1dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cDataReq
<LI><a href="#[1ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsFindByHandle
<LI><a href="#[35f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsErrRsp
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[1e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsCsfSetHashUpdateStatus
</UL>

<P><STRONG><a name="[360]"></a>attsClearPrepWrites</STRONG> (Thumb, 24 bytes, Stack size 16 bytes, atts_main.o(i.attsClearPrepWrites))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = attsClearPrepWrites &rArr; WsfQueueDeq
</UL>
<BR>[Calls]<UL><LI><a href="#[2da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfQueueDeq
<LI><a href="#[168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufFree
</UL>
<BR>[Called By]<UL><LI><a href="#[d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcExecWriteReq
<LI><a href="#[b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsConnCback
</UL>

<P><STRONG><a name="[361]"></a>attsCsfActClientState</STRONG> (Thumb, 154 bytes, Stack size 24 bytes, atts_csf.o(i.attsCsfActClientState))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = attsCsfActClientState
</UL>
<BR>[Called By]<UL><LI><a href="#[b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsDataCback
</UL>

<P><STRONG><a name="[371]"></a>attsCsfGetHashUpdateStatus</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, atts_csf.o(i.attsCsfGetHashUpdateStatus))
<BR><BR>[Called By]<UL><LI><a href="#[6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadTypeReq
</UL>

<P><STRONG><a name="[369]"></a>attsCsfIsClientChangeAware</STRONG> (Thumb, 40 bytes, Stack size 0 bytes, atts_csf.o(i.attsCsfIsClientChangeAware))
<BR><BR>[Called By]<UL><LI><a href="#[1f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsHandleValueIndNtf
</UL>

<P><STRONG><a name="[1e4]"></a>attsCsfSetHashUpdateStatus</STRONG> (Thumb, 64 bytes, Stack size 8 bytes, atts_csf.o(i.attsCsfSetHashUpdateStatus))
<BR><BR>[Stack]<UL><LI>Max Depth = 352<LI>Call Chain = attsCsfSetHashUpdateStatus &rArr; attsCheckPendDbHashReadRsp &rArr; attsErrRsp &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[35e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsCheckPendDbHashReadRsp
</UL>
<BR>[Called By]<UL><LI><a href="#[36d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcessDatabaseHashUpdate
<LI><a href="#[1e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsAddGroup
</UL>

<P><STRONG><a name="[362]"></a>attsDiscBusy</STRONG> (Thumb, 54 bytes, Stack size 8 bytes, atts_main.o(i.attsDiscBusy))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = attsDiscBusy &rArr; WsfTimerStartSec &rArr; wsfTimerInsert &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[2a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStartSec
<LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnSetIdle
</UL>
<BR>[Called By]<UL><LI><a href="#[a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadGroupTypeReq
<LI><a href="#[5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcFindTypeReq
<LI><a href="#[4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcFindInfoReq
</UL>

<P><STRONG><a name="[35f]"></a>attsErrRsp</STRONG> (Thumb, 68 bytes, Stack size 32 bytes, atts_main.o(i.attsErrRsp))
<BR><BR>[Stack]<UL><LI>Max Depth = 312<LI>Call Chain = attsErrRsp &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attMsgAlloc
<LI><a href="#[1dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cDataReq
</UL>
<BR>[Called By]<UL><LI><a href="#[35e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsCheckPendDbHashReadRsp
<LI><a href="#[b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcWrite
<LI><a href="#[6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadTypeReq
<LI><a href="#[7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadReq
<LI><a href="#[9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadMultReq
<LI><a href="#[a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadGroupTypeReq
<LI><a href="#[8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadBlobReq
<LI><a href="#[c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcPrepWriteReq
<LI><a href="#[5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcFindTypeReq
<LI><a href="#[4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcFindInfoReq
<LI><a href="#[d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcExecWriteReq
<LI><a href="#[b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsDataCback
</UL>

<P><STRONG><a name="[1ef]"></a>attsFindByHandle</STRONG> (Thumb, 48 bytes, Stack size 8 bytes, atts_proc.o(i.attsFindByHandle))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = attsFindByHandle
</UL>
<BR>[Called By]<UL><LI><a href="#[1ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsGetAttr
<LI><a href="#[1f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsSetAttr
<LI><a href="#[35e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsCheckPendDbHashReadRsp
<LI><a href="#[364]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsExecPrepWrite
<LI><a href="#[b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcWrite
<LI><a href="#[7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadReq
<LI><a href="#[9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadMultReq
<LI><a href="#[8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadBlobReq
<LI><a href="#[c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcPrepWriteReq
<LI><a href="#[d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcExecWriteReq
</UL>

<P><STRONG><a name="[36f]"></a>attsFindInRange</STRONG> (Thumb, 64 bytes, Stack size 12 bytes, atts_proc.o(i.attsFindInRange))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = attsFindInRange
</UL>
<BR>[Called By]<UL><LI><a href="#[4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcFindInfoReq
</UL>

<P><STRONG><a name="[365]"></a>attsFindServiceGroupEnd</STRONG> (Thumb, 132 bytes, Stack size 32 bytes, atts_read.o(i.attsFindServiceGroupEnd))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = attsFindServiceGroupEnd &rArr; attsUuidCmp &rArr; attUuidCmp16to128 &rArr; memcmp
</UL>
<BR>[Calls]<UL><LI><a href="#[366]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsUuidCmp
</UL>
<BR>[Called By]<UL><LI><a href="#[a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadGroupTypeReq
<LI><a href="#[5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcFindTypeReq
</UL>

<P><STRONG><a name="[367]"></a>attsFindUuidInRange</STRONG> (Thumb, 126 bytes, Stack size 32 bytes, atts_read.o(i.attsFindUuidInRange))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = attsFindUuidInRange &rArr; attsUuidCmp &rArr; attUuidCmp16to128 &rArr; memcmp
</UL>
<BR>[Calls]<UL><LI><a href="#[366]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsUuidCmp
</UL>
<BR>[Called By]<UL><LI><a href="#[6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadTypeReq
<LI><a href="#[a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadGroupTypeReq
<LI><a href="#[5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcFindTypeReq
<LI><a href="#[36d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcessDatabaseHashUpdate
</UL>

<P><STRONG><a name="[1e7]"></a>attsIsHashableAttr</STRONG> (Thumb, 150 bytes, Stack size 8 bytes, atts_main.o(i.attsIsHashableAttr))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = attsIsHashableAttr
</UL>
<BR>[Called By]<UL><LI><a href="#[1e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsCalculateDbHash
</UL>

<P><STRONG><a name="[36e]"></a>attsPermissions</STRONG> (Thumb, 118 bytes, Stack size 24 bytes, atts_proc.o(i.attsPermissions))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = attsPermissions
</UL>
<BR>[Calls]<UL><LI><a href="#[17f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnSecLevel
</UL>
<BR>[Called By]<UL><LI><a href="#[b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcWrite
<LI><a href="#[6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadTypeReq
<LI><a href="#[7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadReq
<LI><a href="#[9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadMultReq
<LI><a href="#[a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadGroupTypeReq
<LI><a href="#[8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadBlobReq
<LI><a href="#[c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcPrepWriteReq
</UL>

<P><STRONG><a name="[d]"></a>attsProcExecWriteReq</STRONG> (Thumb, 214 bytes, Stack size 40 bytes, atts_write.o(i.attsProcExecWriteReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 352<LI>Call Chain = attsProcExecWriteReq &rArr; attsErrRsp &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[2da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfQueueDeq
<LI><a href="#[168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufFree
<LI><a href="#[1d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attMsgAlloc
<LI><a href="#[1dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cDataReq
<LI><a href="#[364]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsExecPrepWrite
<LI><a href="#[1ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsFindByHandle
<LI><a href="#[35f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsErrRsp
<LI><a href="#[360]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsClearPrepWrites
</UL>
<BR>[Address Reference Count : 1]<UL><LI> atts_main.o(.data)
</UL>
<P><STRONG><a name="[4]"></a>attsProcFindInfoReq</STRONG> (Thumb, 312 bytes, Stack size 40 bytes, atts_proc.o(i.attsProcFindInfoReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 352<LI>Call Chain = attsProcFindInfoReq &rArr; attsErrRsp &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgFree
<LI><a href="#[1d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attMsgAlloc
<LI><a href="#[1dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cDataReq
<LI><a href="#[36f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsFindInRange
<LI><a href="#[35f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsErrRsp
<LI><a href="#[362]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsDiscBusy
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Address Reference Count : 1]<UL><LI> atts_main.o(.data)
</UL>
<P><STRONG><a name="[5]"></a>attsProcFindTypeReq</STRONG> (Thumb, 344 bytes, Stack size 64 bytes, atts_read.o(i.attsProcFindTypeReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 376<LI>Call Chain = attsProcFindTypeReq &rArr; attsErrRsp &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgFree
<LI><a href="#[1d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attMsgAlloc
<LI><a href="#[1dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cDataReq
<LI><a href="#[365]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsFindServiceGroupEnd
<LI><a href="#[367]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsFindUuidInRange
<LI><a href="#[35f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsErrRsp
<LI><a href="#[362]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsDiscBusy
<LI><a href="#[15c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
</UL>
<BR>[Address Reference Count : 1]<UL><LI> atts_main.o(.data)
</UL>
<P><STRONG><a name="[3]"></a>attsProcMtuReq</STRONG> (Thumb, 124 bytes, Stack size 32 bytes, atts_proc.o(i.attsProcMtuReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 312<LI>Call Chain = attsProcMtuReq &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciGetMaxRxAclLen
<LI><a href="#[34a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attSetMtu
<LI><a href="#[1d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attMsgAlloc
<LI><a href="#[1dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cDataReq
</UL>
<BR>[Address Reference Count : 1]<UL><LI> atts_main.o(.data)
</UL>
<P><STRONG><a name="[c]"></a>attsProcPrepWriteReq</STRONG> (Thumb, 356 bytes, Stack size 72 bytes, atts_write.o(i.attsProcPrepWriteReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 384<LI>Call Chain = attsProcPrepWriteReq &rArr; attsErrRsp &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[2e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfQueueCount
<LI><a href="#[2db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfQueueEnq
<LI><a href="#[16d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufAlloc
<LI><a href="#[1d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attMsgAlloc
<LI><a href="#[1dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cDataReq
<LI><a href="#[36e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsPermissions
<LI><a href="#[1ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsFindByHandle
<LI><a href="#[35f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsErrRsp
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Address Reference Count : 1]<UL><LI> atts_main.o(.data)
</UL>
<P><STRONG><a name="[8]"></a>attsProcReadBlobReq</STRONG> (Thumb, 266 bytes, Stack size 48 bytes, atts_read.o(i.attsProcReadBlobReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 360<LI>Call Chain = attsProcReadBlobReq &rArr; attsErrRsp &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attMsgAlloc
<LI><a href="#[1dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cDataReq
<LI><a href="#[36e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsPermissions
<LI><a href="#[1ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsFindByHandle
<LI><a href="#[35f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsErrRsp
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Address Reference Count : 1]<UL><LI> atts_main.o(.data)
</UL>
<P><STRONG><a name="[a]"></a>attsProcReadGroupTypeReq</STRONG> (Thumb, 480 bytes, Stack size 80 bytes, atts_read.o(i.attsProcReadGroupTypeReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 392<LI>Call Chain = attsProcReadGroupTypeReq &rArr; attsErrRsp &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attMsgAlloc
<LI><a href="#[1dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cDataReq
<LI><a href="#[365]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsFindServiceGroupEnd
<LI><a href="#[370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsUuid16Cmp
<LI><a href="#[36e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsPermissions
<LI><a href="#[367]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsFindUuidInRange
<LI><a href="#[35f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsErrRsp
<LI><a href="#[362]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsDiscBusy
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Address Reference Count : 1]<UL><LI> atts_main.o(.data)
</UL>
<P><STRONG><a name="[9]"></a>attsProcReadMultReq</STRONG> (Thumb, 308 bytes, Stack size 64 bytes, atts_read.o(i.attsProcReadMultReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 376<LI>Call Chain = attsProcReadMultReq &rArr; attsErrRsp &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgFree
<LI><a href="#[1d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attMsgAlloc
<LI><a href="#[1dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cDataReq
<LI><a href="#[36e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsPermissions
<LI><a href="#[1ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsFindByHandle
<LI><a href="#[35f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsErrRsp
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Address Reference Count : 1]<UL><LI> atts_main.o(.data)
</UL>
<P><STRONG><a name="[7]"></a>attsProcReadReq</STRONG> (Thumb, 236 bytes, Stack size 48 bytes, atts_proc.o(i.attsProcReadReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 360<LI>Call Chain = attsProcReadReq &rArr; attsErrRsp &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attMsgAlloc
<LI><a href="#[1dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cDataReq
<LI><a href="#[36e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsPermissions
<LI><a href="#[1ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsFindByHandle
<LI><a href="#[35f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsErrRsp
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Address Reference Count : 1]<UL><LI> atts_main.o(.data)
</UL>
<P><STRONG><a name="[6]"></a>attsProcReadTypeReq</STRONG> (Thumb, 634 bytes, Stack size 80 bytes, atts_read.o(i.attsProcReadTypeReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 392<LI>Call Chain = attsProcReadTypeReq &rArr; attsErrRsp &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[16d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufAlloc
<LI><a href="#[371]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsCsfGetHashUpdateStatus
<LI><a href="#[1d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attMsgAlloc
<LI><a href="#[1dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cDataReq
<LI><a href="#[36e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsPermissions
<LI><a href="#[367]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsFindUuidInRange
<LI><a href="#[35f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsErrRsp
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
<LI><a href="#[15c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
</UL>
<BR>[Address Reference Count : 1]<UL><LI> atts_main.o(.data)
</UL>
<P><STRONG><a name="[e]"></a>attsProcValueCnf</STRONG> (Thumb, 64 bytes, Stack size 24 bytes, atts_ind.o(i.attsProcValueCnf))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = attsProcValueCnf &rArr; attsExecCallback &rArr; attExecCallback
</UL>
<BR>[Calls]<UL><LI><a href="#[263]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStop
<LI><a href="#[368]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsIndCcbByConnId
<LI><a href="#[363]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsExecCallback
</UL>
<BR>[Address Reference Count : 1]<UL><LI> atts_main.o(.data)
</UL>
<P><STRONG><a name="[b]"></a>attsProcWrite</STRONG> (Thumb, 312 bytes, Stack size 72 bytes, atts_write.o(i.attsProcWrite))
<BR><BR>[Stack]<UL><LI>Max Depth = 384<LI>Call Chain = attsProcWrite &rArr; attsErrRsp &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attMsgAlloc
<LI><a href="#[1dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cDataReq
<LI><a href="#[36e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsPermissions
<LI><a href="#[1ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsFindByHandle
<LI><a href="#[35f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsErrRsp
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Address Reference Count : 1]<UL><LI> atts_main.o(.data)
</UL>
<P><STRONG><a name="[36d]"></a>attsProcessDatabaseHashUpdate</STRONG> (Thumb, 114 bytes, Stack size 48 bytes, atts_main.o(i.attsProcessDatabaseHashUpdate))
<BR><BR>[Stack]<UL><LI>Max Depth = 400<LI>Call Chain = attsProcessDatabaseHashUpdate &rArr; attsCsfSetHashUpdateStatus &rArr; attsCheckPendDbHashReadRsp &rArr; attsErrRsp &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufFree
<LI><a href="#[1f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsSetAttr
<LI><a href="#[1e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsCsfSetHashUpdateStatus
<LI><a href="#[367]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsFindUuidInRange
</UL>
<BR>[Called By]<UL><LI><a href="#[b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsMsgCback
</UL>

<P><STRONG><a name="[370]"></a>attsUuid16Cmp</STRONG> (Thumb, 46 bytes, Stack size 16 bytes, atts_proc.o(i.attsUuid16Cmp))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = attsUuid16Cmp &rArr; attUuidCmp16to128 &rArr; memcmp
</UL>
<BR>[Calls]<UL><LI><a href="#[34b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attUuidCmp16to128
</UL>
<BR>[Called By]<UL><LI><a href="#[a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcReadGroupTypeReq
</UL>

<P><STRONG><a name="[366]"></a>attsUuidCmp</STRONG> (Thumb, 84 bytes, Stack size 16 bytes, atts_proc.o(i.attsUuidCmp))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = attsUuidCmp &rArr; attUuidCmp16to128 &rArr; memcmp
</UL>
<BR>[Calls]<UL><LI><a href="#[34b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attUuidCmp16to128
<LI><a href="#[15c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
</UL>
<BR>[Called By]<UL><LI><a href="#[365]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsFindServiceGroupEnd
<LI><a href="#[367]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsFindUuidInRange
</UL>

<P><STRONG><a name="[68]"></a>button_handler</STRONG> (Thumb, 100 bytes, Stack size 16 bytes, radio_task.o(i.button_handler))
<BR><BR>[Stack]<UL><LI>Max Depth = 308<LI>Call Chain = button_handler &rArr; am_util_stdio_printf &rArr; am_util_stdio_vsprintf &rArr; ftoa &rArr; uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[260]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStartMs
<LI><a href="#[265]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_printf
<LI><a href="#[382]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppUiBtnTest
<LI><a href="#[2ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_button_array_tick
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio_task.o(i.exactle_stack_init)
</UL>
<P><STRONG><a name="[be]"></a>dmAdvActClearSets</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, dm_adv_leg.o(i.dmAdvActClearSets))
<BR>[Address Reference Count : 1]<UL><LI> dm_adv_leg.o(.constdata)
</UL>
<P><STRONG><a name="[b9]"></a>dmAdvActConfig</STRONG> (Thumb, 42 bytes, Stack size 8 bytes, dm_adv_leg.o(i.dmAdvActConfig))
<BR><BR>[Stack]<UL><LI>Max Depth = 280<LI>Call Chain = dmAdvActConfig &rArr; dmAdvConfig &rArr; HciLeSetAdvParamCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvConfig
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_adv_leg.o(.constdata)
</UL>
<P><STRONG><a name="[bd]"></a>dmAdvActRemoveSet</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, dm_adv_leg.o(i.dmAdvActRemoveSet))
<BR>[Address Reference Count : 1]<UL><LI> dm_adv_leg.o(.constdata)
</UL>
<P><STRONG><a name="[ba]"></a>dmAdvActSetData</STRONG> (Thumb, 38 bytes, Stack size 8 bytes, dm_adv_leg.o(i.dmAdvActSetData))
<BR><BR>[Stack]<UL><LI>Max Depth = 224<LI>Call Chain = dmAdvActSetData &rArr; HciLeSetScanRespDataCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[291]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetScanRespDataCmd
<LI><a href="#[288]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetAdvDataCmd
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_adv_leg.o(.constdata)
</UL>
<P><STRONG><a name="[bf]"></a>dmAdvActSetRandAddr</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, dm_adv_leg.o(i.dmAdvActSetRandAddr))
<BR>[Address Reference Count : 1]<UL><LI> dm_adv_leg.o(.constdata)
</UL>
<P><STRONG><a name="[bb]"></a>dmAdvActStart</STRONG> (Thumb, 48 bytes, Stack size 8 bytes, dm_adv_leg.o(i.dmAdvActStart))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = dmAdvActStart &rArr; HciLeSetAdvEnableCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[289]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetAdvEnableCmd
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_adv_leg.o(.constdata)
</UL>
<P><STRONG><a name="[bc]"></a>dmAdvActStop</STRONG> (Thumb, 46 bytes, Stack size 8 bytes, dm_adv_leg.o(i.dmAdvActStop))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = dmAdvActStop &rArr; HciLeSetAdvEnableCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[289]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetAdvEnableCmd
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_adv_leg.o(.constdata)
</UL>
<P><STRONG><a name="[c0]"></a>dmAdvActTimeout</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, dm_adv_leg.o(i.dmAdvActTimeout))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = dmAdvActTimeout &rArr; HciLeSetAdvEnableCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[289]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetAdvEnableCmd
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_adv_leg.o(.constdata)
</UL>
<P><STRONG><a name="[38b]"></a>dmAdvCbInit</STRONG> (Thumb, 46 bytes, Stack size 0 bytes, dm_adv.o(i.dmAdvCbInit))
<BR><BR>[Called By]<UL><LI><a href="#[20b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvInit
</UL>

<P><STRONG><a name="[386]"></a>dmAdvConnectFailed</STRONG> (Thumb, 32 bytes, Stack size 8 bytes, dm_adv_leg.o(i.dmAdvConnectFailed))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = dmAdvConnectFailed &rArr; WsfTimerStop &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[263]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStop
<LI><a href="#[387]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmDevPassEvtToDevPriv
</UL>
<BR>[Called By]<UL><LI><a href="#[d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActAcceptFailed
</UL>

<P><STRONG><a name="[388]"></a>dmAdvConnected</STRONG> (Thumb, 32 bytes, Stack size 8 bytes, dm_adv_leg.o(i.dmAdvConnected))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = dmAdvConnected &rArr; WsfTimerStop &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[263]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStop
<LI><a href="#[387]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmDevPassEvtToDevPriv
</UL>
<BR>[Called By]<UL><LI><a href="#[d3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActConnAccepted
</UL>

<P><STRONG><a name="[389]"></a>dmAdvGenConnCmpl</STRONG> (Thumb, 74 bytes, Stack size 48 bytes, dm_adv.o(i.dmAdvGenConnCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = dmAdvGenConnCmpl &rArr; dmDevPassHciEvtToConn
</UL>
<BR>[Calls]<UL><LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCpy
<LI><a href="#[38a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmDevPassHciEvtToConn
<LI><a href="#[160]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Called By]<UL><LI><a href="#[c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvHciHandler
</UL>

<P><STRONG><a name="[c2]"></a>dmAdvHciHandler</STRONG> (Thumb, 212 bytes, Stack size 16 bytes, dm_adv_leg.o(i.dmAdvHciHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = dmAdvHciHandler &rArr; WsfTimerStartMs &rArr; wsfTimerInsert &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[263]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStop
<LI><a href="#[260]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStartMs
<LI><a href="#[389]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvGenConnCmpl
<LI><a href="#[387]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmDevPassEvtToDevPriv
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_adv_leg.o(.constdata)
</UL>
<P><STRONG><a name="[20b]"></a>dmAdvInit</STRONG> (Thumb, 36 bytes, Stack size 4 bytes, dm_adv.o(i.dmAdvInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = dmAdvInit
</UL>
<BR>[Calls]<UL><LI><a href="#[38b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvCbInit
</UL>
<BR>[Called By]<UL><LI><a href="#[c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvReset
<LI><a href="#[20a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmAdvInit
</UL>

<P><STRONG><a name="[c3]"></a>dmAdvMsgHandler</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, dm_adv_leg.o(i.dmAdvMsgHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = dmAdvMsgHandler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_adv_leg.o(.constdata)
</UL>
<P><STRONG><a name="[c1]"></a>dmAdvReset</STRONG> (Thumb, 58 bytes, Stack size 8 bytes, dm_adv_leg.o(i.dmAdvReset))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = dmAdvReset &rArr; WsfTimerStop &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[263]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStop
<LI><a href="#[20b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_adv_leg.o(.constdata)
</UL>
<P><STRONG><a name="[38c]"></a>dmAdvStartDirected</STRONG> (Thumb, 60 bytes, Stack size 24 bytes, dm_adv_leg.o(i.dmAdvStartDirected))
<BR><BR>[Stack]<UL><LI>Max Depth = 232<LI>Call Chain = dmAdvStartDirected &rArr; HciLeSetAdvEnableCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[289]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetAdvEnableCmd
<LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCpy
</UL>
<BR>[Called By]<UL><LI><a href="#[d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActAccept
</UL>

<P><STRONG><a name="[38d]"></a>dmAdvStopDirected</STRONG> (Thumb, 52 bytes, Stack size 8 bytes, dm_adv_leg.o(i.dmAdvStopDirected))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = dmAdvStopDirected &rArr; HciLeSetAdvEnableCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[289]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetAdvEnableCmd
</UL>
<BR>[Called By]<UL><LI><a href="#[d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActCancelAccept
</UL>

<P><STRONG><a name="[ce]"></a>dmConn2HciHandler</STRONG> (Thumb, 126 bytes, Stack size 16 bytes, dm_conn.o(i.dmConn2HciHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = dmConn2HciHandler &rArr; dmConn2ActRemoteConnParamReq
</UL>
<BR>[Calls]<UL><LI><a href="#[221]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnCcbByHandle
<LI><a href="#[391]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConn2ActWriteAuthToCmpl
<LI><a href="#[38e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConn2ActRssiRead
<LI><a href="#[38f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConn2ActRemoteConnParamReq
<LI><a href="#[394]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConn2ActReadRemoteVerInfoCmpl
<LI><a href="#[393]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConn2ActReadRemoteFeaturesCmpl
<LI><a href="#[390]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConn2ActDataLenChange
<LI><a href="#[392]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConn2ActAuthToExpired
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_conn.o(.constdata)
</UL>
<P><STRONG><a name="[cf]"></a>dmConn2MsgHandler</STRONG> (Thumb, 112 bytes, Stack size 32 bytes, dm_conn.o(i.dmConn2MsgHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 264<LI>Call Chain = dmConn2MsgHandler &rArr; HciLeRemoteConnParamReqReply &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[295]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciReadRssiCmd
<LI><a href="#[28c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetDataLen
<LI><a href="#[285]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeRemoteConnParamReqReply
<LI><a href="#[284]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeRemoteConnParamReqNegReply
<LI><a href="#[2a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciWriteAuthPayloadTimeout
<LI><a href="#[227]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnCcbById
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_conn.o(.constdata)
</UL>
<P><STRONG><a name="[395]"></a>dmConnCcbAlloc</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, dm_conn.o(i.dmConnCcbAlloc))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = dmConnCcbAlloc &rArr; __aeabi_memclr4
</UL>
<BR>[Calls]<UL><LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCpy
<LI><a href="#[160]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Called By]<UL><LI><a href="#[212]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnOpenAccept
<LI><a href="#[cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnHciHandler
</UL>

<P><STRONG><a name="[396]"></a>dmConnCcbByBdAddr</STRONG> (Thumb, 42 bytes, Stack size 16 bytes, dm_conn.o(i.dmConnCcbByBdAddr))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = dmConnCcbByBdAddr &rArr; BdaCmp &rArr; memcmp
</UL>
<BR>[Calls]<UL><LI><a href="#[15a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCmp
</UL>
<BR>[Called By]<UL><LI><a href="#[212]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnOpenAccept
<LI><a href="#[cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnHciHandler
</UL>

<P><STRONG><a name="[221]"></a>dmConnCcbByHandle</STRONG> (Thumb, 36 bytes, Stack size 0 bytes, dm_conn.o(i.dmConnCcbByHandle))
<BR><BR>[Called By]<UL><LI><a href="#[220]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmL2cConnUpdateCnf
<LI><a href="#[cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnHciHandler
<LI><a href="#[ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConn2HciHandler
<LI><a href="#[ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmSecHciHandler
</UL>

<P><STRONG><a name="[227]"></a>dmConnCcbById</STRONG> (Thumb, 34 bytes, Stack size 0 bytes, dm_conn.o(i.dmConnCcbById))
<BR><BR>[Called By]<UL><LI><a href="#[cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnMsgHandler
<LI><a href="#[cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConn2MsgHandler
<LI><a href="#[226]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmReadRemoteFeatures
<LI><a href="#[ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmSecMsgHandler
<LI><a href="#[41b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScCatResponderBdAddr
<LI><a href="#[41a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScCatInitiatorBdAddr
</UL>

<P><STRONG><a name="[398]"></a>dmConnCcbDealloc</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, dm_conn.o(i.dmConnCcbDealloc))
<BR><BR>[Called By]<UL><LI><a href="#[c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActConnFailed
<LI><a href="#[c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActConnClosed
<LI><a href="#[212]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnOpenAccept
</UL>

<P><STRONG><a name="[39b]"></a>dmConnExecCback</STRONG> (Thumb, 36 bytes, Stack size 16 bytes, dm_conn.o(i.dmConnExecCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = dmConnExecCback
</UL>
<BR>[Called By]<UL><LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActConnOpened
<LI><a href="#[c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActConnFailed
<LI><a href="#[c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActConnClosed
</UL>

<P><STRONG><a name="[cb]"></a>dmConnHciHandler</STRONG> (Thumb, 102 bytes, Stack size 16 bytes, dm_conn.o(i.dmConnHciHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = dmConnHciHandler &rArr; dmConnCcbByBdAddr &rArr; BdaCmp &rArr; memcmp
</UL>
<BR>[Calls]<UL><LI><a href="#[222]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmExecute
<LI><a href="#[221]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnCcbByHandle
<LI><a href="#[396]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnCcbByBdAddr
<LI><a href="#[395]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnCcbAlloc
<LI><a href="#[397]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnCmplStates
</UL>
<BR>[Called By]<UL><LI><a href="#[ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnReset
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_conn.o(.constdata)
</UL>
<P><STRONG><a name="[cc]"></a>dmConnMsgHandler</STRONG> (Thumb, 24 bytes, Stack size 16 bytes, dm_conn.o(i.dmConnMsgHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = dmConnMsgHandler &rArr; dmConnSmExecute
</UL>
<BR>[Calls]<UL><LI><a href="#[222]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmExecute
<LI><a href="#[227]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnCcbById
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_conn.o(.constdata)
</UL>
<P><STRONG><a name="[39a]"></a>dmConnNum</STRONG> (Thumb, 28 bytes, Stack size 0 bytes, dm_conn.o(i.dmConnNum))
<BR><BR>[Called By]<UL><LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActConnOpened
<LI><a href="#[c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActConnFailed
<LI><a href="#[c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActConnClosed
</UL>

<P><STRONG><a name="[212]"></a>dmConnOpenAccept</STRONG> (Thumb, 156 bytes, Stack size 40 bytes, dm_conn.o(i.dmConnOpenAccept))
<BR><BR>[Stack]<UL><LI>Max Depth = 192<LI>Call Chain = dmConnOpenAccept &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCpy
<LI><a href="#[1e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskUnlock
<LI><a href="#[1e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskLock
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
<LI><a href="#[398]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnCcbDealloc
<LI><a href="#[396]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnCcbByBdAddr
<LI><a href="#[395]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnCcbAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[211]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnAccept
</UL>

<P><STRONG><a name="[ca]"></a>dmConnReset</STRONG> (Thumb, 122 bytes, Stack size 24 bytes, dm_conn.o(i.dmConnReset))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = dmConnReset &rArr; dmConnHciHandler &rArr; dmConnCcbByBdAddr &rArr; BdaCmp &rArr; memcmp
</UL>
<BR>[Calls]<UL><LI><a href="#[cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnHciHandler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_conn.o(.constdata)
</UL>
<P><STRONG><a name="[d0]"></a>dmConnSmActAccept</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, dm_conn_slave_leg.o(i.dmConnSmActAccept))
<BR><BR>[Stack]<UL><LI>Max Depth = 248<LI>Call Chain = dmConnSmActAccept &rArr; dmAdvStartDirected &rArr; HciLeSetAdvEnableCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[38c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvStartDirected
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_conn_slave_leg.o(.constdata)
</UL>
<P><STRONG><a name="[d4]"></a>dmConnSmActAcceptFailed</STRONG> (Thumb, 20 bytes, Stack size 16 bytes, dm_conn_slave_leg.o(i.dmConnSmActAcceptFailed))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = dmConnSmActAcceptFailed &rArr; dmConnSmActConnFailed &rArr; dmDevPassEvtToDevPriv
</UL>
<BR>[Calls]<UL><LI><a href="#[c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActConnFailed
<LI><a href="#[386]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvConnectFailed
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_conn_slave_leg.o(.constdata)
</UL>
<P><STRONG><a name="[d1]"></a>dmConnSmActCancelAccept</STRONG> (Thumb, 20 bytes, Stack size 16 bytes, dm_conn_slave_leg.o(i.dmConnSmActCancelAccept))
<BR><BR>[Stack]<UL><LI>Max Depth = 232<LI>Call Chain = dmConnSmActCancelAccept &rArr; dmAdvStopDirected &rArr; HciLeSetAdvEnableCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActConnFailed
<LI><a href="#[38d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvStopDirected
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_conn_slave_leg.o(.constdata)
</UL>
<P><STRONG><a name="[c5]"></a>dmConnSmActClose</STRONG> (Thumb, 16 bytes, Stack size 16 bytes, dm_conn.o(i.dmConnSmActClose))
<BR><BR>[Stack]<UL><LI>Max Depth = 232<LI>Call Chain = dmConnSmActClose &rArr; HciDisconnectCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[25a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDisconnectCmd
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_conn.o(.constdata)
</UL>
<P><STRONG><a name="[d3]"></a>dmConnSmActConnAccepted</STRONG> (Thumb, 20 bytes, Stack size 16 bytes, dm_conn_slave_leg.o(i.dmConnSmActConnAccepted))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = dmConnSmActConnAccepted &rArr; dmConnSmActConnOpened &rArr; dmDevPassEvtToDevPriv
</UL>
<BR>[Calls]<UL><LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActConnOpened
<LI><a href="#[388]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvConnected
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_conn_slave_leg.o(.constdata)
</UL>
<P><STRONG><a name="[c8]"></a>dmConnSmActConnClosed</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, dm_conn.o(i.dmConnSmActConnClosed))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = dmConnSmActConnClosed &rArr; dmDevPassEvtToDevPriv
</UL>
<BR>[Calls]<UL><LI><a href="#[399]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmDevPassEvtToConnCte
<LI><a href="#[39a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnNum
<LI><a href="#[39b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnExecCback
<LI><a href="#[398]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnCcbDealloc
<LI><a href="#[387]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmDevPassEvtToDevPriv
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_conn.o(.constdata)
</UL>
<P><STRONG><a name="[c7]"></a>dmConnSmActConnFailed</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, dm_conn.o(i.dmConnSmActConnFailed))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = dmConnSmActConnFailed &rArr; dmDevPassEvtToDevPriv
</UL>
<BR>[Calls]<UL><LI><a href="#[39a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnNum
<LI><a href="#[39b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnExecCback
<LI><a href="#[398]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnCcbDealloc
<LI><a href="#[387]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmDevPassEvtToDevPriv
</UL>
<BR>[Called By]<UL><LI><a href="#[d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActCancelAccept
<LI><a href="#[d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActAcceptFailed
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_conn.o(.constdata)
</UL>
<P><STRONG><a name="[c6]"></a>dmConnSmActConnOpened</STRONG> (Thumb, 162 bytes, Stack size 16 bytes, dm_conn.o(i.dmConnSmActConnOpened))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = dmConnSmActConnOpened &rArr; dmDevPassEvtToDevPriv
</UL>
<BR>[Calls]<UL><LI><a href="#[39c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciGetBdAddr
<LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCpy
<LI><a href="#[399]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmDevPassEvtToConnCte
<LI><a href="#[159]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmHostAddrType
<LI><a href="#[39a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnNum
<LI><a href="#[39b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnExecCback
<LI><a href="#[387]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmDevPassEvtToDevPriv
</UL>
<BR>[Called By]<UL><LI><a href="#[d3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActConnAccepted
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_conn.o(.constdata)
</UL>
<P><STRONG><a name="[c9]"></a>dmConnSmActHciUpdated</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, dm_conn.o(i.dmConnSmActHciUpdated))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = dmConnSmActHciUpdated
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_conn.o(.constdata)
</UL>
<P><STRONG><a name="[d5]"></a>dmConnSmActL2cUpdateCnf</STRONG> (Thumb, 28 bytes, Stack size 16 bytes, dm_conn_slave.o(i.dmConnSmActL2cUpdateCnf))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = dmConnSmActL2cUpdateCnf &rArr; dmConnUpdateCback
</UL>
<BR>[Calls]<UL><LI><a href="#[39d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnUpdateCback
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_conn_slave_leg.o(.constdata)
</UL>
<P><STRONG><a name="[c4]"></a>dmConnSmActNone</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, dm_conn.o(i.dmConnSmActNone))
<BR><BR>[Called By]<UL><LI><a href="#[222]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmExecute
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_conn.o(.constdata)
</UL>
<P><STRONG><a name="[d2]"></a>dmConnSmActUpdateSlave</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, dm_conn_slave.o(i.dmConnSmActUpdateSlave))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = dmConnSmActUpdateSlave &rArr; L2cDmConnUpdateReq &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[279]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeConnUpdateCmd
<LI><a href="#[39e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciGetLeSupFeat
<LI><a href="#[2a3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cDmConnUpdateReq
<LI><a href="#[39d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnUpdateCback
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_conn_slave_leg.o(.constdata)
</UL>
<P><STRONG><a name="[222]"></a>dmConnSmExecute</STRONG> (Thumb, 96 bytes, Stack size 24 bytes, dm_conn_sm.o(i.dmConnSmExecute))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = dmConnSmExecute
</UL>
<BR>[Calls]<UL><LI><a href="#[c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActNone
</UL>
<BR>[Called By]<UL><LI><a href="#[220]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmL2cConnUpdateCnf
<LI><a href="#[cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnMsgHandler
<LI><a href="#[cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnHciHandler
</UL>

<P><STRONG><a name="[d6]"></a>dmDevActReset</STRONG> (Thumb, 44 bytes, Stack size 16 bytes, dm_dev.o(i.dmDevActReset))
<BR><BR>[Stack]<UL><LI>Max Depth = 304<LI>Call Chain = dmDevActReset &rArr; HciResetSequence &rArr; hciCoreTxReady &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[297]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciResetSequence
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_dev.o(.constdata)
</UL>
<P><STRONG><a name="[d7]"></a>dmDevHciHandler</STRONG> (Thumb, 48 bytes, Stack size 8 bytes, dm_dev.o(i.dmDevHciHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = dmDevHciHandler &rArr; dmDevHciEvtVendorSpec
</UL>
<BR>[Calls]<UL><LI><a href="#[3a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmDevHciEvtVendorSpec
<LI><a href="#[39f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmDevHciEvtReset
<LI><a href="#[3a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmDevHciEvtHwError
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_dev.o(.constdata)
</UL>
<P><STRONG><a name="[d8]"></a>dmDevMsgHandler</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, dm_dev.o(i.dmDevMsgHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = dmDevMsgHandler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_dev.o(.constdata)
</UL>
<P><STRONG><a name="[399]"></a>dmDevPassEvtToConnCte</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, dm_dev.o(i.dmDevPassEvtToConnCte))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = dmDevPassEvtToConnCte
</UL>
<BR>[Called By]<UL><LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActConnOpened
<LI><a href="#[c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActConnClosed
</UL>

<P><STRONG><a name="[387]"></a>dmDevPassEvtToDevPriv</STRONG> (Thumb, 42 bytes, Stack size 32 bytes, dm_dev.o(i.dmDevPassEvtToDevPriv))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = dmDevPassEvtToDevPriv
</UL>
<BR>[Called By]<UL><LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActConnOpened
<LI><a href="#[c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActConnFailed
<LI><a href="#[c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActConnClosed
<LI><a href="#[c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvHciHandler
<LI><a href="#[388]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvConnected
<LI><a href="#[386]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvConnectFailed
<LI><a href="#[ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmScanHciHandler
<LI><a href="#[e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmPrivHciHandler
</UL>

<P><STRONG><a name="[38a]"></a>dmDevPassHciEvtToConn</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, dm_main.o(i.dmDevPassHciEvtToConn))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = dmDevPassHciEvtToConn
</UL>
<BR>[Called By]<UL><LI><a href="#[389]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvGenConnCmpl
</UL>

<P><STRONG><a name="[218]"></a>dmDevSetFilterPolicy</STRONG> (Thumb, 100 bytes, Stack size 12 bytes, dm_dev.o(i.dmDevSetFilterPolicy))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = dmDevSetFilterPolicy
</UL>
<BR>[Called By]<UL><LI><a href="#[217]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmDevSetFilterPolicy
</UL>

<P><STRONG><a name="[d9]"></a>dmEmptyHandler</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, dm_main.o(i.dmEmptyHandler))
<BR>[Address Reference Count : 2]<UL><LI> dm_main.o(.constdata)
<LI> dm_sec_lesc.o(.constdata)
</UL>
<P><STRONG><a name="[cd]"></a>dmEmptyReset</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, dm_main.o(i.dmEmptyReset))
<BR>[Address Reference Count : 4]<UL><LI> dm_conn.o(.constdata)
<LI> dm_dev.o(.constdata)
<LI> dm_main.o(.constdata)
<LI> dm_sec_lesc.o(.constdata)
</UL>
<P><STRONG><a name="[dc]"></a>dmPrivActAddDevToResList</STRONG> (Thumb, 36 bytes, Stack size 16 bytes, dm_priv.o(i.dmPrivActAddDevToResList))
<BR><BR>[Stack]<UL><LI>Max Depth = 240<LI>Call Chain = dmPrivActAddDevToResList &rArr; HciLeAddDeviceToResolvingListCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[277]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeAddDeviceToResolvingListCmd
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_priv.o(.constdata)
</UL>
<P><STRONG><a name="[de]"></a>dmPrivActClearResList</STRONG> (Thumb, 10 bytes, Stack size 8 bytes, dm_priv.o(i.dmPrivActClearResList))
<BR><BR>[Stack]<UL><LI>Max Depth = 208<LI>Call Chain = dmPrivActClearResList &rArr; HciLeClearResolvingList &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeClearResolvingList
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_priv.o(.constdata)
</UL>
<P><STRONG><a name="[e1]"></a>dmPrivActGenAddr</STRONG> (Thumb, 98 bytes, Stack size 16 bytes, dm_priv.o(i.dmPrivActGenAddr))
<BR><BR>[Stack]<UL><LI>Max Depth = 264<LI>Call Chain = dmPrivActGenAddr &rArr; SecAes &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[18d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecRand
<LI><a href="#[2ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecAes
<LI><a href="#[1d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_priv.o(.constdata)
</UL>
<P><STRONG><a name="[e2]"></a>dmPrivActGenAddrAesCmpl</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, dm_priv.o(i.dmPrivActGenAddrAesCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = dmPrivActGenAddrAesCmpl
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_priv.o(.constdata)
</UL>
<P><STRONG><a name="[dd]"></a>dmPrivActRemDevFromResList</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, dm_priv.o(i.dmPrivActRemDevFromResList))
<BR><BR>[Stack]<UL><LI>Max Depth = 232<LI>Call Chain = dmPrivActRemDevFromResList &rArr; HciLeRemoveDeviceFromResolvingList &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[286]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeRemoveDeviceFromResolvingList
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_priv.o(.constdata)
</UL>
<P><STRONG><a name="[db]"></a>dmPrivActResAddrAesCmpl</STRONG> (Thumb, 52 bytes, Stack size 8 bytes, dm_priv.o(i.dmPrivActResAddrAesCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = dmPrivActResAddrAesCmpl &rArr; memcmp
</UL>
<BR>[Calls]<UL><LI><a href="#[15c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_priv.o(.constdata)
</UL>
<P><STRONG><a name="[da]"></a>dmPrivActResolveAddr</STRONG> (Thumb, 102 bytes, Stack size 32 bytes, dm_priv.o(i.dmPrivActResolveAddr))
<BR><BR>[Stack]<UL><LI>Max Depth = 280<LI>Call Chain = dmPrivActResolveAddr &rArr; SecAes &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[2ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecAes
<LI><a href="#[1d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_priv.o(.constdata)
</UL>
<P><STRONG><a name="[df]"></a>dmPrivActSetAddrResEnable</STRONG> (Thumb, 14 bytes, Stack size 16 bytes, dm_priv.o(i.dmPrivActSetAddrResEnable))
<BR><BR>[Stack]<UL><LI>Max Depth = 232<LI>Call Chain = dmPrivActSetAddrResEnable &rArr; dmPrivSetAddrResEnable &rArr; HciLeSetAddrResolutionEnable &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[3a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmPrivSetAddrResEnable
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_priv.o(.constdata)
</UL>
<P><STRONG><a name="[e0]"></a>dmPrivActSetPrivacyMode</STRONG> (Thumb, 18 bytes, Stack size 16 bytes, dm_priv.o(i.dmPrivActSetPrivacyMode))
<BR><BR>[Stack]<UL><LI>Max Depth = 232<LI>Call Chain = dmPrivActSetPrivacyMode &rArr; HciLeSetPrivacyModeCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[28e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetPrivacyModeCmd
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_priv.o(.constdata)
</UL>
<P><STRONG><a name="[e4]"></a>dmPrivHciHandler</STRONG> (Thumb, 172 bytes, Stack size 8 bytes, dm_priv.o(i.dmPrivHciHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 224<LI>Call Chain = dmPrivHciHandler &rArr; dmPrivSetAddrResEnable &rArr; HciLeSetAddrResolutionEnable &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[387]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmDevPassEvtToDevPriv
<LI><a href="#[3a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmPrivSetAddrResEnable
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_priv.o(.constdata)
</UL>
<P><STRONG><a name="[e5]"></a>dmPrivMsgHandler</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, dm_priv.o(i.dmPrivMsgHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = dmPrivMsgHandler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_priv.o(.constdata)
</UL>
<P><STRONG><a name="[e3]"></a>dmPrivReset</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, dm_priv.o(i.dmPrivReset))
<BR>[Address Reference Count : 1]<UL><LI> dm_priv.o(.constdata)
</UL>
<P><STRONG><a name="[e6]"></a>dmScanActStart</STRONG> (Thumb, 112 bytes, Stack size 24 bytes, dm_scan_leg.o(i.dmScanActStart))
<BR><BR>[Stack]<UL><LI>Max Depth = 248<LI>Call Chain = dmScanActStart &rArr; HciLeSetScanParamCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[290]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetScanParamCmd
<LI><a href="#[28f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetScanEnableCmd
<LI><a href="#[22d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmScanPhyToIdx
<LI><a href="#[385]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmLlAddrType
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_scan_leg.o(.constdata)
</UL>
<P><STRONG><a name="[e7]"></a>dmScanActStop</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, dm_scan_leg.o(i.dmScanActStop))
<BR><BR>[Stack]<UL><LI>Max Depth = 224<LI>Call Chain = dmScanActStop &rArr; HciLeSetScanEnableCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[28f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetScanEnableCmd
</UL>
<BR>[Called By]<UL><LI><a href="#[e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmScanActTimeout
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_scan_leg.o(.constdata)
</UL>
<P><STRONG><a name="[e8]"></a>dmScanActTimeout</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, dm_scan_leg.o(i.dmScanActTimeout))
<BR><BR>[Stack]<UL><LI>Max Depth = 232<LI>Call Chain = dmScanActTimeout &rArr; dmScanActStop &rArr; HciLeSetScanEnableCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmScanActStop
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_scan_leg.o(.constdata)
</UL>
<P><STRONG><a name="[ea]"></a>dmScanHciHandler</STRONG> (Thumb, 148 bytes, Stack size 8 bytes, dm_scan_leg.o(i.dmScanHciHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = dmScanHciHandler &rArr; WsfTimerStartMs &rArr; wsfTimerInsert &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[263]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStop
<LI><a href="#[260]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStartMs
<LI><a href="#[387]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmDevPassEvtToDevPriv
<LI><a href="#[3a3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmScanActHciReport
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_scan_leg.o(.constdata)
</UL>
<P><STRONG><a name="[22c]"></a>dmScanInit</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, dm_scan.o(i.dmScanInit))
<BR><BR>[Called By]<UL><LI><a href="#[e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmScanReset
<LI><a href="#[22b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmScanInit
</UL>

<P><STRONG><a name="[eb]"></a>dmScanMsgHandler</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, dm_scan_leg.o(i.dmScanMsgHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = dmScanMsgHandler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_scan_leg.o(.constdata)
</UL>
<P><STRONG><a name="[e9]"></a>dmScanReset</STRONG> (Thumb, 56 bytes, Stack size 8 bytes, dm_scan_leg.o(i.dmScanReset))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = dmScanReset &rArr; WsfTimerStop &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[263]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStop
<LI><a href="#[22c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmScanInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_scan_leg.o(.constdata)
</UL>
<P><STRONG><a name="[ed]"></a>dmSecHciHandler</STRONG> (Thumb, 192 bytes, Stack size 32 bytes, dm_sec.o(i.dmSecHciHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 248<LI>Call Chain = dmSecHciHandler &rArr; HciLeLtkReqReplCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[27c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeLtkReqReplCmd
<LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnSetIdle
<LI><a href="#[221]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnCcbByHandle
<LI><a href="#[2c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpDmGetStk
<LI><a href="#[2c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpDmEncryptInd
<LI><a href="#[3a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSmpCbackExec
<LI><a href="#[15c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_sec.o(.constdata)
</UL>
<P><STRONG><a name="[ef]"></a>dmSecLescMsgHandler</STRONG> (Thumb, 92 bytes, Stack size 48 bytes, dm_sec_lesc.o(i.dmSecLescMsgHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = dmSecLescMsgHandler &rArr; WsfBufFree
</UL>
<BR>[Calls]<UL><LI><a href="#[168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufFree
<LI><a href="#[206]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Calc128Cpy
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_sec_lesc.o(.constdata)
</UL>
<P><STRONG><a name="[ee]"></a>dmSecMsgHandler</STRONG> (Thumb, 102 bytes, Stack size 16 bytes, dm_sec.o(i.dmSecMsgHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 240<LI>Call Chain = dmSecMsgHandler &rArr; HciLeStartEncryptionCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[292]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeStartEncryptionCmd
<LI><a href="#[27c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeLtkReqReplCmd
<LI><a href="#[27b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeLtkReqNegReplCmd
<LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnSetIdle
<LI><a href="#[227]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnCcbById
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_sec.o(.constdata)
</UL>
<P><STRONG><a name="[ec]"></a>dmSecReset</STRONG> (Thumb, 8 bytes, Stack size 8 bytes, dm_sec.o(i.dmSecReset))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = dmSecReset &rArr; SmpDbInit &rArr; WsfTimerStop &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpDbInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_sec.o(.constdata)
</UL>
<P><STRONG><a name="[431]"></a>eTaskConfirmSleepModeStatus</STRONG> (Thumb, 42 bytes, Stack size 0 bytes, tasks.o(i.eTaskConfirmSleepModeStatus))
<BR><BR>[Called By]<UL><LI><a href="#[3e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortSuppressTicksAndSleep
</UL>

<P><STRONG><a name="[3a5]"></a>enable_print_interface</STRONG> (Thumb, 8 bytes, Stack size 8 bytes, ble_freertos_beaconscanner.o(i.enable_print_interface))
<BR><BR>[Stack]<UL><LI>Max Depth = 112<LI>Call Chain = enable_print_interface &rArr; am_bsp_itm_printf_enable &rArr; am_hal_gpio_pinconfig
</UL>
<BR>[Calls]<UL><LI><a href="#[2f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_bsp_itm_printf_enable
</UL>
<BR>[Called By]<UL><LI><a href="#[135]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[2a9]"></a>exactle_stack_init</STRONG> (Thumb, 250 bytes, Stack size 16 bytes, radio_task.o(i.exactle_stack_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 308<LI>Call Chain = exactle_stack_init &rArr; am_util_stdio_printf &rArr; am_util_stdio_vsprintf &rArr; ftoa &rArr; uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[3b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciSetMaxRxAclLen
<LI><a href="#[2e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerInit
<LI><a href="#[3a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfOsSetNextHandler
<LI><a href="#[2de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfOsInit
<LI><a href="#[3a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufInit
<LI><a href="#[2b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecEccInit
<LI><a href="#[3b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcInit
<LI><a href="#[1c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttHandlerInit
<LI><a href="#[3b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsInit
<LI><a href="#[3b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsIndInit
<LI><a href="#[21e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmHandlerInit
<LI><a href="#[219]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmDevVsInit
<LI><a href="#[3ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnSlaveInit
<LI><a href="#[3aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnInit
<LI><a href="#[20a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmAdvInit
<LI><a href="#[3ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecLescInit
<LI><a href="#[3ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecInit
<LI><a href="#[22b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmScanInit
<LI><a href="#[3ae]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmPrivInit
<LI><a href="#[265]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_printf
<LI><a href="#[3b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvHandlerInit
<LI><a href="#[276]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciHandlerInit
<LI><a href="#[2cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpHandlerInit
<LI><a href="#[3b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmprInit
<LI><a href="#[2d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmprScInit
<LI><a href="#[2b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecInit
<LI><a href="#[3a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecCmacInit
<LI><a href="#[3a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecAesInit
<LI><a href="#[3b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cSlaveInit
<LI><a href="#[3af]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cSlaveHandlerInit
<LI><a href="#[2a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cInit
<LI><a href="#[1f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BeaconScannerHandlerInit
<LI><a href="#[193]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppHandlerInit
</UL>
<BR>[Called By]<UL><LI><a href="#[6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioTask
</UL>

<P><STRONG><a name="[25b]"></a>hciCmdAlloc</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, hci_cmd.o(i.hciCmdAlloc))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = hciCmdAlloc &rArr; WsfMsgAlloc &rArr; WsfBufAlloc
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[2a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciSetEventMaskPage2Cmd
<LI><a href="#[2a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciSetEventMaskCmd
<LI><a href="#[296]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciResetCmd
<LI><a href="#[295]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciReadRssiCmd
<LI><a href="#[25f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciReadLocalVerInfoCmd
<LI><a href="#[294]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciReadBdAddrCmd
<LI><a href="#[293]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeWriteDefDataLen
<LI><a href="#[292]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeStartEncryptionCmd
<LI><a href="#[291]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetScanRespDataCmd
<LI><a href="#[290]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetScanParamCmd
<LI><a href="#[28f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetScanEnableCmd
<LI><a href="#[28e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetPrivacyModeCmd
<LI><a href="#[28d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetEventMaskCmd
<LI><a href="#[28c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetDataLen
<LI><a href="#[28a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetAdvParamCmd
<LI><a href="#[289]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetAdvEnableCmd
<LI><a href="#[288]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetAdvDataCmd
<LI><a href="#[287]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetAddrResolutionEnable
<LI><a href="#[286]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeRemoveDeviceFromResolvingList
<LI><a href="#[285]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeRemoteConnParamReqReply
<LI><a href="#[284]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeRemoteConnParamReqNegReply
<LI><a href="#[283]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeReadWhiteListSizeCmd
<LI><a href="#[282]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeReadSupStatesCmd
<LI><a href="#[281]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeReadResolvingListSize
<LI><a href="#[228]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeReadRemoteFeatCmd
<LI><a href="#[280]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeReadMaxDataLen
<LI><a href="#[27f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeReadLocalSupFeatCmd
<LI><a href="#[27e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeReadBufSizeCmd
<LI><a href="#[27d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeRandCmd
<LI><a href="#[27c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeLtkReqReplCmd
<LI><a href="#[27b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeLtkReqNegReplCmd
<LI><a href="#[27a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeEncryptCmd
<LI><a href="#[279]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeConnUpdateCmd
<LI><a href="#[21d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeClearWhiteListCmd
<LI><a href="#[278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeClearResolvingList
<LI><a href="#[277]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeAddDeviceToResolvingListCmd
<LI><a href="#[21b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeAddDevWhiteListCmd
<LI><a href="#[25a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDisconnectCmd
<LI><a href="#[2a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciWriteAuthPayloadTimeout
</UL>

<P><STRONG><a name="[3bd]"></a>hciCmdInit</STRONG> (Thumb, 34 bytes, Stack size 0 bytes, hci_cmd.o(i.hciCmdInit))
<BR><BR>[Called By]<UL><LI><a href="#[259]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreInit
</UL>

<P><STRONG><a name="[3b7]"></a>hciCmdRecvCmpl</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, hci_cmd.o(i.hciCmdRecvCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 200<LI>Call Chain = hciCmdRecvCmpl &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[263]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStop
<LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
</UL>
<BR>[Called By]<UL><LI><a href="#[3ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessCmdStatus
<LI><a href="#[3c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessCmdCmpl
</UL>

<P><STRONG><a name="[25c]"></a>hciCmdSend</STRONG> (Thumb, 84 bytes, Stack size 16 bytes, hci_cmd.o(i.hciCmdSend))
<BR><BR>[Stack]<UL><LI>Max Depth = 192<LI>Call Chain = hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[3b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciTrSendCmd
<LI><a href="#[2a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStartSec
<LI><a href="#[29e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgEnq
<LI><a href="#[257]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgDeq
</UL>
<BR>[Called By]<UL><LI><a href="#[2a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciSetEventMaskPage2Cmd
<LI><a href="#[2a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciSetEventMaskCmd
<LI><a href="#[296]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciResetCmd
<LI><a href="#[295]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciReadRssiCmd
<LI><a href="#[25f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciReadLocalVerInfoCmd
<LI><a href="#[294]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciReadBdAddrCmd
<LI><a href="#[293]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeWriteDefDataLen
<LI><a href="#[292]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeStartEncryptionCmd
<LI><a href="#[291]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetScanRespDataCmd
<LI><a href="#[290]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetScanParamCmd
<LI><a href="#[28f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetScanEnableCmd
<LI><a href="#[28e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetPrivacyModeCmd
<LI><a href="#[28d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetEventMaskCmd
<LI><a href="#[28c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetDataLen
<LI><a href="#[28a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetAdvParamCmd
<LI><a href="#[289]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetAdvEnableCmd
<LI><a href="#[288]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetAdvDataCmd
<LI><a href="#[287]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetAddrResolutionEnable
<LI><a href="#[286]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeRemoveDeviceFromResolvingList
<LI><a href="#[285]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeRemoteConnParamReqReply
<LI><a href="#[284]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeRemoteConnParamReqNegReply
<LI><a href="#[283]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeReadWhiteListSizeCmd
<LI><a href="#[282]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeReadSupStatesCmd
<LI><a href="#[281]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeReadResolvingListSize
<LI><a href="#[228]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeReadRemoteFeatCmd
<LI><a href="#[280]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeReadMaxDataLen
<LI><a href="#[27f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeReadLocalSupFeatCmd
<LI><a href="#[27e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeReadBufSizeCmd
<LI><a href="#[27d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeRandCmd
<LI><a href="#[27c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeLtkReqReplCmd
<LI><a href="#[27b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeLtkReqNegReplCmd
<LI><a href="#[27a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeEncryptCmd
<LI><a href="#[279]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeConnUpdateCmd
<LI><a href="#[21d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeClearWhiteListCmd
<LI><a href="#[278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeClearResolvingList
<LI><a href="#[277]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeAddDeviceToResolvingListCmd
<LI><a href="#[21b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeAddDevWhiteListCmd
<LI><a href="#[25a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDisconnectCmd
<LI><a href="#[3b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdRecvCmpl
<LI><a href="#[2a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciWriteAuthPayloadTimeout
</UL>

<P><STRONG><a name="[253]"></a>hciCmdTimeout</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, hci_cmd.o(i.hciCmdTimeout))
<BR><BR>[Stack]<UL><LI>Max Depth = 372<LI>Call Chain = hciCmdTimeout &rArr; HciDrvRadioBoot &rArr; am_hal_ble_boot &rArr; am_hal_ble_patch_complete &rArr; am_hal_ble_plf_reg_read &rArr; am_hal_ble_blocking_hci_write &rArr; am_hal_ble_blocking_transfer &rArr; am_hal_ble_cmd_write
</UL>
<BR>[Calls]<UL><LI><a href="#[268]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvRadioShutdown
<LI><a href="#[1b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvRadioBoot
<LI><a href="#[1b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmDevReset
</UL>
<BR>[Called By]<UL><LI><a href="#[252]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciCoreHandler
</UL>

<P><STRONG><a name="[256]"></a>hciCoreAclReassembly</STRONG> (Thumb, 270 bytes, Stack size 40 bytes, hci_core.o(i.hciCoreAclReassembly))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = hciCoreAclReassembly &rArr; WsfMsgDataAlloc &rArr; WsfMsgAlloc &rArr; WsfBufAlloc
</UL>
<BR>[Calls]<UL><LI><a href="#[2d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgDataAlloc
<LI><a href="#[29b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreConnByHandle
<LI><a href="#[1cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgFree
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[252]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciCoreHandler
</UL>

<P><STRONG><a name="[29b]"></a>hciCoreConnByHandle</STRONG> (Thumb, 32 bytes, Stack size 0 bytes, hci_core.o(i.hciCoreConnByHandle))
<BR><BR>[Called By]<UL><LI><a href="#[3be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreNumCmplPkts
<LI><a href="#[298]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreTxReady
<LI><a href="#[256]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreAclReassembly
<LI><a href="#[29a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciSendAclData
</UL>

<P><STRONG><a name="[3b9]"></a>hciCoreConnClose</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, hci_core.o(i.hciCoreConnClose))
<BR><BR>[Stack]<UL><LI>Max Depth = 288<LI>Call Chain = hciCoreConnClose &rArr; hciCoreConnFree &rArr; hciCoreTxReady &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[3ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreConnFree
</UL>
<BR>[Called By]<UL><LI><a href="#[254]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessMsg
</UL>

<P><STRONG><a name="[3bb]"></a>hciCoreConnOpen</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, hci_core.o(i.hciCoreConnOpen))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = hciCoreConnOpen &rArr; hciCoreConnAlloc
</UL>
<BR>[Calls]<UL><LI><a href="#[3bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreConnAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[254]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessMsg
</UL>

<P><STRONG><a name="[259]"></a>hciCoreInit</STRONG> (Thumb, 8 bytes, Stack size 8 bytes, hci_core_ps.o(i.hciCoreInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = hciCoreInit
</UL>
<BR>[Calls]<UL><LI><a href="#[3bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdInit
</UL>
<BR>[Called By]<UL><LI><a href="#[258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciCoreInit
</UL>

<P><STRONG><a name="[3be]"></a>hciCoreNumCmplPkts</STRONG> (Thumb, 124 bytes, Stack size 32 bytes, hci_core_ps.o(i.hciCoreNumCmplPkts))
<BR><BR>[Stack]<UL><LI>Max Depth = 296<LI>Call Chain = hciCoreNumCmplPkts &rArr; hciCoreTxReady &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[298]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreTxReady
<LI><a href="#[29b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreConnByHandle
</UL>
<BR>[Called By]<UL><LI><a href="#[254]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessMsg
</UL>

<P><STRONG><a name="[3c1]"></a>hciCoreRecv</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, hci_core_ps.o(i.hciCoreRecv))
<BR><BR>[Stack]<UL><LI>Max Depth = 152<LI>Call Chain = hciCoreRecv &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[262]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfSetEvent
<LI><a href="#[29e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgEnq
</UL>
<BR>[Called By]<UL><LI><a href="#[261]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciTrSerialRxIncoming
</UL>

<P><STRONG><a name="[255]"></a>hciCoreResetSequence</STRONG> (Thumb, 502 bytes, Stack size 24 bytes, hci_vs.o(i.hciCoreResetSequence))
<BR><BR>[Stack]<UL><LI>Max Depth = 240<LI>Call Chain = hciCoreResetSequence &rArr; HciLeWriteDefDataLen &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[2a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciSetEventMaskPage2Cmd
<LI><a href="#[2a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciSetEventMaskCmd
<LI><a href="#[294]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciReadBdAddrCmd
<LI><a href="#[293]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeWriteDefDataLen
<LI><a href="#[28d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetEventMaskCmd
<LI><a href="#[283]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeReadWhiteListSizeCmd
<LI><a href="#[282]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeReadSupStatesCmd
<LI><a href="#[27f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeReadLocalSupFeatCmd
<LI><a href="#[27e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeReadBufSizeCmd
<LI><a href="#[27d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeRandCmd
<LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCpy
<LI><a href="#[3c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreReadResolvingListSize
<LI><a href="#[3bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreReadMaxDataLen
</UL>
<BR>[Called By]<UL><LI><a href="#[252]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciCoreHandler
</UL>

<P><STRONG><a name="[299]"></a>hciCoreResetStart</STRONG> (Thumb, 8 bytes, Stack size 8 bytes, hci_vs.o(i.hciCoreResetStart))
<BR><BR>[Stack]<UL><LI>Max Depth = 224<LI>Call Chain = hciCoreResetStart &rArr; HciResetCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[296]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciResetCmd
</UL>
<BR>[Called By]<UL><LI><a href="#[297]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciResetSequence
</UL>

<P><STRONG><a name="[3c2]"></a>hciCoreSendAclData</STRONG> (Thumb, 46 bytes, Stack size 16 bytes, hci_core.o(i.hciCoreSendAclData))
<BR><BR>[Stack]<UL><LI>Max Depth = 192<LI>Call Chain = hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[3c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciTrSendAclData
</UL>
<BR>[Called By]<UL><LI><a href="#[29d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreTxAclStart
<LI><a href="#[3c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreTxAclContinue
</UL>

<P><STRONG><a name="[3c4]"></a>hciCoreTxAclComplete</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, hci_core.o(i.hciCoreTxAclComplete))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = hciCoreTxAclComplete &rArr; WsfMsgFree &rArr; WsfBufFree
</UL>
<BR>[Calls]<UL><LI><a href="#[1cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgFree
</UL>
<BR>[Called By]<UL><LI><a href="#[3c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciTrSendAclData
</UL>

<P><STRONG><a name="[3c5]"></a>hciCoreTxAclContinue</STRONG> (Thumb, 100 bytes, Stack size 16 bytes, hci_core.o(i.hciCoreTxAclContinue))
<BR><BR>[Stack]<UL><LI>Max Depth = 208<LI>Call Chain = hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[29f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciGetBufSize
<LI><a href="#[3c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreSendAclData
<LI><a href="#[3c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreNextConnFragment
</UL>
<BR>[Called By]<UL><LI><a href="#[298]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreTxReady
<LI><a href="#[29d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreTxAclStart
</UL>

<P><STRONG><a name="[29d]"></a>hciCoreTxAclStart</STRONG> (Thumb, 84 bytes, Stack size 24 bytes, hci_core.o(i.hciCoreTxAclStart))
<BR><BR>[Stack]<UL><LI>Max Depth = 232<LI>Call Chain = hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[29f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciGetBufSize
<LI><a href="#[3c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreTxAclContinue
<LI><a href="#[3c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreSendAclData
</UL>
<BR>[Called By]<UL><LI><a href="#[298]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreTxReady
<LI><a href="#[29a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciSendAclData
</UL>

<P><STRONG><a name="[298]"></a>hciCoreTxReady</STRONG> (Thumb, 144 bytes, Stack size 32 bytes, hci_core.o(i.hciCoreTxReady))
<BR><BR>[Stack]<UL><LI>Max Depth = 264<LI>Call Chain = hciCoreTxReady &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[29d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreTxAclStart
<LI><a href="#[3c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreTxAclContinue
<LI><a href="#[29b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreConnByHandle
<LI><a href="#[1cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgFree
<LI><a href="#[257]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgDeq
</UL>
<BR>[Called By]<UL><LI><a href="#[3be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreNumCmplPkts
<LI><a href="#[297]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciResetSequence
<LI><a href="#[3ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreConnFree
</UL>

<P><STRONG><a name="[3c9]"></a>hciCoreVsCmdCmplRcvd</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, hci_vs.o(i.hciCoreVsCmdCmplRcvd))
<BR><BR>[Called By]<UL><LI><a href="#[3c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessCmdCmpl
</UL>

<P><STRONG><a name="[3c7]"></a>hciDrvWrite</STRONG> (Thumb, 110 bytes, Stack size 24 bytes, hci_drv_apollo3.o(i.hciDrvWrite))
<BR><BR>[Stack]<UL><LI>Max Depth = 160<LI>Call Chain = hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[262]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfSetEvent
<LI><a href="#[319]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_queue_item_add
<LI><a href="#[266]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;error_check
</UL>
<BR>[Called By]<UL><LI><a href="#[3c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciTrSendAclData
<LI><a href="#[3b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciTrSendCmd
</UL>

<P><STRONG><a name="[3cb]"></a>hciEvtCmdStatusFailure</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, hci_evt.o(i.hciEvtCmdStatusFailure))
<BR><BR>[Called By]<UL><LI><a href="#[3ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessCmdStatus
</UL>

<P><STRONG><a name="[3c8]"></a>hciEvtProcessCmdCmpl</STRONG> (Thumb, 384 bytes, Stack size 32 bytes, hci_evt.o(i.hciEvtProcessCmdCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 232<LI>Call Chain = hciEvtProcessCmdCmpl &rArr; hciCmdRecvCmpl &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[3b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdRecvCmpl
<LI><a href="#[3c9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreVsCmdCmplRcvd
<LI><a href="#[168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufFree
<LI><a href="#[16d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[254]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessMsg
</UL>

<P><STRONG><a name="[3ca]"></a>hciEvtProcessCmdStatus</STRONG> (Thumb, 46 bytes, Stack size 24 bytes, hci_evt.o(i.hciEvtProcessCmdStatus))
<BR><BR>[Stack]<UL><LI>Max Depth = 224<LI>Call Chain = hciEvtProcessCmdStatus &rArr; hciCmdRecvCmpl &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[3b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdRecvCmpl
<LI><a href="#[3cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtCmdStatusFailure
</UL>
<BR>[Called By]<UL><LI><a href="#[254]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessMsg
</UL>

<P><STRONG><a name="[254]"></a>hciEvtProcessMsg</STRONG> (Thumb, 564 bytes, Stack size 40 bytes, hci_evt.o(i.hciEvtProcessMsg))
<BR><BR>[Stack]<UL><LI>Max Depth = 336<LI>Call Chain = hciEvtProcessMsg &rArr; hciCoreNumCmplPkts &rArr; hciCoreTxReady &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[3be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreNumCmplPkts
<LI><a href="#[3bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreConnOpen
<LI><a href="#[3b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreConnClose
<LI><a href="#[168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufFree
<LI><a href="#[16d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufAlloc
<LI><a href="#[3ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessCmdStatus
<LI><a href="#[3c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessCmdCmpl
<LI><a href="#[3cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessLePerAdvReport
<LI><a href="#[3ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessLeExtAdvReport
<LI><a href="#[3cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessLeDirectAdvReport
<LI><a href="#[3cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessLeAdvReport
</UL>
<BR>[Called By]<UL><LI><a href="#[252]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciCoreHandler
</UL>

<P><STRONG><a name="[3c3]"></a>hciTrSendAclData</STRONG> (Thumb, 44 bytes, Stack size 16 bytes, hci_tr.o(i.hciTrSendAclData))
<BR><BR>[Stack]<UL><LI>Max Depth = 176<LI>Call Chain = hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[3c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreTxAclComplete
<LI><a href="#[3c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciDrvWrite
</UL>
<BR>[Called By]<UL><LI><a href="#[3c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreSendAclData
</UL>

<P><STRONG><a name="[3b8]"></a>hciTrSendCmd</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, hci_tr.o(i.hciTrSendCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 176<LI>Call Chain = hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgFree
<LI><a href="#[3c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciDrvWrite
</UL>
<BR>[Called By]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCmdSend
</UL>

<P><STRONG><a name="[261]"></a>hciTrSerialRxIncoming</STRONG> (Thumb, 414 bytes, Stack size 32 bytes, hci_tr.o(i.hciTrSerialRxIncoming))
<BR><BR>[Stack]<UL><LI>Max Depth = 184<LI>Call Chain = hciTrSerialRxIncoming &rArr; hciCoreRecv &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[3c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreRecv
<LI><a href="#[2d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgDataAlloc
<LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[69]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvHandler
</UL>

<P><STRONG><a name="[2a5]"></a>l2cMsgAlloc</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, l2c_main.o(i.l2cMsgAlloc))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = l2cMsgAlloc &rArr; WsfMsgDataAlloc &rArr; WsfMsgAlloc &rArr; WsfBufAlloc
</UL>
<BR>[Calls]<UL><LI><a href="#[2d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgDataAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[2a3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cDmConnUpdateReq
<LI><a href="#[3d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;l2cSendCmdReject
</UL>

<P><STRONG><a name="[4b]"></a>l2cRxSignalingPkt</STRONG> (Thumb, 82 bytes, Stack size 24 bytes, l2c_main.o(i.l2cRxSignalingPkt))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = l2cRxSignalingPkt
</UL>
<BR>[Calls]<UL><LI><a href="#[173]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnRole
<LI><a href="#[348]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnIdByHandle
</UL>
<BR>[Address Reference Count : 1]<UL><LI> l2c_main.o(i.L2cInit)
</UL>
<P><STRONG><a name="[3d0]"></a>l2cSendCmdReject</STRONG> (Thumb, 74 bytes, Stack size 24 bytes, l2c_main.o(i.l2cSendCmdReject))
<BR><BR>[Stack]<UL><LI>Max Depth = 304<LI>Call Chain = l2cSendCmdReject &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cDataReq
<LI><a href="#[2a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;l2cMsgAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;l2cSlaveRxSignalingPkt
</UL>

<P><STRONG><a name="[135]"></a>main</STRONG> (Thumb, 62 bytes, Stack size 0 bytes, ble_freertos_beaconscanner.o(i.main))
<BR><BR>[Stack]<UL><LI>Max Depth = 292 + Unknown Stack Size
<LI>Call Chain = main &rArr; am_util_stdio_printf &rArr; am_util_stdio_vsprintf &rArr; ftoa &rArr; uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[265]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_printf
<LI><a href="#[3d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;run_tasks
<LI><a href="#[31b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_sysctrl_fpu_stacking_enable
<LI><a href="#[3d3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_sysctrl_fpu_enable
<LI><a href="#[318]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_memory_enable
<LI><a href="#[316]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_clkgen_control
<LI><a href="#[3d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_cachectrl_enable
<LI><a href="#[312]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_cachectrl_config
<LI><a href="#[2f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_bsp_low_power_init
<LI><a href="#[3a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;enable_print_interface
</UL>
<BR>[Called By]<UL><LI><a href="#[134]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry_main
</UL>

<P><STRONG><a name="[3fd]"></a>pvPortMalloc</STRONG> (Thumb, 176 bytes, Stack size 24 bytes, heap_2.o(i.pvPortMalloc))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = pvPortMalloc &rArr; xTaskResumeAll &rArr; xTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[3ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vApplicationMallocFailedHook
<LI><a href="#[3e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeAll
<LI><a href="#[3e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspendAll
<LI><a href="#[3fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvHeapInit
</UL>
<BR>[Called By]<UL><LI><a href="#[2e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTimerCreate
<LI><a href="#[2df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xEventGroupCreate
<LI><a href="#[400]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskCreate
<LI><a href="#[3e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericCreate
</UL>

<P><STRONG><a name="[3ec]"></a>pxPortInitialiseStack</STRONG> (Thumb, 38 bytes, Stack size 0 bytes, port.o(i.pxPortInitialiseStack))
<BR><BR>[Called By]<UL><LI><a href="#[3ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvInitialiseNewTask
</UL>

<P><STRONG><a name="[3d4]"></a>run_tasks</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, rtos.o(i.run_tasks))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + Unknown Stack Size
<LI>Call Chain = run_tasks &rArr; vTaskStartScheduler &rArr; xTimerCreateTimerTask &rArr; xTaskCreate &rArr; pvPortMalloc &rArr; xTaskResumeAll &rArr; xTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[400]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskCreate
<LI><a href="#[401]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskStartScheduler
</UL>
<BR>[Called By]<UL><LI><a href="#[135]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[2aa]"></a>setup_buttons</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, radio_task.o(i.setup_buttons))
<BR><BR>[Stack]<UL><LI>Max Depth = 112<LI>Call Chain = setup_buttons &rArr; am_devices_button_array_init &rArr; am_devices_button_init &rArr; am_hal_gpio_pinconfig
</UL>
<BR>[Calls]<UL><LI><a href="#[2a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStartSec
<LI><a href="#[2fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_button_array_init
</UL>
<BR>[Called By]<UL><LI><a href="#[6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioTask
</UL>

<P><STRONG><a name="[6b]"></a>setup_task</STRONG> (Thumb, 44 bytes, Stack size 16 bytes, rtos.o(i.setup_task))
<BR><BR>[Stack]<UL><LI>Max Depth = 388 + Unknown Stack Size
<LI>Call Chain = setup_task &rArr; RadioTaskSetup &rArr; HciDrvRadioBoot &rArr; am_hal_ble_boot &rArr; am_hal_ble_patch_complete &rArr; am_hal_ble_plf_reg_read &rArr; am_hal_ble_blocking_hci_write &rArr; am_hal_ble_blocking_transfer &rArr; am_hal_ble_cmd_write
</UL>
<BR>[Calls]<UL><LI><a href="#[265]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_printf
<LI><a href="#[400]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskCreate
<LI><a href="#[405]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspend
<LI><a href="#[2ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioTaskSetup
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rtos.o(i.run_tasks)
</UL>
<P><STRONG><a name="[101]"></a>smpActAttemptRcvd</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, smp_act.o(i.smpActAttemptRcvd))
<BR>[Address Reference Count : 2]<UL><LI> smpr_sm.o(.constdata)
<LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[fe]"></a>smpActCheckAttempts</STRONG> (Thumb, 42 bytes, Stack size 16 bytes, smp_act.o(i.smpActCheckAttempts))
<BR><BR>[Stack]<UL><LI>Max Depth = 336<LI>Call Chain = smpActCheckAttempts &rArr; smpSendPairingFailed &rArr; smpSendPkt &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActNotifyDmAttemptsFailure
<LI><a href="#[406]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendPairingFailed
<LI><a href="#[407]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCleanup
</UL>
<BR>[Address Reference Count : 2]<UL><LI> smpr_sm.o(.constdata)
<LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[126]"></a>smpActCleanup</STRONG> (Thumb, 14 bytes, Stack size 16 bytes, smp_act.o(i.smpActCleanup))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = smpActCleanup &rArr; smpCleanup &rArr; WsfTimerStop &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[407]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCleanup
</UL>
<BR>[Called By]<UL><LI><a href="#[f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActCleanup
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sm.o(.constdata)
</UL>
<P><STRONG><a name="[fc]"></a>smpActMaxAttempts</STRONG> (Thumb, 46 bytes, Stack size 16 bytes, smp_act.o(i.smpActMaxAttempts))
<BR><BR>[Stack]<UL><LI>Max Depth = 352<LI>Call Chain = smpActMaxAttempts &rArr; smpActPairingCancel &rArr; smpSendPairingFailed &rArr; smpSendPkt &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[260]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStartMs
<LI><a href="#[128]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActPairingCancel
<LI><a href="#[2c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpDbMaxAttemptReached
</UL>
<BR>[Address Reference Count : 2]<UL><LI> smpr_sm.o(.constdata)
<LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[f0]"></a>smpActNone</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, smp_act.o(i.smpActNone))
<BR>[Address Reference Count : 2]<UL><LI> smpr_sm.o(.constdata)
<LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[ff]"></a>smpActNotifyDmAttemptsFailure</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, smp_act.o(i.smpActNotifyDmAttemptsFailure))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = smpActNotifyDmAttemptsFailure &rArr; DmSmpCbackExec
</UL>
<BR>[Calls]<UL><LI><a href="#[3a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSmpCbackExec
</UL>
<BR>[Called By]<UL><LI><a href="#[fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActCheckAttempts
</UL>
<BR>[Address Reference Count : 2]<UL><LI> smpr_sm.o(.constdata)
<LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[100]"></a>smpActNotifyDmRspToFailure</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, smp_act.o(i.smpActNotifyDmRspToFailure))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = smpActNotifyDmRspToFailure &rArr; DmSmpCbackExec
</UL>
<BR>[Calls]<UL><LI><a href="#[3a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSmpCbackExec
</UL>
<BR>[Address Reference Count : 2]<UL><LI> smpr_sm.o(.constdata)
<LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[f7]"></a>smpActPairCnfCalc1</STRONG> (Thumb, 42 bytes, Stack size 16 bytes, smp_act.o(i.smpActPairCnfCalc1))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = smpActPairCnfCalc1 &rArr; smpCalcC1Part1 &rArr; SecAes &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[18d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecRand
<LI><a href="#[408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCalcC1Part1
<LI><a href="#[f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActStorePin
</UL>
<BR>[Address Reference Count : 2]<UL><LI> smpr_sm.o(.constdata)
<LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[f8]"></a>smpActPairCnfCalc2</STRONG> (Thumb, 18 bytes, Stack size 16 bytes, smp_act.o(i.smpActPairCnfCalc2))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = smpActPairCnfCalc2 &rArr; smpCalcC1Part2 &rArr; SecAes &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[409]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCalcC1Part2
</UL>
<BR>[Address Reference Count : 2]<UL><LI> smpr_sm.o(.constdata)
<LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[fa]"></a>smpActPairCnfVerCalc1</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, smp_act.o(i.smpActPairCnfVerCalc1))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = smpActPairCnfVerCalc1 &rArr; smpCalcC1Part1 &rArr; SecAes &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCalcC1Part1
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Address Reference Count : 2]<UL><LI> smpr_sm.o(.constdata)
<LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[fb]"></a>smpActPairCnfVerCalc2</STRONG> (Thumb, 18 bytes, Stack size 16 bytes, smp_act.o(i.smpActPairCnfVerCalc2))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = smpActPairCnfVerCalc2 &rArr; smpCalcC1Part2 &rArr; SecAes &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[409]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCalcC1Part2
</UL>
<BR>[Address Reference Count : 2]<UL><LI> smpr_sm.o(.constdata)
<LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[128]"></a>smpActPairingCancel</STRONG> (Thumb, 24 bytes, Stack size 16 bytes, smp_act.o(i.smpActPairingCancel))
<BR><BR>[Stack]<UL><LI>Max Depth = 336<LI>Call Chain = smpActPairingCancel &rArr; smpSendPairingFailed &rArr; smpSendPkt &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[127]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActPairingFailed
<LI><a href="#[406]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendPairingFailed
</UL>
<BR>[Called By]<UL><LI><a href="#[fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActMaxAttempts
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sm.o(.constdata)
</UL>
<P><STRONG><a name="[fd]"></a>smpActPairingCmpl</STRONG> (Thumb, 52 bytes, Stack size 24 bytes, smp_act.o(i.smpActPairingCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = smpActPairingCmpl &rArr; smpCleanup &rArr; WsfTimerStop &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnSetIdle
<LI><a href="#[3a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSmpCbackExec
<LI><a href="#[407]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCleanup
</UL>
<BR>[Address Reference Count : 2]<UL><LI> smpr_sm.o(.constdata)
<LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[127]"></a>smpActPairingFailed</STRONG> (Thumb, 36 bytes, Stack size 16 bytes, smp_act.o(i.smpActPairingFailed))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = smpActPairingFailed &rArr; smpCleanup &rArr; WsfTimerStop &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnSetIdle
<LI><a href="#[3a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSmpCbackExec
<LI><a href="#[407]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCleanup
</UL>
<BR>[Called By]<UL><LI><a href="#[128]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActPairingCancel
<LI><a href="#[f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActPairingFailed
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sm.o(.constdata)
</UL>
<P><STRONG><a name="[f9]"></a>smpActSendPairCnf</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, smp_act.o(i.smpActSendPairCnf))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = smpActSendPairCnf &rArr; smpSendPkt &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[40a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpStartRspTimer
<LI><a href="#[40c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendPkt
<LI><a href="#[40b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpMsgAlloc
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Address Reference Count : 2]<UL><LI> smpr_sm.o(.constdata)
<LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[f5]"></a>smpActStorePin</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, smp_act.o(i.smpActStorePin))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = smpActStorePin
</UL>
<BR>[Calls]<UL><LI><a href="#[1d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActPairCnfCalc1
</UL>
<BR>[Address Reference Count : 2]<UL><LI> smpr_sm.o(.constdata)
<LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[5b]"></a>smpAuthReq</STRONG> (Thumb, 98 bytes, Stack size 40 bytes, smp_act.o(i.smpAuthReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = smpAuthReq &rArr; smpSmExecute
</UL>
<BR>[Calls]<UL><LI><a href="#[3a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSmpCbackExec
<LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sm.o(i.SmprInit)
</UL>
<P><STRONG><a name="[408]"></a>smpCalcC1Part1</STRONG> (Thumb, 290 bytes, Stack size 56 bytes, smp_main.o(i.smpCalcC1Part1))
<BR><BR>[Stack]<UL><LI>Max Depth = 304<LI>Call Chain = smpCalcC1Part1 &rArr; SecAes &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaIsZeros
<LI><a href="#[2ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecAes
<LI><a href="#[40f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnPeerRpa
<LI><a href="#[175]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnPeerAddrType
<LI><a href="#[40d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnLocalRpa
<LI><a href="#[40e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnLocalAddrType
<LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
</UL>
<BR>[Called By]<UL><LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprActProcPairCnfCalc1
<LI><a href="#[fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActPairCnfVerCalc1
<LI><a href="#[f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActPairCnfCalc1
</UL>

<P><STRONG><a name="[409]"></a>smpCalcC1Part2</STRONG> (Thumb, 278 bytes, Stack size 56 bytes, smp_main.o(i.smpCalcC1Part2))
<BR><BR>[Stack]<UL><LI>Max Depth = 304<LI>Call Chain = smpCalcC1Part2 &rArr; SecAes &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaIsZeros
<LI><a href="#[2ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecAes
<LI><a href="#[40f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnPeerRpa
<LI><a href="#[174]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnPeerAddr
<LI><a href="#[40d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnLocalRpa
<LI><a href="#[410]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnLocalAddr
<LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
</UL>
<BR>[Called By]<UL><LI><a href="#[fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActPairCnfVerCalc2
<LI><a href="#[f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActPairCnfCalc2
</UL>

<P><STRONG><a name="[411]"></a>smpCalcS1</STRONG> (Thumb, 86 bytes, Stack size 40 bytes, smp_main.o(i.smpCalcS1))
<BR><BR>[Stack]<UL><LI>Max Depth = 288<LI>Call Chain = smpCalcS1 &rArr; SecAes &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[412]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Calc128Cpy64
<LI><a href="#[2ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecAes
<LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
</UL>
<BR>[Called By]<UL><LI><a href="#[121]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprActCnfVerify
</UL>

<P><STRONG><a name="[2c9]"></a>smpCcbByConnId</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, smp_main.o(i.smpCcbByConnId))
<BR><BR>[Called By]<UL><LI><a href="#[232]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScGetCancelMsgWithReattempt
<LI><a href="#[2c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpDmGetStk
<LI><a href="#[65]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpHandler
<LI><a href="#[415]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpResumeAttemptsState
<LI><a href="#[55]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpL2cCtrlCback
<LI><a href="#[57]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpDmConnCback
</UL>

<P><STRONG><a name="[413]"></a>smpCcbByHandle</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, smp_main.o(i.smpCcbByHandle))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = smpCcbByHandle
</UL>
<BR>[Calls]<UL><LI><a href="#[348]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnIdByHandle
</UL>
<BR>[Called By]<UL><LI><a href="#[56]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpL2cDataCback
</UL>

<P><STRONG><a name="[407]"></a>smpCleanup</STRONG> (Thumb, 62 bytes, Stack size 8 bytes, smp_act.o(i.smpCleanup))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = smpCleanup &rArr; WsfTimerStop &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[263]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStop
<LI><a href="#[168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufFree
</UL>
<BR>[Called By]<UL><LI><a href="#[127]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActPairingFailed
<LI><a href="#[126]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActCleanup
<LI><a href="#[fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActPairingCmpl
<LI><a href="#[fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActCheckAttempts
</UL>

<P><STRONG><a name="[416]"></a>smpGenerateLtk</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, smp_main.o(i.smpGenerateLtk))
<BR><BR>[Stack]<UL><LI>Max Depth = 240<LI>Call Chain = smpGenerateLtk &rArr; SecRand &rArr; HciLeRandCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[18d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecRand
<LI><a href="#[3a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSmpCbackExec
<LI><a href="#[1d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr
</UL>
<BR>[Called By]<UL><LI><a href="#[426]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendKey
</UL>

<P><STRONG><a name="[428]"></a>smpGetPkBit</STRONG> (Thumb, 60 bytes, Stack size 12 bytes, smp_sc_main.o(i.smpGetPkBit))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = smpGetPkBit
</UL>
<BR>[Called By]<UL><LI><a href="#[110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActPkCalcCb
<LI><a href="#[112]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActPkCalcCa
</UL>

<P><STRONG><a name="[2ca]"></a>smpGetScSecLevel</STRONG> (Thumb, 50 bytes, Stack size 0 bytes, smp_main.o(i.smpGetScSecLevel))
<BR><BR>[Called By]<UL><LI><a href="#[2c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpDmGetStk
<LI><a href="#[426]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendKey
</UL>

<P><STRONG><a name="[40b]"></a>smpMsgAlloc</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, smp_main.o(i.smpMsgAlloc))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = smpMsgAlloc &rArr; WsfMsgDataAlloc &rArr; WsfMsgAlloc &rArr; WsfBufAlloc
</UL>
<BR>[Calls]<UL><LI><a href="#[2d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgDataAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[102]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprActSendSecurityReq
<LI><a href="#[104]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprActSendPairRsp
<LI><a href="#[122]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprActSendPairRandom
<LI><a href="#[10c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActPkSendKeypress
<LI><a href="#[f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActSendPairCnf
<LI><a href="#[425]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendRand
<LI><a href="#[424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendPubKey
<LI><a href="#[423]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendPairCnf
<LI><a href="#[422]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendDHKeyCheck
<LI><a href="#[406]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendPairingFailed
<LI><a href="#[426]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendKey
</UL>

<P><STRONG><a name="[5a]"></a>smpProcPairing</STRONG> (Thumb, 360 bytes, Stack size 32 bytes, smp_act.o(i.smpProcPairing))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = smpProcPairing &rArr; smpSmExecute
</UL>
<BR>[Calls]<UL><LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sm.o(i.SmprInit)
</UL>
<P><STRONG><a name="[418]"></a>smpProcRcvKey</STRONG> (Thumb, 262 bytes, Stack size 32 bytes, smp_act.o(i.smpProcRcvKey))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = smpProcRcvKey &rArr; Calc128Cpy
</UL>
<BR>[Calls]<UL><LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCpy
<LI><a href="#[206]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Calc128Cpy
<LI><a href="#[3a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSmpCbackExec
</UL>
<BR>[Called By]<UL><LI><a href="#[124]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprActRcvKey
</UL>

<P><STRONG><a name="[419]"></a>smpScActAuthSelect</STRONG> (Thumb, 122 bytes, Stack size 24 bytes, smp_sc_act.o(i.smpScActAuthSelect))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = smpScActAuthSelect &rArr; smpSmExecute
</UL>
<BR>[Calls]<UL><LI><a href="#[2bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WStrReverseCpy
<LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
</UL>
<BR>[Called By]<UL><LI><a href="#[f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActSendPubKey
</UL>

<P><STRONG><a name="[11c]"></a>smpScActCalcF5Ltk</STRONG> (Thumb, 142 bytes, Stack size 32 bytes, smp_sc_act.o(i.smpScActCalcF5Ltk))
<BR><BR>[Stack]<UL><LI>Max Depth = 408<LI>Call Chain = smpScActCalcF5Ltk &rArr; SmpScCmac &rArr; SecCmac &rArr; secCmacGenSubkey1 &rArr; SecLeEncryptCmd &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[206]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Calc128Cpy
<LI><a href="#[2d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScCat
<LI><a href="#[2d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScCmac
<LI><a href="#[2d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScCat128
<LI><a href="#[2cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScAlloc
<LI><a href="#[41b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScCatResponderBdAddr
<LI><a href="#[41a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScCatInitiatorBdAddr
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[11b]"></a>smpScActCalcF5MacKey</STRONG> (Thumb, 146 bytes, Stack size 32 bytes, smp_sc_act.o(i.smpScActCalcF5MacKey))
<BR><BR>[Stack]<UL><LI>Max Depth = 408<LI>Call Chain = smpScActCalcF5MacKey &rArr; SmpScCmac &rArr; SecCmac &rArr; secCmacGenSubkey1 &rArr; SecLeEncryptCmd &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[206]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Calc128Cpy
<LI><a href="#[2d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScCat
<LI><a href="#[2d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScCmac
<LI><a href="#[2d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScCat128
<LI><a href="#[2cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScAlloc
<LI><a href="#[41b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScCatResponderBdAddr
<LI><a href="#[41a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScCatInitiatorBdAddr
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[11a]"></a>smpScActCalcF5TKey</STRONG> (Thumb, 90 bytes, Stack size 40 bytes, smp_sc_act.o(i.smpScActCalcF5TKey))
<BR><BR>[Stack]<UL><LI>Max Depth = 416<LI>Call Chain = smpScActCalcF5TKey &rArr; SmpScCmac &rArr; SecCmac &rArr; secCmacGenSubkey1 &rArr; SecLeEncryptCmd &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[232]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScGetCancelMsgWithReattempt
<LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
<LI><a href="#[2d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScCmac
<LI><a href="#[2cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScAlloc
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[41c]"></a>smpScActCalcSharedSecret</STRONG> (Thumb, 88 bytes, Stack size 112 bytes, smp_sc_act.o(i.smpScActCalcSharedSecret))
<BR><BR>[Stack]<UL><LI>Max Depth = 924 + Unknown Stack Size
<LI>Call Chain = smpScActCalcSharedSecret &rArr; SecEccGenSharedSecret &rArr; uECC_shared_secret &rArr; EccPoint_mult &rArr; XYcZ_initial_double &rArr; EccPoint_double_jacobian &rArr; vli_modSquare_fast &rArr; vli_square &rArr; mul2add
</UL>
<BR>[Calls]<UL><LI><a href="#[2b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecEccGenSharedSecret
<LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[119]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActCalcDHKey
</UL>

<P><STRONG><a name="[f1]"></a>smpScActCleanup</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, smp_sc_act.o(i.smpScActCleanup))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = smpScActCleanup &rArr; smpActCleanup &rArr; smpCleanup &rArr; WsfTimerStop &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[126]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActCleanup
<LI><a href="#[2d3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScFreeScratchBuffers
</UL>
<BR>[Called By]<UL><LI><a href="#[f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActPairingFailed
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[11d]"></a>smpScActDHKeyCalcF6Ea</STRONG> (Thumb, 146 bytes, Stack size 24 bytes, smp_sc_act.o(i.smpScActDHKeyCalcF6Ea))
<BR><BR>[Stack]<UL><LI>Max Depth = 400<LI>Call Chain = smpScActDHKeyCalcF6Ea &rArr; SmpScCmac &rArr; SecCmac &rArr; secCmacGenSubkey1 &rArr; SecLeEncryptCmd &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[2bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WStrReverseCpy
<LI><a href="#[2d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScCmac
<LI><a href="#[2d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScCat128
<LI><a href="#[2cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScAlloc
<LI><a href="#[41b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScCatResponderBdAddr
<LI><a href="#[41a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScCatInitiatorBdAddr
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[11e]"></a>smpScActDHKeyCalcF6Eb</STRONG> (Thumb, 140 bytes, Stack size 24 bytes, smp_sc_act.o(i.smpScActDHKeyCalcF6Eb))
<BR><BR>[Stack]<UL><LI>Max Depth = 400<LI>Call Chain = smpScActDHKeyCalcF6Eb &rArr; SmpScCmac &rArr; SecCmac &rArr; secCmacGenSubkey1 &rArr; SecLeEncryptCmd &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[206]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Calc128Cpy
<LI><a href="#[2d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScCmac
<LI><a href="#[2d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScCat128
<LI><a href="#[2cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScAlloc
<LI><a href="#[41b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScCatResponderBdAddr
<LI><a href="#[41a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScCatInitiatorBdAddr
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[41d]"></a>smpScActJwncCalcF4</STRONG> (Thumb, 68 bytes, Stack size 24 bytes, smp_sc_act.o(i.smpScActJwncCalcF4))
<BR><BR>[Stack]<UL><LI>Max Depth = 440<LI>Call Chain = smpScActJwncCalcF4 &rArr; SmpScCalcF4 &rArr; SmpScCmac &rArr; SecCmac &rArr; secCmacGenSubkey1 &rArr; SecLeEncryptCmd &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[2cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScCalcF4
</UL>
<BR>[Called By]<UL><LI><a href="#[106]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActJwncSetup
</UL>

<P><STRONG><a name="[41e]"></a>smpScActJwncCalcG2</STRONG> (Thumb, 122 bytes, Stack size 24 bytes, smp_sc_act.o(i.smpScActJwncCalcG2))
<BR><BR>[Stack]<UL><LI>Max Depth = 400<LI>Call Chain = smpScActJwncCalcG2 &rArr; SmpScCmac &rArr; SecCmac &rArr; secCmacGenSubkey1 &rArr; SecLeEncryptCmd &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[2d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScCat
<LI><a href="#[2d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScCmac
<LI><a href="#[2d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScCat128
<LI><a href="#[2cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActJwncCalcG2
</UL>

<P><STRONG><a name="[41f]"></a>smpScActJwncDisplay</STRONG> (Thumb, 86 bytes, Stack size 32 bytes, smp_sc_act.o(i.smpScActJwncDisplay))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = smpScActJwncDisplay &rArr; smpSmExecute
</UL>
<BR>[Calls]<UL><LI><a href="#[206]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Calc128Cpy
<LI><a href="#[3a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSmpCbackExec
<LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
</UL>
<BR>[Called By]<UL><LI><a href="#[109]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActJwncDisplay
</UL>

<P><STRONG><a name="[f3]"></a>smpScActPairingCancel</STRONG> (Thumb, 24 bytes, Stack size 16 bytes, smp_sc_act.o(i.smpScActPairingCancel))
<BR><BR>[Stack]<UL><LI>Max Depth = 336<LI>Call Chain = smpScActPairingCancel &rArr; smpSendPairingFailed &rArr; smpSendPkt &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActPairingFailed
<LI><a href="#[406]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendPairingFailed
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[f2]"></a>smpScActPairingFailed</STRONG> (Thumb, 24 bytes, Stack size 16 bytes, smp_sc_act.o(i.smpScActPairingFailed))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = smpScActPairingFailed &rArr; smpScActCleanup &rArr; smpActCleanup &rArr; smpCleanup &rArr; WsfTimerStop &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[127]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActPairingFailed
<LI><a href="#[f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActCleanup
</UL>
<BR>[Called By]<UL><LI><a href="#[f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActPairingCancel
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[10b]"></a>smpScActPkKeypress</STRONG> (Thumb, 86 bytes, Stack size 32 bytes, smp_sc_act.o(i.smpScActPkKeypress))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = smpScActPkKeypress &rArr; smpSmExecute
</UL>
<BR>[Calls]<UL><LI><a href="#[3a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSmpCbackExec
<LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[10c]"></a>smpScActPkSendKeypress</STRONG> (Thumb, 78 bytes, Stack size 24 bytes, smp_sc_act.o(i.smpScActPkSendKeypress))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = smpScActPkSendKeypress &rArr; smpSendPkt &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[40a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpStartRspTimer
<LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
<LI><a href="#[40c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendPkt
<LI><a href="#[40b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpMsgAlloc
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[10a]"></a>smpScActPkSetup</STRONG> (Thumb, 58 bytes, Stack size 40 bytes, smp_sc_act.o(i.smpScActPkSetup))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = smpScActPkSetup &rArr; DmSmpCbackExec
</UL>
<BR>[Calls]<UL><LI><a href="#[3a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSmpCbackExec
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[59]"></a>smpScAuthReq</STRONG> (Thumb, 118 bytes, Stack size 40 bytes, smp_sc_act.o(i.smpScAuthReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = smpScAuthReq &rArr; smpSmExecute
</UL>
<BR>[Calls]<UL><LI><a href="#[3a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSmpCbackExec
<LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smp_sc_main.o(i.SmpScInit)
</UL>
<P><STRONG><a name="[420]"></a>smpScFailWithReattempt</STRONG> (Thumb, 26 bytes, Stack size 16 bytes, smp_sc_main.o(i.smpScFailWithReattempt))
<BR><BR>[Stack]<UL><LI>Max Depth = 116<LI>Call Chain = smpScFailWithReattempt &rArr; SmpScGetCancelMsgWithReattempt &rArr; SmpDbPairingFailed &rArr; smpDbGetRecord &rArr; smpDbAddDevice &rArr; __aeabi_memclr4
</UL>
<BR>[Calls]<UL><LI><a href="#[232]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScGetCancelMsgWithReattempt
<LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
</UL>
<BR>[Called By]<UL><LI><a href="#[113]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActPkSendRand
<LI><a href="#[116]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActOobSendRand
</UL>

<P><STRONG><a name="[58]"></a>smpScProcPairing</STRONG> (Thumb, 788 bytes, Stack size 32 bytes, smp_sc_act.o(i.smpScProcPairing))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = smpScProcPairing &rArr; SmpScAllocScratchBuffers &rArr; WsfBufAlloc
</UL>
<BR>[Calls]<UL><LI><a href="#[421]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecGetEccKey
<LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
<LI><a href="#[2ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScAllocScratchBuffers
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smp_sc_main.o(i.SmpScInit)
</UL>
<P><STRONG><a name="[422]"></a>smpScSendDHKeyCheck</STRONG> (Thumb, 90 bytes, Stack size 24 bytes, smp_sc_main.o(i.smpScSendDHKeyCheck))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = smpScSendDHKeyCheck &rArr; smpSendPkt &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[2bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WStrReverseCpy
<LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnSetIdle
<LI><a href="#[40a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpStartRspTimer
<LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
<LI><a href="#[40c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendPkt
<LI><a href="#[40b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpMsgAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[11f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActDHKeyCheckSend
</UL>

<P><STRONG><a name="[423]"></a>smpScSendPairCnf</STRONG> (Thumb, 90 bytes, Stack size 24 bytes, smp_sc_main.o(i.smpScSendPairCnf))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = smpScSendPairCnf &rArr; smpSendPkt &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[2bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WStrReverseCpy
<LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnSetIdle
<LI><a href="#[40a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpStartRspTimer
<LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
<LI><a href="#[40c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendPkt
<LI><a href="#[40b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpMsgAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[111]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActPkSendCnf
<LI><a href="#[107]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActJwncSendCnf
</UL>

<P><STRONG><a name="[424]"></a>smpScSendPubKey</STRONG> (Thumb, 106 bytes, Stack size 24 bytes, smp_sc_main.o(i.smpScSendPubKey))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = smpScSendPubKey &rArr; smpSendPkt &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[2bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WStrReverseCpy
<LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnSetIdle
<LI><a href="#[40a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpStartRspTimer
<LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
<LI><a href="#[40c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendPkt
<LI><a href="#[40b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpMsgAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActSendPubKey
</UL>

<P><STRONG><a name="[425]"></a>smpScSendRand</STRONG> (Thumb, 90 bytes, Stack size 24 bytes, smp_sc_main.o(i.smpScSendRand))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = smpScSendRand &rArr; smpSendPkt &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[2bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WStrReverseCpy
<LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnSetIdle
<LI><a href="#[40a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpStartRspTimer
<LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
<LI><a href="#[40c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendPkt
<LI><a href="#[40b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpMsgAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[118]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActWaitDhCheck
<LI><a href="#[113]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActPkSendRand
<LI><a href="#[116]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActOobSendRand
<LI><a href="#[109]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActJwncDisplay
</UL>

<P><STRONG><a name="[426]"></a>smpSendKey</STRONG> (Thumb, 466 bytes, Stack size 64 bytes, smp_act.o(i.smpSendKey))
<BR><BR>[Stack]<UL><LI>Max Depth = 360<LI>Call Chain = smpSendKey &rArr; smpSendPkt &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[39c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciGetBdAddr
<LI><a href="#[1cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgFree
<LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCpy
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
<LI><a href="#[206]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Calc128Cpy
<LI><a href="#[427]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecGetLocalCsrk
<LI><a href="#[173]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnRole
<LI><a href="#[149]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecGetLocalIrk
<LI><a href="#[3a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSmpCbackExec
<LI><a href="#[2ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpGetScSecLevel
<LI><a href="#[40c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendPkt
<LI><a href="#[40b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpMsgAlloc
<LI><a href="#[416]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpGenerateLtk
</UL>
<BR>[Called By]<UL><LI><a href="#[125]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprActSendKey
</UL>

<P><STRONG><a name="[406]"></a>smpSendPairingFailed</STRONG> (Thumb, 44 bytes, Stack size 24 bytes, smp_act.o(i.smpSendPairingFailed))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = smpSendPairingFailed &rArr; smpSendPkt &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[40c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendPkt
<LI><a href="#[40b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpMsgAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[128]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActPairingCancel
<LI><a href="#[f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActPairingCancel
<LI><a href="#[fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActCheckAttempts
</UL>

<P><STRONG><a name="[40c]"></a>smpSendPkt</STRONG> (Thumb, 44 bytes, Stack size 16 bytes, smp_main.o(i.smpSendPkt))
<BR><BR>[Stack]<UL><LI>Max Depth = 296<LI>Call Chain = smpSendPkt &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgFree
<LI><a href="#[1dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cDataReq
</UL>
<BR>[Called By]<UL><LI><a href="#[102]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprActSendSecurityReq
<LI><a href="#[104]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprActSendPairRsp
<LI><a href="#[122]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprActSendPairRandom
<LI><a href="#[10c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActPkSendKeypress
<LI><a href="#[f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActSendPairCnf
<LI><a href="#[425]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendRand
<LI><a href="#[424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendPubKey
<LI><a href="#[423]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendPairCnf
<LI><a href="#[422]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendDHKeyCheck
<LI><a href="#[406]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendPairingFailed
<LI><a href="#[426]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendKey
<LI><a href="#[55]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpL2cCtrlCback
</UL>

<P><STRONG><a name="[2cb]"></a>smpSmExecute</STRONG> (Thumb, 110 bytes, Stack size 24 bytes, smp_act.o(i.smpSmExecute))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = smpSmExecute
</UL>
<BR>[Calls]<UL><LI><a href="#[173]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnRole
</UL>
<BR>[Called By]<UL><LI><a href="#[408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCalcC1Part1
<LI><a href="#[125]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprActSendKey
<LI><a href="#[124]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprActRcvKey
<LI><a href="#[103]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprActProcPairReq
<LI><a href="#[121]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprActCnfVerify
<LI><a href="#[5a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpProcPairing
<LI><a href="#[5b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpAuthReq
<LI><a href="#[10c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActPkSendKeypress
<LI><a href="#[10b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActPkKeypress
<LI><a href="#[41f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActJwncDisplay
<LI><a href="#[11a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActCalcF5TKey
<LI><a href="#[425]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendRand
<LI><a href="#[424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendPubKey
<LI><a href="#[423]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendPairCnf
<LI><a href="#[422]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendDHKeyCheck
<LI><a href="#[420]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScFailWithReattempt
<LI><a href="#[41c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActCalcSharedSecret
<LI><a href="#[419]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActAuthSelect
<LI><a href="#[411]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCalcS1
<LI><a href="#[2d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScCmac
<LI><a href="#[2cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScAlloc
<LI><a href="#[58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScProcPairing
<LI><a href="#[59]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScAuthReq
<LI><a href="#[65]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpHandler
<LI><a href="#[56]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpL2cDataCback
<LI><a href="#[55]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpL2cCtrlCback
<LI><a href="#[57]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpDmConnCback
<LI><a href="#[409]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCalcC1Part2
<LI><a href="#[113]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActPkSendRand
<LI><a href="#[115]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActOobCalcCa
<LI><a href="#[11f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActDHKeyCheckSend
</UL>

<P><STRONG><a name="[40a]"></a>smpStartRspTimer</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, smp_act.o(i.smpStartRspTimer))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = smpStartRspTimer &rArr; WsfTimerStartSec &rArr; wsfTimerInsert &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[2a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStartSec
</UL>
<BR>[Called By]<UL><LI><a href="#[123]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprActSetupKeyDist
<LI><a href="#[102]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprActSendSecurityReq
<LI><a href="#[104]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprActSendPairRsp
<LI><a href="#[122]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprActSendPairRandom
<LI><a href="#[10c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActPkSendKeypress
<LI><a href="#[f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpActSendPairCnf
<LI><a href="#[425]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendRand
<LI><a href="#[424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendPubKey
<LI><a href="#[423]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendPairCnf
<LI><a href="#[422]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendDHKeyCheck
</UL>

<P><STRONG><a name="[417]"></a>smpStateIdle</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, smp_main.o(i.smpStateIdle))
<BR><BR>[Called By]<UL><LI><a href="#[55]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpL2cCtrlCback
</UL>

<P><STRONG><a name="[121]"></a>smprActCnfVerify</STRONG> (Thumb, 96 bytes, Stack size 16 bytes, smpr_act.o(i.smprActCnfVerify))
<BR><BR>[Stack]<UL><LI>Max Depth = 304<LI>Call Chain = smprActCnfVerify &rArr; smpCalcS1 &rArr; SecAes &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
<LI><a href="#[411]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCalcS1
<LI><a href="#[2c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpDbPairingFailed
<LI><a href="#[15c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
</UL>
<BR>[Address Reference Count : 2]<UL><LI> smpr_sm.o(.constdata)
<LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[105]"></a>smprActProcPairCnf</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, smpr_act.o(i.smprActProcPairCnf))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = smprActProcPairCnf
</UL>
<BR>[Calls]<UL><LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprActProcPairCnfCalc1
</UL>
<BR>[Address Reference Count : 2]<UL><LI> smpr_sm.o(.constdata)
<LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[120]"></a>smprActProcPairCnfCalc1</STRONG> (Thumb, 42 bytes, Stack size 16 bytes, smpr_act.o(i.smprActProcPairCnfCalc1))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = smprActProcPairCnfCalc1 &rArr; smpCalcC1Part1 &rArr; SecAes &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[18d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecRand
<LI><a href="#[408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCalcC1Part1
<LI><a href="#[105]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprActProcPairCnf
</UL>
<BR>[Address Reference Count : 2]<UL><LI> smpr_sm.o(.constdata)
<LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[103]"></a>smprActProcPairReq</STRONG> (Thumb, 130 bytes, Stack size 24 bytes, smpr_act.o(i.smprActProcPairReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = smprActProcPairReq &rArr; WsfBufAlloc
</UL>
<BR>[Calls]<UL><LI><a href="#[16d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufAlloc
<LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnSetIdle
<LI><a href="#[3a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSmpCbackExec
<LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
</UL>
<BR>[Address Reference Count : 2]<UL><LI> smpr_sm.o(.constdata)
<LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[124]"></a>smprActRcvKey</STRONG> (Thumb, 46 bytes, Stack size 16 bytes, smpr_act.o(i.smprActRcvKey))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = smprActRcvKey &rArr; smpProcRcvKey &rArr; Calc128Cpy
</UL>
<BR>[Calls]<UL><LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
<LI><a href="#[418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpProcRcvKey
</UL>
<BR>[Address Reference Count : 2]<UL><LI> smpr_sm.o(.constdata)
<LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[125]"></a>smprActSendKey</STRONG> (Thumb, 140 bytes, Stack size 16 bytes, smpr_act.o(i.smprActSendKey))
<BR><BR>[Stack]<UL><LI>Max Depth = 376<LI>Call Chain = smprActSendKey &rArr; smpSendKey &rArr; smpSendPkt &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
<LI><a href="#[426]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendKey
</UL>
<BR>[Called By]<UL><LI><a href="#[123]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprActSetupKeyDist
</UL>
<BR>[Address Reference Count : 2]<UL><LI> smpr_sm.o(.constdata)
<LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[122]"></a>smprActSendPairRandom</STRONG> (Thumb, 114 bytes, Stack size 24 bytes, smpr_act.o(i.smprActSendPairRandom))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = smprActSendPairRandom &rArr; smpSendPkt &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[40a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpStartRspTimer
<LI><a href="#[40c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendPkt
<LI><a href="#[40b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpMsgAlloc
<LI><a href="#[1d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Address Reference Count : 2]<UL><LI> smpr_sm.o(.constdata)
<LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[104]"></a>smprActSendPairRsp</STRONG> (Thumb, 170 bytes, Stack size 32 bytes, smpr_act.o(i.smprActSendPairRsp))
<BR><BR>[Stack]<UL><LI>Max Depth = 328<LI>Call Chain = smprActSendPairRsp &rArr; smpSendPkt &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[40a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpStartRspTimer
<LI><a href="#[40c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendPkt
<LI><a href="#[40b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpMsgAlloc
</UL>
<BR>[Address Reference Count : 2]<UL><LI> smpr_sm.o(.constdata)
<LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[102]"></a>smprActSendSecurityReq</STRONG> (Thumb, 52 bytes, Stack size 24 bytes, smpr_act.o(i.smprActSendSecurityReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = smprActSendSecurityReq &rArr; smpSendPkt &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[40a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpStartRspTimer
<LI><a href="#[40c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendPkt
<LI><a href="#[40b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpMsgAlloc
</UL>
<BR>[Address Reference Count : 2]<UL><LI> smpr_sm.o(.constdata)
<LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[123]"></a>smprActSetupKeyDist</STRONG> (Thumb, 84 bytes, Stack size 16 bytes, smpr_act.o(i.smprActSetupKeyDist))
<BR><BR>[Stack]<UL><LI>Max Depth = 392<LI>Call Chain = smprActSetupKeyDist &rArr; smprActSendKey &rArr; smpSendKey &rArr; smpSendPkt &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[125]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprActSendKey
<LI><a href="#[40a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpStartRspTimer
</UL>
<BR>[Address Reference Count : 2]<UL><LI> smpr_sm.o(.constdata)
<LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[119]"></a>smprScActCalcDHKey</STRONG> (Thumb, 48 bytes, Stack size 16 bytes, smpr_sc_act.o(i.smprScActCalcDHKey))
<BR><BR>[Stack]<UL><LI>Max Depth = 940 + Unknown Stack Size
<LI>Call Chain = smprScActCalcDHKey &rArr; smpScActCalcSharedSecret &rArr; SecEccGenSharedSecret &rArr; uECC_shared_secret &rArr; EccPoint_mult &rArr; XYcZ_initial_double &rArr; EccPoint_double_jacobian &rArr; vli_modSquare_fast &rArr; vli_square &rArr; mul2add
</UL>
<BR>[Calls]<UL><LI><a href="#[2bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WStrReverseCpy
<LI><a href="#[41c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActCalcSharedSecret
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[11f]"></a>smprScActDHKeyCheckSend</STRONG> (Thumb, 160 bytes, Stack size 24 bytes, smpr_sc_act.o(i.smprScActDHKeyCheckSend))
<BR><BR>[Stack]<UL><LI>Max Depth = 344<LI>Call Chain = smprScActDHKeyCheckSend &rArr; smpScSendDHKeyCheck &rArr; smpSendPkt &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[206]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Calc128Cpy
<LI><a href="#[422]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendDHKeyCheck
<LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
<LI><a href="#[2c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpDbPairingFailed
<LI><a href="#[1d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr
<LI><a href="#[15c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[108]"></a>smprScActJwncCalcG2</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, smpr_sc_act.o(i.smprScActJwncCalcG2))
<BR><BR>[Stack]<UL><LI>Max Depth = 416<LI>Call Chain = smprScActJwncCalcG2 &rArr; smpScActJwncCalcG2 &rArr; SmpScCmac &rArr; SecCmac &rArr; secCmacGenSubkey1 &rArr; SecLeEncryptCmd &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[2bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WStrReverseCpy
<LI><a href="#[41e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActJwncCalcG2
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[109]"></a>smprScActJwncDisplay</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, smpr_sc_act.o(i.smprScActJwncDisplay))
<BR><BR>[Stack]<UL><LI>Max Depth = 336<LI>Call Chain = smprScActJwncDisplay &rArr; smpScSendRand &rArr; smpSendPkt &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[41f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActJwncDisplay
<LI><a href="#[425]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendRand
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[107]"></a>smprScActJwncSendCnf</STRONG> (Thumb, 18 bytes, Stack size 16 bytes, smpr_sc_act.o(i.smprScActJwncSendCnf))
<BR><BR>[Stack]<UL><LI>Max Depth = 336<LI>Call Chain = smprScActJwncSendCnf &rArr; smpScSendPairCnf &rArr; smpSendPkt &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[423]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendPairCnf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[106]"></a>smprScActJwncSetup</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, smpr_sc_act.o(i.smprScActJwncSetup))
<BR><BR>[Stack]<UL><LI>Max Depth = 456<LI>Call Chain = smprScActJwncSetup &rArr; smpScActJwncCalcF4 &rArr; SmpScCalcF4 &rArr; SmpScCmac &rArr; SecCmac &rArr; secCmacGenSubkey1 &rArr; SecLeEncryptCmd &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[206]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Calc128Cpy
<LI><a href="#[18d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecRand
<LI><a href="#[41d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActJwncCalcF4
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[115]"></a>smprScActOobCalcCa</STRONG> (Thumb, 126 bytes, Stack size 32 bytes, smpr_sc_act.o(i.smprScActOobCalcCa))
<BR><BR>[Stack]<UL><LI>Max Depth = 448<LI>Call Chain = smprScActOobCalcCa &rArr; SmpScCalcF4 &rArr; SmpScCmac &rArr; SecCmac &rArr; secCmacGenSubkey1 &rArr; SecLeEncryptCmd &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[206]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Calc128Cpy
<LI><a href="#[2bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WStrReverseCpy
<LI><a href="#[2cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScCalcF4
<LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[116]"></a>smprScActOobSendRand</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, smpr_sc_act.o(i.smprScActOobSendRand))
<BR><BR>[Stack]<UL><LI>Max Depth = 336<LI>Call Chain = smprScActOobSendRand &rArr; smpScSendRand &rArr; smpSendPkt &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[18d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecRand
<LI><a href="#[425]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendRand
<LI><a href="#[420]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScFailWithReattempt
<LI><a href="#[15c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[114]"></a>smprScActOobSetup</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, smpr_sc_act.o(i.smprScActOobSetup))
<BR>[Address Reference Count : 1]<UL><LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[112]"></a>smprScActPkCalcCa</STRONG> (Thumb, 60 bytes, Stack size 32 bytes, smpr_sc_act.o(i.smprScActPkCalcCa))
<BR><BR>[Stack]<UL><LI>Max Depth = 448<LI>Call Chain = smprScActPkCalcCa &rArr; SmpScCalcF4 &rArr; SmpScCmac &rArr; SecCmac &rArr; secCmacGenSubkey1 &rArr; SecLeEncryptCmd &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[2bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WStrReverseCpy
<LI><a href="#[428]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpGetPkBit
<LI><a href="#[2cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScCalcF4
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[110]"></a>smprScActPkCalcCb</STRONG> (Thumb, 60 bytes, Stack size 24 bytes, smpr_sc_act.o(i.smprScActPkCalcCb))
<BR><BR>[Stack]<UL><LI>Max Depth = 440<LI>Call Chain = smprScActPkCalcCb &rArr; SmpScCalcF4 &rArr; SmpScCmac &rArr; SecCmac &rArr; secCmacGenSubkey1 &rArr; SecLeEncryptCmd &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[18d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecRand
<LI><a href="#[428]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpGetPkBit
<LI><a href="#[2cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpScCalcF4
</UL>
<BR>[Called By]<UL><LI><a href="#[10f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActPkStorePinAndCalcCb
<LI><a href="#[10e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActPkStoreCnfAndCalcCb
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[111]"></a>smprScActPkSendCnf</STRONG> (Thumb, 18 bytes, Stack size 16 bytes, smpr_sc_act.o(i.smprScActPkSendCnf))
<BR><BR>[Stack]<UL><LI>Max Depth = 336<LI>Call Chain = smprScActPkSendCnf &rArr; smpScSendPairCnf &rArr; smpSendPkt &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[423]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendPairCnf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[113]"></a>smprScActPkSendRand</STRONG> (Thumb, 104 bytes, Stack size 16 bytes, smpr_sc_act.o(i.smprScActPkSendRand))
<BR><BR>[Stack]<UL><LI>Max Depth = 336<LI>Call Chain = smprScActPkSendRand &rArr; smpScSendRand &rArr; smpSendPkt &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[425]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendRand
<LI><a href="#[420]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScFailWithReattempt
<LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
<LI><a href="#[15c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[10d]"></a>smprScActPkStoreCnf</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, smpr_sc_act.o(i.smprScActPkStoreCnf))
<BR><BR>[Stack]<UL><LI>Max Depth = 28<LI>Call Chain = smprScActPkStoreCnf &rArr; WStrReverseCpy
</UL>
<BR>[Calls]<UL><LI><a href="#[2bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WStrReverseCpy
</UL>
<BR>[Called By]<UL><LI><a href="#[10e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActPkStoreCnfAndCalcCb
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[10e]"></a>smprScActPkStoreCnfAndCalcCb</STRONG> (Thumb, 24 bytes, Stack size 16 bytes, smpr_sc_act.o(i.smprScActPkStoreCnfAndCalcCb))
<BR><BR>[Stack]<UL><LI>Max Depth = 456<LI>Call Chain = smprScActPkStoreCnfAndCalcCb &rArr; smprScActPkCalcCb &rArr; SmpScCalcF4 &rArr; SmpScCmac &rArr; SecCmac &rArr; secCmacGenSubkey1 &rArr; SecLeEncryptCmd &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[10d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActPkStoreCnf
<LI><a href="#[110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActPkCalcCb
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[10f]"></a>smprScActPkStorePinAndCalcCb</STRONG> (Thumb, 24 bytes, Stack size 16 bytes, smpr_sc_act.o(i.smprScActPkStorePinAndCalcCb))
<BR><BR>[Stack]<UL><LI>Max Depth = 456<LI>Call Chain = smprScActPkStorePinAndCalcCb &rArr; smprScActPkCalcCb &rArr; SmpScCalcF4 &rArr; SmpScCmac &rArr; SecCmac &rArr; secCmacGenSubkey1 &rArr; SecLeEncryptCmd &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActStoreLescPin
<LI><a href="#[110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActPkCalcCb
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[f4]"></a>smprScActSendPubKey</STRONG> (Thumb, 24 bytes, Stack size 16 bytes, smpr_sc_act.o(i.smprScActSendPubKey))
<BR><BR>[Stack]<UL><LI>Max Depth = 336<LI>Call Chain = smprScActSendPubKey &rArr; smpScSendPubKey &rArr; smpSendPkt &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendPubKey
<LI><a href="#[419]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActAuthSelect
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[117]"></a>smprScActStoreDhCheck</STRONG> (Thumb, 36 bytes, Stack size 16 bytes, smpr_sc_act.o(i.smprScActStoreDhCheck))
<BR><BR>[Stack]<UL><LI>Max Depth = 28<LI>Call Chain = smprScActStoreDhCheck &rArr; WStrReverseCpy
</UL>
<BR>[Calls]<UL><LI><a href="#[2bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WStrReverseCpy
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[f6]"></a>smprScActStoreLescPin</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, smpr_sc_act.o(i.smprScActStoreLescPin))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = smprScActStoreLescPin &rArr; Calc128Cpy
</UL>
<BR>[Calls]<UL><LI><a href="#[206]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Calc128Cpy
<LI><a href="#[2bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WStrReverseCpy
</UL>
<BR>[Called By]<UL><LI><a href="#[10f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smprScActPkStorePinAndCalcCb
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[118]"></a>smprScActWaitDhCheck</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, smpr_sc_act.o(i.smprScActWaitDhCheck))
<BR><BR>[Stack]<UL><LI>Max Depth = 336<LI>Call Chain = smprScActWaitDhCheck &rArr; smpScSendRand &rArr; smpSendPkt &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[425]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScSendRand
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smpr_sc_sm.o(.constdata)
</UL>
<P><STRONG><a name="[2b3]"></a>uECC_make_key</STRONG> (Thumb, 76 bytes, Stack size 112 bytes, uecc.o(i.uECC_make_key))
<BR><BR>[Stack]<UL><LI>Max Depth = 724<LI>Call Chain = uECC_make_key &rArr; EccPoint_compute_public_key &rArr; EccPoint_mult &rArr; XYcZ_initial_double &rArr; EccPoint_double_jacobian &rArr; vli_modSquare_fast &rArr; vli_square &rArr; mul2add
</UL>
<BR>[Calls]<UL><LI><a href="#[429]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_nativeToBytes
<LI><a href="#[238]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EccPoint_compute_public_key
</UL>
<BR>[Called By]<UL><LI><a href="#[234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecEccGenKey
</UL>

<P><STRONG><a name="[2b8]"></a>uECC_set_rng</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, uecc.o(i.uECC_set_rng))
<BR><BR>[Called By]<UL><LI><a href="#[2b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecEccInit
</UL>

<P><STRONG><a name="[2b6]"></a>uECC_shared_secret</STRONG> (Thumb, 168 bytes, Stack size 264 bytes, uecc.o(i.uECC_shared_secret))
<BR><BR>[Stack]<UL><LI>Max Depth = 780<LI>Call Chain = uECC_shared_secret &rArr; EccPoint_mult &rArr; XYcZ_initial_double &rArr; EccPoint_double_jacobian &rArr; vli_modSquare_fast &rArr; vli_square &rArr; mul2add
</UL>
<BR>[Calls]<UL><LI><a href="#[429]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_nativeToBytes
<LI><a href="#[239]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_isZero
<LI><a href="#[42a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_bytesToNative
<LI><a href="#[23b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_add
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EccPoint_mult
<LI><a href="#[23d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EccPoint_isZero
</UL>
<BR>[Called By]<UL><LI><a href="#[2b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecEccGenSharedSecret
</UL>

<P><STRONG><a name="[2b5]"></a>uECC_valid_public_key</STRONG> (Thumb, 100 bytes, Stack size 136 bytes, uecc.o(i.uECC_valid_public_key))
<BR><BR>[Stack]<UL><LI>Max Depth = 356<LI>Call Chain = uECC_valid_public_key &rArr; curve_x_side &rArr; vli_modSquare_fast &rArr; vli_square &rArr; mul2add
</UL>
<BR>[Calls]<UL><LI><a href="#[23f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modSquare_fast
<LI><a href="#[23a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_cmp
<LI><a href="#[42a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_bytesToNative
<LI><a href="#[383]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;curve_x_side
<LI><a href="#[23d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EccPoint_isZero
</UL>
<BR>[Called By]<UL><LI><a href="#[2b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecEccGenSharedSecret
</UL>

<P><STRONG><a name="[3d7]"></a>uxListRemove</STRONG> (Thumb, 40 bytes, Stack size 0 bytes, list.o(i.uxListRemove))
<BR><BR>[Called By]<UL><LI><a href="#[2d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskIncrementTick
<LI><a href="#[405]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspend
<LI><a href="#[3f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvSwitchTimerLists
<LI><a href="#[3f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvProcessReceivedCommands
<LI><a href="#[3f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvProcessExpiredTimer
<LI><a href="#[3d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvAddCurrentTaskToDelayedList
<LI><a href="#[3fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskRemoveFromEventList
<LI><a href="#[439]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskRemoveFromUnorderedEventList
<LI><a href="#[3e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeAll
</UL>

<P><STRONG><a name="[447]"></a>uxTaskResetEventItemValue</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, tasks.o(i.uxTaskResetEventItemValue))
<BR><BR>[Called By]<UL><LI><a href="#[444]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xEventGroupWaitBits
</UL>

<P><STRONG><a name="[3ff]"></a>vApplicationMallocFailedHook</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, rtos.o(i.vApplicationMallocFailedHook))
<BR><BR>[Called By]<UL><LI><a href="#[3fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pvPortMalloc
</UL>

<P><STRONG><a name="[43d]"></a>vApplicationStackOverflowHook</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, rtos.o(i.vApplicationStackOverflowHook))
<BR><BR>[Called By]<UL><LI><a href="#[13b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSwitchContext
</UL>

<P><STRONG><a name="[5c]"></a>vEventGroupSetBitsCallback</STRONG> (Thumb, 16 bytes, Stack size 16 bytes, event_groups.o(i.vEventGroupSetBitsCallback))
<BR><BR>[Stack]<UL><LI>Max Depth = 104<LI>Call Chain = vEventGroupSetBitsCallback &rArr; xEventGroupSetBits &rArr; xTaskResumeAll &rArr; xTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[2e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xEventGroupSetBits
</UL>
<BR>[Address Reference Count : 1]<UL><LI> wsf_os.o(i.WsfSetOsSpecificEvent)
</UL>
<P><STRONG><a name="[3df]"></a>vListInitialise</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, list.o(i.vListInitialise))
<BR><BR>[Called By]<UL><LI><a href="#[2df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xEventGroupCreate
<LI><a href="#[3de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvCheckForValidListAndQueue
<LI><a href="#[3dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvInitialiseTaskLists
<LI><a href="#[3e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericReset
</UL>

<P><STRONG><a name="[3eb]"></a>vListInitialiseItem</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, list.o(i.vListInitialiseItem))
<BR><BR>[Called By]<UL><LI><a href="#[3ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvInitialiseNewTimer
<LI><a href="#[3ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvInitialiseNewTask
</UL>

<P><STRONG><a name="[3d9]"></a>vListInsert</STRONG> (Thumb, 52 bytes, Stack size 8 bytes, list.o(i.vListInsert))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = vListInsert
</UL>
<BR>[Called By]<UL><LI><a href="#[3f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvSwitchTimerLists
<LI><a href="#[3ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvInsertTimerInActiveList
<LI><a href="#[3d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvAddCurrentTaskToDelayedList
<LI><a href="#[437]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskPlaceOnEventList
</UL>

<P><STRONG><a name="[3d8]"></a>vListInsertEnd</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, list.o(i.vListInsertEnd))
<BR><BR>[Called By]<UL><LI><a href="#[2d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskIncrementTick
<LI><a href="#[405]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspend
<LI><a href="#[3da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvAddNewTaskToReadyList
<LI><a href="#[3d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvAddCurrentTaskToDelayedList
<LI><a href="#[3fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskRemoveFromEventList
<LI><a href="#[436]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskPlaceOnEventListRestricted
<LI><a href="#[439]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskRemoveFromUnorderedEventList
<LI><a href="#[438]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskPlaceOnUnorderedEventList
<LI><a href="#[3e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeAll
</UL>

<P><STRONG><a name="[3db]"></a>vPortEnterCritical</STRONG> (Thumb, 58 bytes, Stack size 0 bytes, port.o(i.vPortEnterCritical))
<BR><BR>[Called By]<UL><LI><a href="#[444]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xEventGroupWaitBits
<LI><a href="#[405]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspend
<LI><a href="#[3de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvCheckForValidListAndQueue
<LI><a href="#[3da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvAddNewTaskToReadyList
<LI><a href="#[44c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskCheckForTimeOut
<LI><a href="#[3f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueReceive
<LI><a href="#[44a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSend
<LI><a href="#[3e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericReset
<LI><a href="#[3f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vQueueWaitForMessageRestricted
<LI><a href="#[3fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvUnlockQueue
<LI><a href="#[3f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvIsQueueFull
<LI><a href="#[3ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvIsQueueEmpty
<LI><a href="#[3e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeAll
</UL>

<P><STRONG><a name="[3dd]"></a>vPortExitCritical</STRONG> (Thumb, 38 bytes, Stack size 0 bytes, port.o(i.vPortExitCritical))
<BR><BR>[Called By]<UL><LI><a href="#[444]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xEventGroupWaitBits
<LI><a href="#[405]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspend
<LI><a href="#[3de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvCheckForValidListAndQueue
<LI><a href="#[3da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvAddNewTaskToReadyList
<LI><a href="#[44c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskCheckForTimeOut
<LI><a href="#[3f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueReceive
<LI><a href="#[44a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSend
<LI><a href="#[3e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericReset
<LI><a href="#[3f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vQueueWaitForMessageRestricted
<LI><a href="#[3fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvUnlockQueue
<LI><a href="#[3f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvIsQueueFull
<LI><a href="#[3ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvIsQueueEmpty
<LI><a href="#[3e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeAll
</UL>

<P><STRONG><a name="[3f4]"></a>vPortFree</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, heap_2.o(i.vPortFree))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = vPortFree &rArr; xTaskResumeAll &rArr; xTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[3e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeAll
<LI><a href="#[3e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspendAll
</UL>
<BR>[Called By]<UL><LI><a href="#[400]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskCreate
<LI><a href="#[3f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvProcessReceivedCommands
</UL>

<P><STRONG><a name="[42b]"></a>vPortSetupTimerInterrupt</STRONG> (Thumb, 118 bytes, Stack size 8 bytes, port.o(i.vPortSetupTimerInterrupt))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = vPortSetupTimerInterrupt &rArr; am_hal_stimer_compare_delta_set
</UL>
<BR>[Calls]<UL><LI><a href="#[42c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_stimer_int_enable
<LI><a href="#[430]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_stimer_counter_get
<LI><a href="#[42f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_stimer_config
<LI><a href="#[31a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_stimer_compare_delta_set
<LI><a href="#[42d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__NVIC_SetPriority
<LI><a href="#[42e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__NVIC_EnableIRQ
</UL>
<BR>[Called By]<UL><LI><a href="#[43b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xPortStartScheduler
</UL>

<P><STRONG><a name="[3e6]"></a>vPortSuppressTicksAndSleep</STRONG> (Thumb, 204 bytes, Stack size 32 bytes, port.o(i.vPortSuppressTicksAndSleep))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = vPortSuppressTicksAndSleep &rArr; am_hal_stimer_compare_delta_set
</UL>
<BR>[Calls]<UL><LI><a href="#[433]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskStepTick
<LI><a href="#[431]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;eTaskConfirmSleepModeStatus
<LI><a href="#[31e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_stimer_int_clear
<LI><a href="#[430]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_stimer_counter_get
<LI><a href="#[31a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_stimer_compare_delta_set
<LI><a href="#[432]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_freertos_wakeup
<LI><a href="#[302]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_freertos_sleep
</UL>
<BR>[Called By]<UL><LI><a href="#[6d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvIdleTask
</UL>

<P><STRONG><a name="[434]"></a>vPortValidateInterruptPriority</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, port.o(i.vPortValidateInterruptPriority))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = vPortValidateInterruptPriority
</UL>
<BR>[Calls]<UL><LI><a href="#[435]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortGetIPSR
</UL>
<BR>[Called By]<UL><LI><a href="#[44d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSendFromISR
</UL>

<P><STRONG><a name="[3f7]"></a>vQueueWaitForMessageRestricted</STRONG> (Thumb, 74 bytes, Stack size 24 bytes, queue.o(i.vQueueWaitForMessageRestricted))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = vQueueWaitForMessageRestricted &rArr; vTaskPlaceOnEventListRestricted &rArr; prvAddCurrentTaskToDelayedList &rArr; vListInsert
</UL>
<BR>[Calls]<UL><LI><a href="#[3dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[3db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
<LI><a href="#[436]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskPlaceOnEventListRestricted
<LI><a href="#[3fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvUnlockQueue
</UL>
<BR>[Called By]<UL><LI><a href="#[3f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvProcessTimerOrBlockTask
</UL>

<P><STRONG><a name="[44b]"></a>vTaskInternalSetTimeOutState</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, tasks.o(i.vTaskInternalSetTimeOutState))
<BR><BR>[Called By]<UL><LI><a href="#[44c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskCheckForTimeOut
<LI><a href="#[3f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueReceive
<LI><a href="#[44a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSend
</UL>

<P><STRONG><a name="[3fc]"></a>vTaskMissedYield</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, tasks.o(i.vTaskMissedYield))
<BR><BR>[Called By]<UL><LI><a href="#[3fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvUnlockQueue
</UL>

<P><STRONG><a name="[437]"></a>vTaskPlaceOnEventList</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, tasks.o(i.vTaskPlaceOnEventList))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = vTaskPlaceOnEventList &rArr; prvAddCurrentTaskToDelayedList &rArr; vListInsert
</UL>
<BR>[Calls]<UL><LI><a href="#[3d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvAddCurrentTaskToDelayedList
<LI><a href="#[3d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInsert
</UL>
<BR>[Called By]<UL><LI><a href="#[3f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueReceive
<LI><a href="#[44a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSend
</UL>

<P><STRONG><a name="[436]"></a>vTaskPlaceOnEventListRestricted</STRONG> (Thumb, 42 bytes, Stack size 16 bytes, tasks.o(i.vTaskPlaceOnEventListRestricted))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = vTaskPlaceOnEventListRestricted &rArr; prvAddCurrentTaskToDelayedList &rArr; vListInsert
</UL>
<BR>[Calls]<UL><LI><a href="#[3d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvAddCurrentTaskToDelayedList
<LI><a href="#[3d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInsertEnd
</UL>
<BR>[Called By]<UL><LI><a href="#[3f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vQueueWaitForMessageRestricted
</UL>

<P><STRONG><a name="[438]"></a>vTaskPlaceOnUnorderedEventList</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, tasks.o(i.vTaskPlaceOnUnorderedEventList))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = vTaskPlaceOnUnorderedEventList &rArr; prvAddCurrentTaskToDelayedList &rArr; vListInsert
</UL>
<BR>[Calls]<UL><LI><a href="#[3d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvAddCurrentTaskToDelayedList
<LI><a href="#[3d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInsertEnd
</UL>
<BR>[Called By]<UL><LI><a href="#[444]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xEventGroupWaitBits
</UL>

<P><STRONG><a name="[439]"></a>vTaskRemoveFromUnorderedEventList</STRONG> (Thumb, 104 bytes, Stack size 16 bytes, tasks.o(i.vTaskRemoveFromUnorderedEventList))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = vTaskRemoveFromUnorderedEventList
</UL>
<BR>[Calls]<UL><LI><a href="#[3d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInsertEnd
<LI><a href="#[3d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uxListRemove
</UL>
<BR>[Called By]<UL><LI><a href="#[2e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xEventGroupSetBits
</UL>

<P><STRONG><a name="[401]"></a>vTaskStartScheduler</STRONG> (Thumb, 102 bytes, Stack size 16 bytes, tasks.o(i.vTaskStartScheduler))
<BR><BR>[Stack]<UL><LI>Max Depth = 168 + Unknown Stack Size
<LI>Call Chain = vTaskStartScheduler &rArr; xTimerCreateTimerTask &rArr; xTaskCreate &rArr; pvPortMalloc &rArr; xTaskResumeAll &rArr; xTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[43b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xPortStartScheduler
<LI><a href="#[400]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskCreate
<LI><a href="#[43a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTimerCreateTimerTask
</UL>
<BR>[Called By]<UL><LI><a href="#[3d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;run_tasks
</UL>

<P><STRONG><a name="[433]"></a>vTaskStepTick</STRONG> (Thumb, 38 bytes, Stack size 0 bytes, tasks.o(i.vTaskStepTick))
<BR><BR>[Called By]<UL><LI><a href="#[3e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortSuppressTicksAndSleep
</UL>

<P><STRONG><a name="[405]"></a>vTaskSuspend</STRONG> (Thumb, 158 bytes, Stack size 16 bytes, tasks.o(i.vTaskSuspend))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = vTaskSuspend &rArr; vTaskSwitchContext
</UL>
<BR>[Calls]<UL><LI><a href="#[3dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[3db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
<LI><a href="#[13b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSwitchContext
<LI><a href="#[43c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvResetNextTaskUnblockTime
<LI><a href="#[3d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInsertEnd
<LI><a href="#[3d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uxListRemove
</UL>
<BR>[Called By]<UL><LI><a href="#[6b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;setup_task
</UL>

<P><STRONG><a name="[3e5]"></a>vTaskSuspendAll</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, tasks.o(i.vTaskSuspendAll))
<BR><BR>[Called By]<UL><LI><a href="#[444]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xEventGroupWaitBits
<LI><a href="#[2e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xEventGroupSetBits
<LI><a href="#[3f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvProcessTimerOrBlockTask
<LI><a href="#[6d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvIdleTask
<LI><a href="#[3f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueReceive
<LI><a href="#[44a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSend
<LI><a href="#[3f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortFree
<LI><a href="#[3fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pvPortMalloc
</UL>

<P><STRONG><a name="[13b]"></a>vTaskSwitchContext</STRONG> (Thumb, 160 bytes, Stack size 16 bytes, tasks.o(i.vTaskSwitchContext))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = vTaskSwitchContext
</UL>
<BR>[Calls]<UL><LI><a href="#[43d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vApplicationStackOverflowHook
</UL>
<BR>[Called By]<UL><LI><a href="#[18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PendSV_Handler
<LI><a href="#[405]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspend
</UL>

<P><STRONG><a name="[2ab]"></a>wsfOsDispatcher</STRONG> (Thumb, 198 bytes, Stack size 40 bytes, wsf_os.o(i.wsfOsDispatcher))
<BR><BR>[Stack]<UL><LI>Max Depth = 224<LI>Call Chain = wsfOsDispatcher &rArr; WsfTimerUpdateTicks &rArr; xTimerGenericCommand &rArr; xQueueGenericSend &rArr; vTaskPlaceOnEventList &rArr; prvAddCurrentTaskToDelayedList &rArr; vListInsert
</UL>
<BR>[Calls]<UL><LI><a href="#[1cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgFree
<LI><a href="#[257]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgDeq
<LI><a href="#[444]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xEventGroupWaitBits
<LI><a href="#[2ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerUpdateTicks
<LI><a href="#[2e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerServiceExpired
<LI><a href="#[2d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfCsExit
<LI><a href="#[2d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfCsEnter
</UL>
<BR>[Called By]<UL><LI><a href="#[6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioTask
</UL>

<P><STRONG><a name="[2df]"></a>xEventGroupCreate</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, event_groups.o(i.xEventGroupCreate))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = xEventGroupCreate &rArr; pvPortMalloc &rArr; xTaskResumeAll &rArr; xTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[3df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInitialise
<LI><a href="#[3fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pvPortMalloc
</UL>
<BR>[Called By]<UL><LI><a href="#[2de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfOsInit
</UL>

<P><STRONG><a name="[2e5]"></a>xEventGroupSetBits</STRONG> (Thumb, 170 bytes, Stack size 48 bytes, event_groups.o(i.xEventGroupSetBits))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = xEventGroupSetBits &rArr; xTaskResumeAll &rArr; xTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[439]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskRemoveFromUnorderedEventList
<LI><a href="#[3e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeAll
<LI><a href="#[3e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspendAll
</UL>
<BR>[Called By]<UL><LI><a href="#[5c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vEventGroupSetBitsCallback
<LI><a href="#[2e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfSetOsSpecificEvent
</UL>

<P><STRONG><a name="[444]"></a>xEventGroupWaitBits</STRONG> (Thumb, 266 bytes, Stack size 64 bytes, event_groups.o(i.xEventGroupWaitBits))
<BR><BR>[Stack]<UL><LI>Max Depth = 112<LI>Call Chain = xEventGroupWaitBits &rArr; vTaskPlaceOnUnorderedEventList &rArr; prvAddCurrentTaskToDelayedList &rArr; vListInsert
</UL>
<BR>[Calls]<UL><LI><a href="#[3dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[3db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
<LI><a href="#[445]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskGetSchedulerState
<LI><a href="#[438]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskPlaceOnUnorderedEventList
<LI><a href="#[447]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uxTaskResetEventItemValue
<LI><a href="#[446]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvTestWaitCondition
<LI><a href="#[3e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeAll
<LI><a href="#[3e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspendAll
</UL>
<BR>[Called By]<UL><LI><a href="#[2ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wsfOsDispatcher
</UL>

<P><STRONG><a name="[43b]"></a>xPortStartScheduler</STRONG> (Thumb, 258 bytes, Stack size 16 bytes, port.o(i.xPortStartScheduler))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = xPortStartScheduler &rArr; vPortSetupTimerInterrupt &rArr; am_hal_stimer_compare_delta_set
</UL>
<BR>[Calls]<UL><LI><a href="#[42b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortSetupTimerInterrupt
<LI><a href="#[448]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___6_port_c_39a90d8d__prvEnableVFP
<LI><a href="#[449]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__asm___6_port_c_39a90d8d__prvStartFirstTask
</UL>
<BR>[Called By]<UL><LI><a href="#[401]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskStartScheduler
</UL>

<P><STRONG><a name="[31f]"></a>xPortStimerTickHandler</STRONG> (Thumb, 148 bytes, Stack size 32 bytes, port.o(i.xPortStimerTickHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = xPortStimerTickHandler &rArr; am_hal_stimer_compare_delta_set
</UL>
<BR>[Calls]<UL><LI><a href="#[430]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_stimer_counter_get
<LI><a href="#[31a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_stimer_compare_delta_set
<LI><a href="#[2d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskIncrementTick
</UL>
<BR>[Called By]<UL><LI><a href="#[32]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_stimer_cmpr1_isr
<LI><a href="#[31]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_stimer_cmpr0_isr
</UL>

<P><STRONG><a name="[3e0]"></a>xQueueGenericCreate</STRONG> (Thumb, 72 bytes, Stack size 32 bytes, queue.o(i.xQueueGenericCreate))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = xQueueGenericCreate &rArr; pvPortMalloc &rArr; xTaskResumeAll &rArr; xTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[3e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvInitialiseNewQueue
<LI><a href="#[3fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pvPortMalloc
</UL>
<BR>[Called By]<UL><LI><a href="#[3de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvCheckForValidListAndQueue
</UL>

<P><STRONG><a name="[3e9]"></a>xQueueGenericReset</STRONG> (Thumb, 128 bytes, Stack size 16 bytes, queue.o(i.xQueueGenericReset))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = xQueueGenericReset &rArr; xTaskRemoveFromEventList
</UL>
<BR>[Calls]<UL><LI><a href="#[3dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[3db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
<LI><a href="#[3fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskRemoveFromEventList
<LI><a href="#[3df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInitialise
</UL>
<BR>[Called By]<UL><LI><a href="#[3e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvInitialiseNewQueue
</UL>

<P><STRONG><a name="[44a]"></a>xQueueGenericSend</STRONG> (Thumb, 348 bytes, Stack size 56 bytes, queue.o(i.xQueueGenericSend))
<BR><BR>[Stack]<UL><LI>Max Depth = 104<LI>Call Chain = xQueueGenericSend &rArr; vTaskPlaceOnEventList &rArr; prvAddCurrentTaskToDelayedList &rArr; vListInsert
</UL>
<BR>[Calls]<UL><LI><a href="#[3dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[3db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
<LI><a href="#[3fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskRemoveFromEventList
<LI><a href="#[44c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskCheckForTimeOut
<LI><a href="#[437]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskPlaceOnEventList
<LI><a href="#[44b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskInternalSetTimeOutState
<LI><a href="#[3fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvUnlockQueue
<LI><a href="#[3f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvIsQueueFull
<LI><a href="#[3e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvCopyDataToQueue
<LI><a href="#[445]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskGetSchedulerState
<LI><a href="#[3e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeAll
<LI><a href="#[3e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspendAll
</UL>
<BR>[Called By]<UL><LI><a href="#[2ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTimerGenericCommand
</UL>

<P><STRONG><a name="[44d]"></a>xQueueGenericSendFromISR</STRONG> (Thumb, 194 bytes, Stack size 40 bytes, queue.o(i.xQueueGenericSendFromISR))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[434]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortValidateInterruptPriority
<LI><a href="#[3fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskRemoveFromEventList
<LI><a href="#[3e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvCopyDataToQueue
</UL>
<BR>[Called By]<UL><LI><a href="#[2ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTimerGenericCommand
<LI><a href="#[2e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTimerPendFunctionCallFromISR
</UL>

<P><STRONG><a name="[3f5]"></a>xQueueReceive</STRONG> (Thumb, 302 bytes, Stack size 48 bytes, queue.o(i.xQueueReceive))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = xQueueReceive &rArr; vTaskPlaceOnEventList &rArr; prvAddCurrentTaskToDelayedList &rArr; vListInsert
</UL>
<BR>[Calls]<UL><LI><a href="#[3dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[3db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
<LI><a href="#[3fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskRemoveFromEventList
<LI><a href="#[44c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskCheckForTimeOut
<LI><a href="#[437]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskPlaceOnEventList
<LI><a href="#[44b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskInternalSetTimeOutState
<LI><a href="#[3fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvUnlockQueue
<LI><a href="#[3ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvIsQueueEmpty
<LI><a href="#[3e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvCopyDataFromQueue
<LI><a href="#[445]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskGetSchedulerState
<LI><a href="#[3e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeAll
<LI><a href="#[3e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspendAll
</UL>
<BR>[Called By]<UL><LI><a href="#[3f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvProcessReceivedCommands
</UL>

<P><STRONG><a name="[44c]"></a>xTaskCheckForTimeOut</STRONG> (Thumb, 96 bytes, Stack size 16 bytes, tasks.o(i.xTaskCheckForTimeOut))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = xTaskCheckForTimeOut
</UL>
<BR>[Calls]<UL><LI><a href="#[3dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[3db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
<LI><a href="#[44b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskInternalSetTimeOutState
</UL>
<BR>[Called By]<UL><LI><a href="#[3f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueReceive
<LI><a href="#[44a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSend
</UL>

<P><STRONG><a name="[400]"></a>xTaskCreate</STRONG> (Thumb, 96 bytes, Stack size 72 bytes, tasks.o(i.xTaskCreate))
<BR><BR>[Stack]<UL><LI>Max Depth = 136 + Unknown Stack Size
<LI>Call Chain = xTaskCreate &rArr; pvPortMalloc &rArr; xTaskResumeAll &rArr; xTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[3ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvInitialiseNewTask
<LI><a href="#[3da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvAddNewTaskToReadyList
<LI><a href="#[3f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortFree
<LI><a href="#[3fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pvPortMalloc
</UL>
<BR>[Called By]<UL><LI><a href="#[401]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskStartScheduler
<LI><a href="#[6b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;setup_task
<LI><a href="#[3d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;run_tasks
<LI><a href="#[43a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTimerCreateTimerTask
</UL>

<P><STRONG><a name="[445]"></a>xTaskGetSchedulerState</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, tasks.o(i.xTaskGetSchedulerState))
<BR><BR>[Called By]<UL><LI><a href="#[2ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTimerGenericCommand
<LI><a href="#[444]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xEventGroupWaitBits
<LI><a href="#[3f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueReceive
<LI><a href="#[44a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSend
</UL>

<P><STRONG><a name="[2ee]"></a>xTaskGetTickCount</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, tasks.o(i.xTaskGetTickCount))
<BR><BR>[Called By]<UL><LI><a href="#[2ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerUpdateTicks
<LI><a href="#[3f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvSampleTimeNow
</UL>

<P><STRONG><a name="[2d6]"></a>xTaskIncrementTick</STRONG> (Thumb, 236 bytes, Stack size 24 bytes, tasks.o(i.xTaskIncrementTick))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = xTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[43c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvResetNextTaskUnblockTime
<LI><a href="#[3d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInsertEnd
<LI><a href="#[3d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uxListRemove
</UL>
<BR>[Called By]<UL><LI><a href="#[31f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xPortStimerTickHandler
<LI><a href="#[19]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTick_Handler
<LI><a href="#[3e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeAll
</UL>

<P><STRONG><a name="[3fb]"></a>xTaskRemoveFromEventList</STRONG> (Thumb, 112 bytes, Stack size 16 bytes, tasks.o(i.xTaskRemoveFromEventList))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = xTaskRemoveFromEventList
</UL>
<BR>[Calls]<UL><LI><a href="#[43c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvResetNextTaskUnblockTime
<LI><a href="#[3d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInsertEnd
<LI><a href="#[3d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uxListRemove
</UL>
<BR>[Called By]<UL><LI><a href="#[3f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueReceive
<LI><a href="#[44d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSendFromISR
<LI><a href="#[44a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSend
<LI><a href="#[3e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericReset
<LI><a href="#[3fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvUnlockQueue
</UL>

<P><STRONG><a name="[3e7]"></a>xTaskResumeAll</STRONG> (Thumb, 204 bytes, Stack size 16 bytes, tasks.o(i.xTaskResumeAll))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = xTaskResumeAll &rArr; xTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[3dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[3db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
<LI><a href="#[2d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskIncrementTick
<LI><a href="#[43c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvResetNextTaskUnblockTime
<LI><a href="#[3d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInsertEnd
<LI><a href="#[3d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uxListRemove
</UL>
<BR>[Called By]<UL><LI><a href="#[444]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xEventGroupWaitBits
<LI><a href="#[2e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xEventGroupSetBits
<LI><a href="#[3f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvProcessTimerOrBlockTask
<LI><a href="#[6d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvIdleTask
<LI><a href="#[3f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueReceive
<LI><a href="#[44a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSend
<LI><a href="#[3f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortFree
<LI><a href="#[3fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pvPortMalloc
</UL>

<P><STRONG><a name="[2e7]"></a>xTimerCreate</STRONG> (Thumb, 48 bytes, Stack size 40 bytes, timers.o(i.xTimerCreate))
<BR><BR>[Stack]<UL><LI>Max Depth = 176<LI>Call Chain = xTimerCreate &rArr; prvInitialiseNewTimer &rArr; prvCheckForValidListAndQueue &rArr; xQueueGenericCreate &rArr; pvPortMalloc &rArr; xTaskResumeAll &rArr; xTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[3ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvInitialiseNewTimer
<LI><a href="#[3fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pvPortMalloc
</UL>
<BR>[Called By]<UL><LI><a href="#[2e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerInit
</UL>

<P><STRONG><a name="[43a]"></a>xTimerCreateTimerTask</STRONG> (Thumb, 48 bytes, Stack size 16 bytes, timers.o(i.xTimerCreateTimerTask))
<BR><BR>[Stack]<UL><LI>Max Depth = 152 + Unknown Stack Size
<LI>Call Chain = xTimerCreateTimerTask &rArr; xTaskCreate &rArr; pvPortMalloc &rArr; xTaskResumeAll &rArr; xTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[400]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskCreate
<LI><a href="#[3de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvCheckForValidListAndQueue
</UL>
<BR>[Called By]<UL><LI><a href="#[401]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskStartScheduler
</UL>

<P><STRONG><a name="[2ef]"></a>xTimerGenericCommand</STRONG> (Thumb, 110 bytes, Stack size 48 bytes, timers.o(i.xTimerGenericCommand))
<BR><BR>[Stack]<UL><LI>Max Depth = 152<LI>Call Chain = xTimerGenericCommand &rArr; xQueueGenericSend &rArr; vTaskPlaceOnEventList &rArr; prvAddCurrentTaskToDelayedList &rArr; vListInsert
</UL>
<BR>[Calls]<UL><LI><a href="#[44d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSendFromISR
<LI><a href="#[44a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSend
<LI><a href="#[445]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskGetSchedulerState
</UL>
<BR>[Called By]<UL><LI><a href="#[2ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerUpdateTicks
<LI><a href="#[3f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvSwitchTimerLists
<LI><a href="#[3f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvProcessReceivedCommands
<LI><a href="#[3f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvProcessExpiredTimer
</UL>

<P><STRONG><a name="[2e4]"></a>xTimerPendFunctionCallFromISR</STRONG> (Thumb, 48 bytes, Stack size 40 bytes, timers.o(i.xTimerPendFunctionCallFromISR))
<BR><BR>[Stack]<UL><LI>Max Depth = 104<LI>Call Chain = xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[44d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSendFromISR
</UL>
<BR>[Called By]<UL><LI><a href="#[2e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfSetOsSpecificEvent
</UL>

<P><STRONG><a name="[32b]"></a>__aeabi_d2f</STRONG> (Thumb, 0 bytes, Stack size 32 bytes, d2f.o(x$fpl$d2f))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = __aeabi_d2f
</UL>
<BR>[Called By]<UL><LI><a href="#[322]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_vsprintf
</UL>

<P><STRONG><a name="[44e]"></a>_d2f</STRONG> (Thumb, 98 bytes, Stack size 32 bytes, d2f.o(x$fpl$d2f), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[44f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fretinf
<LI><a href="#[450]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dnaninf
</UL>

<P><STRONG><a name="[450]"></a>__fpl_dnaninf</STRONG> (Thumb, 156 bytes, Stack size 16 bytes, dnaninf.o(x$fpl$dnaninf), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[44e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_d2f
</UL>

<P><STRONG><a name="[12f]"></a>_fp_init</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, fpinit.o(x$fpl$fpinit))
<BR><BR>[Called By]<UL><LI><a href="#[12e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init_fp_1
</UL>

<P><STRONG><a name="[484]"></a>__fplib_config_fpu_vfp</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, fpinit.o(x$fpl$fpinit), UNUSED)

<P><STRONG><a name="[485]"></a>__fplib_config_pureend_doubles</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, fpinit.o(x$fpl$fpinit), UNUSED)

<P><STRONG><a name="[44f]"></a>__fpl_fretinf</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, fretinf.o(x$fpl$fretinf), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[44e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_d2f
</UL>
<P>
<H3>
Local Symbols
</H3>
<P><STRONG><a name="[3bc]"></a>hciCoreConnAlloc</STRONG> (Thumb, 46 bytes, Stack size 8 bytes, hci_core.o(i.hciCoreConnAlloc))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = hciCoreConnAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[3bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreConnOpen
</UL>

<P><STRONG><a name="[3ba]"></a>hciCoreConnFree</STRONG> (Thumb, 76 bytes, Stack size 16 bytes, hci_core.o(i.hciCoreConnFree))
<BR><BR>[Stack]<UL><LI>Max Depth = 280<LI>Call Chain = hciCoreConnFree &rArr; hciCoreTxReady &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[298]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreTxReady
<LI><a href="#[1cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgFree
</UL>
<BR>[Called By]<UL><LI><a href="#[3b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreConnClose
</UL>

<P><STRONG><a name="[3c6]"></a>hciCoreNextConnFragment</STRONG> (Thumb, 38 bytes, Stack size 0 bytes, hci_core.o(i.hciCoreNextConnFragment))
<BR><BR>[Called By]<UL><LI><a href="#[3c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreTxAclContinue
</UL>

<P><STRONG><a name="[95]"></a>hciEvtParseAuthTimeoutExpiredEvt</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, hci_evt.o(i.hciEvtParseAuthTimeoutExpiredEvt))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = hciEvtParseAuthTimeoutExpiredEvt
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[91]"></a>hciEvtParseDataLenChange</STRONG> (Thumb, 68 bytes, Stack size 8 bytes, hci_evt.o(i.hciEvtParseDataLenChange))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = hciEvtParseDataLenChange
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[71]"></a>hciEvtParseDisconnectCmpl</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, hci_evt.o(i.hciEvtParseDisconnectCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = hciEvtParseDisconnectCmpl
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[7c]"></a>hciEvtParseEncChange</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, hci_evt.o(i.hciEvtParseEncChange))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = hciEvtParseEncChange
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[7b]"></a>hciEvtParseEncKeyRefreshCmpl</STRONG> (Thumb, 30 bytes, Stack size 8 bytes, hci_evt.o(i.hciEvtParseEncKeyRefreshCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = hciEvtParseEncKeyRefreshCmpl
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[93]"></a>hciEvtParseGenDhKeyCmdCmpl</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, hci_evt.o(i.hciEvtParseGenDhKeyCmdCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = hciEvtParseGenDhKeyCmdCmpl
</UL>
<BR>[Calls]<UL><LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[81]"></a>hciEvtParseHwError</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, hci_evt.o(i.hciEvtParseHwError))
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[82]"></a>hciEvtParseLeAddDevToResListCmdCmpl</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, hci_evt.o(i.hciEvtParseLeAddDevToResListCmdCmpl))
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[9a]"></a>hciEvtParseLeAdvSetTerm</STRONG> (Thumb, 42 bytes, Stack size 8 bytes, hci_evt.o(i.hciEvtParseLeAdvSetTerm))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = hciEvtParseLeAdvSetTerm
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[84]"></a>hciEvtParseLeClearResListCmdCmpl</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, hci_evt.o(i.hciEvtParseLeClearResListCmdCmpl))
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[9e]"></a>hciEvtParseLeCmdCmpl</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, hci_evt.o(i.hciEvtParseLeCmdCmpl))
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[6f]"></a>hciEvtParseLeConnCmpl</STRONG> (Thumb, 120 bytes, Stack size 16 bytes, hci_evt.o(i.hciEvtParseLeConnCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = hciEvtParseLeConnCmpl
</UL>
<BR>[Calls]<UL><LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCpy
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[72]"></a>hciEvtParseLeConnUpdateCmpl</STRONG> (Thumb, 66 bytes, Stack size 8 bytes, hci_evt.o(i.hciEvtParseLeConnUpdateCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = hciEvtParseLeConnUpdateCmpl
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[73]"></a>hciEvtParseLeCreateConnCancelCmdCmpl</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, hci_evt.o(i.hciEvtParseLeCreateConnCancelCmdCmpl))
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[88]"></a>hciEvtParseLeEncryptCmdCmpl</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, hci_evt.o(i.hciEvtParseLeEncryptCmdCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = hciEvtParseLeEncryptCmdCmpl
</UL>
<BR>[Calls]<UL><LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[70]"></a>hciEvtParseLeEnhancedConnCmpl</STRONG> (Thumb, 126 bytes, Stack size 16 bytes, hci_evt.o(i.hciEvtParseLeEnhancedConnCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = hciEvtParseLeEnhancedConnCmpl
</UL>
<BR>[Calls]<UL><LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCpy
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[7d]"></a>hciEvtParseLeLtkReq</STRONG> (Thumb, 46 bytes, Stack size 8 bytes, hci_evt.o(i.hciEvtParseLeLtkReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = hciEvtParseLeLtkReq
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[7a]"></a>hciEvtParseLeLtkReqNegReplCmdCmpl</STRONG> (Thumb, 30 bytes, Stack size 8 bytes, hci_evt.o(i.hciEvtParseLeLtkReqNegReplCmdCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = hciEvtParseLeLtkReqNegReplCmdCmpl
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[79]"></a>hciEvtParseLeLtkReqReplCmdCmpl</STRONG> (Thumb, 30 bytes, Stack size 8 bytes, hci_evt.o(i.hciEvtParseLeLtkReqReplCmdCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = hciEvtParseLeLtkReqReplCmdCmpl
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[9c]"></a>hciEvtParseLePerAdvSyncEst</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, hci_evt.o(i.hciEvtParseLePerAdvSyncEst))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = hciEvtParseLePerAdvSyncEst
</UL>
<BR>[Calls]<UL><LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCpy
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[9d]"></a>hciEvtParseLePerAdvSyncLost</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, hci_evt.o(i.hciEvtParseLePerAdvSyncLost))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = hciEvtParseLePerAdvSyncLost
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[89]"></a>hciEvtParseLeRandCmdCmpl</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, hci_evt.o(i.hciEvtParseLeRandCmdCmpl))
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[86]"></a>hciEvtParseLeReadLocalResAddrCmdCmpl</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, hci_evt.o(i.hciEvtParseLeReadLocalResAddrCmdCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = hciEvtParseLeReadLocalResAddrCmdCmpl
</UL>
<BR>[Calls]<UL><LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCpy
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[85]"></a>hciEvtParseLeReadPeerResAddrCmdCmpl</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, hci_evt.o(i.hciEvtParseLeReadPeerResAddrCmdCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = hciEvtParseLeReadPeerResAddrCmdCmpl
</UL>
<BR>[Calls]<UL><LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCpy
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[83]"></a>hciEvtParseLeRemDevFromResListCmdCmpl</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, hci_evt.o(i.hciEvtParseLeRemDevFromResListCmdCmpl))
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[9b]"></a>hciEvtParseLeScanReqRcvd</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, hci_evt.o(i.hciEvtParseLeScanReqRcvd))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = hciEvtParseLeScanReqRcvd
</UL>
<BR>[Calls]<UL><LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCpy
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[99]"></a>hciEvtParseLeScanTimeout</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, hci_evt.o(i.hciEvtParseLeScanTimeout))
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[87]"></a>hciEvtParseLeSetAddrResEnableCmdCmpl</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, hci_evt.o(i.hciEvtParseLeSetAddrResEnableCmdCmpl))
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[98]"></a>hciEvtParsePhyUpdateCmpl</STRONG> (Thumb, 42 bytes, Stack size 8 bytes, hci_evt.o(i.hciEvtParsePhyUpdateCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = hciEvtParsePhyUpdateCmpl
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[75]"></a>hciEvtParseReadChanMapCmdCmpl</STRONG> (Thumb, 38 bytes, Stack size 8 bytes, hci_evt.o(i.hciEvtParseReadChanMapCmdCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = hciEvtParseReadChanMapCmdCmpl
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[8c]"></a>hciEvtParseReadDefDataLenCmdCmpl</STRONG> (Thumb, 38 bytes, Stack size 8 bytes, hci_evt.o(i.hciEvtParseReadDefDataLenCmdCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = hciEvtParseReadDefDataLenCmdCmpl
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[78]"></a>hciEvtParseReadLeRemoteFeatCmpl</STRONG> (Thumb, 38 bytes, Stack size 8 bytes, hci_evt.o(i.hciEvtParseReadLeRemoteFeatCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = hciEvtParseReadLeRemoteFeatCmpl
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[8f]"></a>hciEvtParseReadMaxDataLenCmdCmpl</STRONG> (Thumb, 62 bytes, Stack size 8 bytes, hci_evt.o(i.hciEvtParseReadMaxDataLenCmdCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = hciEvtParseReadMaxDataLenCmdCmpl
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[96]"></a>hciEvtParseReadPhyCmdCmpl</STRONG> (Thumb, 42 bytes, Stack size 8 bytes, hci_evt.o(i.hciEvtParseReadPhyCmdCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = hciEvtParseReadPhyCmdCmpl
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[92]"></a>hciEvtParseReadPubKeyCmdCmpl</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, hci_evt.o(i.hciEvtParseReadPubKeyCmdCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = hciEvtParseReadPubKeyCmdCmpl
</UL>
<BR>[Calls]<UL><LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[77]"></a>hciEvtParseReadRemoteVerInfoCmpl</STRONG> (Thumb, 60 bytes, Stack size 8 bytes, hci_evt.o(i.hciEvtParseReadRemoteVerInfoCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = hciEvtParseReadRemoteVerInfoCmpl
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[74]"></a>hciEvtParseReadRssiCmdCmpl</STRONG> (Thumb, 38 bytes, Stack size 8 bytes, hci_evt.o(i.hciEvtParseReadRssiCmdCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = hciEvtParseReadRssiCmdCmpl
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[76]"></a>hciEvtParseReadTxPwrLvlCmdCmpl</STRONG> (Thumb, 38 bytes, Stack size 8 bytes, hci_evt.o(i.hciEvtParseReadTxPwrLvlCmdCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = hciEvtParseReadTxPwrLvlCmdCmpl
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[8b]"></a>hciEvtParseRemConnParamNegRepCmdCmpl</STRONG> (Thumb, 30 bytes, Stack size 8 bytes, hci_evt.o(i.hciEvtParseRemConnParamNegRepCmdCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = hciEvtParseRemConnParamNegRepCmdCmpl
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[8a]"></a>hciEvtParseRemConnParamRepCmdCmpl</STRONG> (Thumb, 30 bytes, Stack size 8 bytes, hci_evt.o(i.hciEvtParseRemConnParamRepCmdCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = hciEvtParseRemConnParamRepCmdCmpl
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[90]"></a>hciEvtParseRemConnParamReq</STRONG> (Thumb, 68 bytes, Stack size 8 bytes, hci_evt.o(i.hciEvtParseRemConnParamReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = hciEvtParseRemConnParamReq
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[8e]"></a>hciEvtParseSetDataLenCmdCmpl</STRONG> (Thumb, 30 bytes, Stack size 8 bytes, hci_evt.o(i.hciEvtParseSetDataLenCmdCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = hciEvtParseSetDataLenCmdCmpl
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[97]"></a>hciEvtParseSetDefPhyCmdCmpl</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, hci_evt.o(i.hciEvtParseSetDefPhyCmdCmpl))
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[80]"></a>hciEvtParseVendorSpec</STRONG> (Thumb, 20 bytes, Stack size 16 bytes, hci_evt.o(i.hciEvtParseVendorSpec))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = hciEvtParseVendorSpec
</UL>
<BR>[Calls]<UL><LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[7f]"></a>hciEvtParseVendorSpecCmdCmpl</STRONG> (Thumb, 40 bytes, Stack size 16 bytes, hci_evt.o(i.hciEvtParseVendorSpecCmdCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = hciEvtParseVendorSpecCmdCmpl
</UL>
<BR>[Calls]<UL><LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[7e]"></a>hciEvtParseVendorSpecCmdStatus</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, hci_evt.o(i.hciEvtParseVendorSpecCmdStatus))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = hciEvtParseVendorSpecCmdStatus
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[94]"></a>hciEvtParseWriteAuthTimeoutCmdCmpl</STRONG> (Thumb, 30 bytes, Stack size 8 bytes, hci_evt.o(i.hciEvtParseWriteAuthTimeoutCmdCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = hciEvtParseWriteAuthTimeoutCmdCmpl
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[8d]"></a>hciEvtParseWriteDefDataLenCmdCmpl</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, hci_evt.o(i.hciEvtParseWriteDefDataLenCmdCmpl))
<BR>[Address Reference Count : 1]<UL><LI> hci_evt.o(.constdata)
</UL>
<P><STRONG><a name="[3cc]"></a>hciEvtProcessLeAdvReport</STRONG> (Thumb, 150 bytes, Stack size 24 bytes, hci_evt.o(i.hciEvtProcessLeAdvReport))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = hciEvtProcessLeAdvReport &rArr; WsfBufAlloc
</UL>
<BR>[Calls]<UL><LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCpy
<LI><a href="#[168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufFree
<LI><a href="#[16d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufAlloc
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[254]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessMsg
</UL>

<P><STRONG><a name="[3cd]"></a>hciEvtProcessLeDirectAdvReport</STRONG> (Thumb, 126 bytes, Stack size 24 bytes, hci_evt.o(i.hciEvtProcessLeDirectAdvReport))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = hciEvtProcessLeDirectAdvReport &rArr; WsfBufAlloc
</UL>
<BR>[Calls]<UL><LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCpy
<LI><a href="#[168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufFree
<LI><a href="#[16d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[254]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessMsg
</UL>

<P><STRONG><a name="[3ce]"></a>hciEvtProcessLeExtAdvReport</STRONG> (Thumb, 250 bytes, Stack size 32 bytes, hci_evt.o(i.hciEvtProcessLeExtAdvReport))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = hciEvtProcessLeExtAdvReport &rArr; WsfBufAlloc
</UL>
<BR>[Calls]<UL><LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCpy
<LI><a href="#[168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufFree
<LI><a href="#[16d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufAlloc
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[254]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessMsg
</UL>

<P><STRONG><a name="[3cf]"></a>hciEvtProcessLePerAdvReport</STRONG> (Thumb, 118 bytes, Stack size 24 bytes, hci_evt.o(i.hciEvtProcessLePerAdvReport))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = hciEvtProcessLePerAdvReport &rArr; WsfBufAlloc
</UL>
<BR>[Calls]<UL><LI><a href="#[168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufFree
<LI><a href="#[16d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufAlloc
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[254]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciEvtProcessMsg
</UL>

<P><STRONG><a name="[3bf]"></a>hciCoreReadMaxDataLen</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, hci_vs.o(i.hciCoreReadMaxDataLen))
<BR><BR>[Stack]<UL><LI>Max Depth = 208<LI>Call Chain = hciCoreReadMaxDataLen &rArr; HciLeReadMaxDataLen &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[280]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeReadMaxDataLen
<LI><a href="#[27d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeRandCmd
</UL>
<BR>[Called By]<UL><LI><a href="#[255]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreResetSequence
<LI><a href="#[3c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreReadResolvingListSize
</UL>

<P><STRONG><a name="[3c0]"></a>hciCoreReadResolvingListSize</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, hci_vs.o(i.hciCoreReadResolvingListSize))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = hciCoreReadResolvingListSize &rArr; hciCoreReadMaxDataLen &rArr; HciLeReadMaxDataLen &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[281]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeReadResolvingListSize
<LI><a href="#[3bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreReadMaxDataLen
</UL>
<BR>[Called By]<UL><LI><a href="#[255]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciCoreResetSequence
</UL>

<P><STRONG><a name="[5d]"></a>WsfTimer_handler</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, wsf_timer.o(i.WsfTimer_handler))
<BR><BR>[Stack]<UL><LI>Max Depth = 144<LI>Call Chain = WsfTimer_handler &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[2dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskSetReady
</UL>
<BR>[Address Reference Count : 1]<UL><LI> wsf_timer.o(i.WsfTimerInit)
</UL>
<P><STRONG><a name="[2ea]"></a>wsfTimerInsert</STRONG> (Thumb, 74 bytes, Stack size 24 bytes, wsf_timer.o(i.wsfTimerInsert))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = wsfTimerInsert &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[2eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wsfTimerRemove
<LI><a href="#[1e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfQueueInsert
<LI><a href="#[1e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskUnlock
<LI><a href="#[1e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskLock
</UL>
<BR>[Called By]<UL><LI><a href="#[2a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStartSec
<LI><a href="#[260]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStartMs
</UL>

<P><STRONG><a name="[2eb]"></a>wsfTimerRemove</STRONG> (Thumb, 46 bytes, Stack size 16 bytes, wsf_timer.o(i.wsfTimerRemove))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[2e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfQueueRemove
</UL>
<BR>[Called By]<UL><LI><a href="#[263]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStop
<LI><a href="#[2ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wsfTimerInsert
</UL>

<P><STRONG><a name="[53]"></a>secEccRng</STRONG> (Thumb, 18 bytes, Stack size 16 bytes, sec_ecc.o(i.secEccRng))
<BR><BR>[Stack]<UL><LI>Max Depth = 240<LI>Call Chain = secEccRng &rArr; SecRand &rArr; HciLeRandCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[18d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecRand
</UL>
<BR>[Address Reference Count : 1]<UL><LI> sec_ecc.o(i.SecEccInit)
</UL>
<P><STRONG><a name="[238]"></a>EccPoint_compute_public_key</STRONG> (Thumb, 114 bytes, Stack size 96 bytes, uecc.o(i.EccPoint_compute_public_key))
<BR><BR>[Stack]<UL><LI>Max Depth = 612<LI>Call Chain = EccPoint_compute_public_key &rArr; EccPoint_mult &rArr; XYcZ_initial_double &rArr; EccPoint_double_jacobian &rArr; vli_modSquare_fast &rArr; vli_square &rArr; mul2add
</UL>
<BR>[Calls]<UL><LI><a href="#[239]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_isZero
<LI><a href="#[23a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_cmp
<LI><a href="#[23b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_add
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EccPoint_mult
<LI><a href="#[23d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EccPoint_isZero
</UL>
<BR>[Called By]<UL><LI><a href="#[2b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uECC_make_key
</UL>

<P><STRONG><a name="[23e]"></a>EccPoint_double_jacobian</STRONG> (Thumb, 274 bytes, Stack size 88 bytes, uecc.o(i.EccPoint_double_jacobian))
<BR><BR>[Stack]<UL><LI>Max Depth = 260<LI>Call Chain = EccPoint_double_jacobian &rArr; vli_modSquare_fast &rArr; vli_square &rArr; mul2add
</UL>
<BR>[Calls]<UL><LI><a href="#[243]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_testBit
<LI><a href="#[245]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_set
<LI><a href="#[244]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_rshift1
<LI><a href="#[242]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modSub
<LI><a href="#[23f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modSquare_fast
<LI><a href="#[240]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modMult_fast
<LI><a href="#[241]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modAdd
<LI><a href="#[239]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_isZero
<LI><a href="#[23b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_add
</UL>
<BR>[Called By]<UL><LI><a href="#[246]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;XYcZ_initial_double
</UL>

<P><STRONG><a name="[23d]"></a>EccPoint_isZero</STRONG> (Thumb, 30 bytes, Stack size 8 bytes, uecc.o(i.EccPoint_isZero))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = EccPoint_isZero
</UL>
<BR>[Calls]<UL><LI><a href="#[239]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_isZero
</UL>
<BR>[Called By]<UL><LI><a href="#[238]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EccPoint_compute_public_key
<LI><a href="#[2b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uECC_valid_public_key
<LI><a href="#[2b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uECC_shared_secret
</UL>

<P><STRONG><a name="[23c]"></a>EccPoint_mult</STRONG> (Thumb, 386 bytes, Stack size 200 bytes, uecc.o(i.EccPoint_mult))
<BR><BR>[Stack]<UL><LI>Max Depth = 516<LI>Call Chain = EccPoint_mult &rArr; XYcZ_initial_double &rArr; EccPoint_double_jacobian &rArr; vli_modSquare_fast &rArr; vli_square &rArr; mul2add
</UL>
<BR>[Calls]<UL><LI><a href="#[243]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_testBit
<LI><a href="#[245]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_set
<LI><a href="#[242]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modSub
<LI><a href="#[240]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modMult_fast
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modInv
<LI><a href="#[24a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;apply_z
<LI><a href="#[246]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;XYcZ_initial_double
<LI><a href="#[247]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;XYcZ_addC
<LI><a href="#[248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;XYcZ_add
</UL>
<BR>[Called By]<UL><LI><a href="#[238]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EccPoint_compute_public_key
<LI><a href="#[2b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uECC_shared_secret
</UL>

<P><STRONG><a name="[248]"></a>XYcZ_add</STRONG> (Thumb, 164 bytes, Stack size 56 bytes, uecc.o(i.XYcZ_add))
<BR><BR>[Stack]<UL><LI>Max Depth = 228<LI>Call Chain = XYcZ_add &rArr; vli_modSquare_fast &rArr; vli_square &rArr; mul2add
</UL>
<BR>[Calls]<UL><LI><a href="#[245]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_set
<LI><a href="#[242]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modSub
<LI><a href="#[23f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modSquare_fast
<LI><a href="#[240]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modMult_fast
</UL>
<BR>[Called By]<UL><LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EccPoint_mult
</UL>

<P><STRONG><a name="[247]"></a>XYcZ_addC</STRONG> (Thumb, 230 bytes, Stack size 120 bytes, uecc.o(i.XYcZ_addC))
<BR><BR>[Stack]<UL><LI>Max Depth = 292<LI>Call Chain = XYcZ_addC &rArr; vli_modSquare_fast &rArr; vli_square &rArr; mul2add
</UL>
<BR>[Calls]<UL><LI><a href="#[245]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_set
<LI><a href="#[242]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modSub
<LI><a href="#[23f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modSquare_fast
<LI><a href="#[240]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modMult_fast
<LI><a href="#[241]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modAdd
</UL>
<BR>[Called By]<UL><LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EccPoint_mult
</UL>

<P><STRONG><a name="[246]"></a>XYcZ_initial_double</STRONG> (Thumb, 90 bytes, Stack size 56 bytes, uecc.o(i.XYcZ_initial_double))
<BR><BR>[Stack]<UL><LI>Max Depth = 316<LI>Call Chain = XYcZ_initial_double &rArr; EccPoint_double_jacobian &rArr; vli_modSquare_fast &rArr; vli_square &rArr; mul2add
</UL>
<BR>[Calls]<UL><LI><a href="#[245]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_set
<LI><a href="#[2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_clear
<LI><a href="#[24a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;apply_z
<LI><a href="#[23e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EccPoint_double_jacobian
</UL>
<BR>[Called By]<UL><LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EccPoint_mult
</UL>

<P><STRONG><a name="[24a]"></a>apply_z</STRONG> (Thumb, 52 bytes, Stack size 48 bytes, uecc.o(i.apply_z))
<BR><BR>[Stack]<UL><LI>Max Depth = 220<LI>Call Chain = apply_z &rArr; vli_modSquare_fast &rArr; vli_square &rArr; mul2add
</UL>
<BR>[Calls]<UL><LI><a href="#[23f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modSquare_fast
<LI><a href="#[240]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modMult_fast
</UL>
<BR>[Called By]<UL><LI><a href="#[246]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;XYcZ_initial_double
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EccPoint_mult
</UL>

<P><STRONG><a name="[383]"></a>curve_x_side</STRONG> (Thumb, 68 bytes, Stack size 48 bytes, uecc.o(i.curve_x_side))
<BR><BR>[Stack]<UL><LI>Max Depth = 220<LI>Call Chain = curve_x_side &rArr; vli_modSquare_fast &rArr; vli_square &rArr; mul2add
</UL>
<BR>[Calls]<UL><LI><a href="#[242]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modSub
<LI><a href="#[23f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modSquare_fast
<LI><a href="#[240]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modMult_fast
<LI><a href="#[241]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modAdd
<LI><a href="#[160]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Called By]<UL><LI><a href="#[2b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uECC_valid_public_key
</UL>

<P><STRONG><a name="[2]"></a>default_RNG</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, uecc.o(i.default_RNG))
<BR>[Address Reference Count : 1]<UL><LI> uecc.o(.data)
</UL>
<P><STRONG><a name="[443]"></a>mul2add</STRONG> (Thumb, 124 bytes, Stack size 52 bytes, uecc.o(i.mul2add))
<BR><BR>[Stack]<UL><LI>Max Depth = 52<LI>Call Chain = mul2add
</UL>
<BR>[Called By]<UL><LI><a href="#[441]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_square
</UL>

<P><STRONG><a name="[442]"></a>muladd</STRONG> (Thumb, 78 bytes, Stack size 36 bytes, uecc.o(i.muladd))
<BR><BR>[Stack]<UL><LI>Max Depth = 36<LI>Call Chain = muladd
</UL>
<BR>[Called By]<UL><LI><a href="#[441]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_square
<LI><a href="#[440]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_mult
</UL>

<P><STRONG><a name="[23b]"></a>vli_add</STRONG> (Thumb, 62 bytes, Stack size 20 bytes, uecc.o(i.vli_add))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = vli_add
</UL>
<BR>[Called By]<UL><LI><a href="#[242]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modSub
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modInv
<LI><a href="#[241]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modAdd
<LI><a href="#[43e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_mmod_fast
<LI><a href="#[23e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EccPoint_double_jacobian
<LI><a href="#[238]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EccPoint_compute_public_key
<LI><a href="#[2b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uECC_shared_secret
</UL>

<P><STRONG><a name="[42a]"></a>vli_bytesToNative</STRONG> (Thumb, 52 bytes, Stack size 12 bytes, uecc.o(i.vli_bytesToNative))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = vli_bytesToNative
</UL>
<BR>[Called By]<UL><LI><a href="#[2b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uECC_valid_public_key
<LI><a href="#[2b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uECC_shared_secret
</UL>

<P><STRONG><a name="[2f0]"></a>vli_clear</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, uecc.o(i.vli_clear))
<BR><BR>[Called By]<UL><LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modInv
<LI><a href="#[246]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;XYcZ_initial_double
</UL>

<P><STRONG><a name="[23a]"></a>vli_cmp</STRONG> (Thumb, 54 bytes, Stack size 8 bytes, uecc.o(i.vli_cmp))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = vli_cmp
</UL>
<BR>[Called By]<UL><LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modInv
<LI><a href="#[241]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modAdd
<LI><a href="#[43e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_mmod_fast
<LI><a href="#[238]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EccPoint_compute_public_key
<LI><a href="#[2b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uECC_valid_public_key
</UL>

<P><STRONG><a name="[239]"></a>vli_isZero</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, uecc.o(i.vli_isZero))
<BR><BR>[Called By]<UL><LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modInv
<LI><a href="#[23d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EccPoint_isZero
<LI><a href="#[23e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EccPoint_double_jacobian
<LI><a href="#[238]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EccPoint_compute_public_key
<LI><a href="#[2b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uECC_shared_secret
</UL>

<P><STRONG><a name="[43e]"></a>vli_mmod_fast</STRONG> (Thumb, 424 bytes, Stack size 48 bytes, uecc.o(i.vli_mmod_fast))
<BR><BR>[Stack]<UL><LI>Max Depth = 68<LI>Call Chain = vli_mmod_fast &rArr; vli_sub
</UL>
<BR>[Calls]<UL><LI><a href="#[43f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_sub
<LI><a href="#[245]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_set
<LI><a href="#[23a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_cmp
<LI><a href="#[23b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_add
</UL>
<BR>[Called By]<UL><LI><a href="#[23f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modSquare_fast
<LI><a href="#[240]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modMult_fast
</UL>

<P><STRONG><a name="[241]"></a>vli_modAdd</STRONG> (Thumb, 56 bytes, Stack size 24 bytes, uecc.o(i.vli_modAdd))
<BR><BR>[Stack]<UL><LI>Max Depth = 44<LI>Call Chain = vli_modAdd &rArr; vli_sub
</UL>
<BR>[Calls]<UL><LI><a href="#[43f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_sub
<LI><a href="#[23a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_cmp
<LI><a href="#[23b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_add
</UL>
<BR>[Called By]<UL><LI><a href="#[383]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;curve_x_side
<LI><a href="#[247]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;XYcZ_addC
<LI><a href="#[23e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EccPoint_double_jacobian
</UL>

<P><STRONG><a name="[249]"></a>vli_modInv</STRONG> (Thumb, 376 bytes, Stack size 152 bytes, uecc.o(i.vli_modInv))
<BR><BR>[Stack]<UL><LI>Max Depth = 172<LI>Call Chain = vli_modInv &rArr; vli_sub
</UL>
<BR>[Calls]<UL><LI><a href="#[43f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_sub
<LI><a href="#[245]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_set
<LI><a href="#[244]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_rshift1
<LI><a href="#[239]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_isZero
<LI><a href="#[23a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_cmp
<LI><a href="#[2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_clear
<LI><a href="#[23b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_add
</UL>
<BR>[Called By]<UL><LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EccPoint_mult
</UL>

<P><STRONG><a name="[240]"></a>vli_modMult_fast</STRONG> (Thumb, 32 bytes, Stack size 80 bytes, uecc.o(i.vli_modMult_fast))
<BR><BR>[Stack]<UL><LI>Max Depth = 156<LI>Call Chain = vli_modMult_fast &rArr; vli_mult &rArr; muladd
</UL>
<BR>[Calls]<UL><LI><a href="#[440]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_mult
<LI><a href="#[43e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_mmod_fast
</UL>
<BR>[Called By]<UL><LI><a href="#[383]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;curve_x_side
<LI><a href="#[24a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;apply_z
<LI><a href="#[247]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;XYcZ_addC
<LI><a href="#[248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;XYcZ_add
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EccPoint_mult
<LI><a href="#[23e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EccPoint_double_jacobian
</UL>

<P><STRONG><a name="[23f]"></a>vli_modSquare_fast</STRONG> (Thumb, 28 bytes, Stack size 80 bytes, uecc.o(i.vli_modSquare_fast))
<BR><BR>[Stack]<UL><LI>Max Depth = 172<LI>Call Chain = vli_modSquare_fast &rArr; vli_square &rArr; mul2add
</UL>
<BR>[Calls]<UL><LI><a href="#[441]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_square
<LI><a href="#[43e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_mmod_fast
</UL>
<BR>[Called By]<UL><LI><a href="#[383]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;curve_x_side
<LI><a href="#[24a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;apply_z
<LI><a href="#[247]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;XYcZ_addC
<LI><a href="#[248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;XYcZ_add
<LI><a href="#[23e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EccPoint_double_jacobian
<LI><a href="#[2b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uECC_valid_public_key
</UL>

<P><STRONG><a name="[242]"></a>vli_modSub</STRONG> (Thumb, 44 bytes, Stack size 24 bytes, uecc.o(i.vli_modSub))
<BR><BR>[Stack]<UL><LI>Max Depth = 44<LI>Call Chain = vli_modSub &rArr; vli_sub
</UL>
<BR>[Calls]<UL><LI><a href="#[43f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_sub
<LI><a href="#[23b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_add
</UL>
<BR>[Called By]<UL><LI><a href="#[383]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;curve_x_side
<LI><a href="#[247]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;XYcZ_addC
<LI><a href="#[248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;XYcZ_add
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EccPoint_mult
<LI><a href="#[23e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EccPoint_double_jacobian
</UL>

<P><STRONG><a name="[440]"></a>vli_mult</STRONG> (Thumb, 146 bytes, Stack size 40 bytes, uecc.o(i.vli_mult))
<BR><BR>[Stack]<UL><LI>Max Depth = 76<LI>Call Chain = vli_mult &rArr; muladd
</UL>
<BR>[Calls]<UL><LI><a href="#[442]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;muladd
</UL>
<BR>[Called By]<UL><LI><a href="#[240]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modMult_fast
</UL>

<P><STRONG><a name="[429]"></a>vli_nativeToBytes</STRONG> (Thumb, 56 bytes, Stack size 12 bytes, uecc.o(i.vli_nativeToBytes))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = vli_nativeToBytes
</UL>
<BR>[Called By]<UL><LI><a href="#[2b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uECC_shared_secret
<LI><a href="#[2b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uECC_make_key
</UL>

<P><STRONG><a name="[244]"></a>vli_rshift1</STRONG> (Thumb, 32 bytes, Stack size 8 bytes, uecc.o(i.vli_rshift1))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = vli_rshift1
</UL>
<BR>[Called By]<UL><LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modInv
<LI><a href="#[23e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EccPoint_double_jacobian
</UL>

<P><STRONG><a name="[245]"></a>vli_set</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, uecc.o(i.vli_set))
<BR><BR>[Called By]<UL><LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modInv
<LI><a href="#[43e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_mmod_fast
<LI><a href="#[246]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;XYcZ_initial_double
<LI><a href="#[247]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;XYcZ_addC
<LI><a href="#[248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;XYcZ_add
<LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EccPoint_mult
<LI><a href="#[23e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EccPoint_double_jacobian
</UL>

<P><STRONG><a name="[441]"></a>vli_square</STRONG> (Thumb, 132 bytes, Stack size 40 bytes, uecc.o(i.vli_square))
<BR><BR>[Stack]<UL><LI>Max Depth = 92<LI>Call Chain = vli_square &rArr; mul2add
</UL>
<BR>[Calls]<UL><LI><a href="#[442]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;muladd
<LI><a href="#[443]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mul2add
</UL>
<BR>[Called By]<UL><LI><a href="#[23f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modSquare_fast
</UL>

<P><STRONG><a name="[43f]"></a>vli_sub</STRONG> (Thumb, 62 bytes, Stack size 20 bytes, uecc.o(i.vli_sub))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = vli_sub
</UL>
<BR>[Called By]<UL><LI><a href="#[242]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modSub
<LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modInv
<LI><a href="#[241]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_modAdd
<LI><a href="#[43e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vli_mmod_fast
</UL>

<P><STRONG><a name="[243]"></a>vli_testBit</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, uecc.o(i.vli_testBit))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = vli_testBit
</UL>
<BR>[Called By]<UL><LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EccPoint_mult
<LI><a href="#[23e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EccPoint_double_jacobian
</UL>

<P><STRONG><a name="[1d4]"></a>attcDiscConfigNext</STRONG> (Thumb, 92 bytes, Stack size 24 bytes, attc_disc.o(i.attcDiscConfigNext))
<BR><BR>[Stack]<UL><LI>Max Depth = 256<LI>Call Chain = attcDiscConfigNext &rArr; AttcWriteReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcWriteReq
<LI><a href="#[1de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcReadReq
</UL>
<BR>[Called By]<UL><LI><a href="#[16e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcDiscConfigStart
<LI><a href="#[1d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcDiscConfigResume
<LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcDiscConfigCmpl
</UL>

<P><STRONG><a name="[351]"></a>attcDiscDescriptors</STRONG> (Thumb, 156 bytes, Stack size 24 bytes, attc_disc.o(i.attcDiscDescriptors))
<BR><BR>[Stack]<UL><LI>Max Depth = 256<LI>Call Chain = attcDiscDescriptors &rArr; AttcFindInfoReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcFindInfoReq
<LI><a href="#[352]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcDiscVerify
</UL>
<BR>[Called By]<UL><LI><a href="#[1d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcDiscProcDesc
<LI><a href="#[1d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcDiscProcChar
</UL>

<P><STRONG><a name="[1d0]"></a>attcDiscProcChar</STRONG> (Thumb, 112 bytes, Stack size 32 bytes, attc_disc.o(i.attcDiscProcChar))
<BR><BR>[Stack]<UL><LI>Max Depth = 288<LI>Call Chain = attcDiscProcChar &rArr; attcDiscDescriptors &rArr; AttcFindInfoReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[353]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcDiscProcCharDecl
<LI><a href="#[351]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcDiscDescriptors
</UL>
<BR>[Called By]<UL><LI><a href="#[17d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcDiscCharCmpl
</UL>

<P><STRONG><a name="[353]"></a>attcDiscProcCharDecl</STRONG> (Thumb, 144 bytes, Stack size 32 bytes, attc_disc.o(i.attcDiscProcCharDecl))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = attcDiscProcCharDecl &rArr; attcUuidCmp &rArr; attUuidCmp16to128 &rArr; memcmp
</UL>
<BR>[Calls]<UL><LI><a href="#[354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcUuidCmp
</UL>
<BR>[Called By]<UL><LI><a href="#[1d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcDiscProcChar
</UL>

<P><STRONG><a name="[1d1]"></a>attcDiscProcDesc</STRONG> (Thumb, 146 bytes, Stack size 40 bytes, attc_disc.o(i.attcDiscProcDesc))
<BR><BR>[Stack]<UL><LI>Max Depth = 296<LI>Call Chain = attcDiscProcDesc &rArr; attcDiscDescriptors &rArr; AttcFindInfoReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[355]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcDiscProcDescPair
<LI><a href="#[351]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcDiscDescriptors
</UL>
<BR>[Called By]<UL><LI><a href="#[17d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcDiscCharCmpl
</UL>

<P><STRONG><a name="[355]"></a>attcDiscProcDescPair</STRONG> (Thumb, 94 bytes, Stack size 32 bytes, attc_disc.o(i.attcDiscProcDescPair))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = attcDiscProcDescPair &rArr; attcUuidCmp &rArr; attUuidCmp16to128 &rArr; memcmp
</UL>
<BR>[Calls]<UL><LI><a href="#[354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcUuidCmp
</UL>
<BR>[Called By]<UL><LI><a href="#[1d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcDiscProcDesc
</UL>

<P><STRONG><a name="[352]"></a>attcDiscVerify</STRONG> (Thumb, 46 bytes, Stack size 0 bytes, attc_disc.o(i.attcDiscVerify))
<BR><BR>[Called By]<UL><LI><a href="#[351]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcDiscDescriptors
</UL>

<P><STRONG><a name="[354]"></a>attcUuidCmp</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, attc_disc.o(i.attcUuidCmp))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = attcUuidCmp &rArr; attUuidCmp16to128 &rArr; memcmp
</UL>
<BR>[Calls]<UL><LI><a href="#[34b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attUuidCmp16to128
<LI><a href="#[15c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
</UL>
<BR>[Called By]<UL><LI><a href="#[355]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcDiscProcDescPair
<LI><a href="#[353]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcDiscProcCharDecl
</UL>

<P><STRONG><a name="[a2]"></a>attcConnCback</STRONG> (Thumb, 196 bytes, Stack size 24 bytes, attc_main.o(i.attcConnCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 248<LI>Call Chain = attcConnCback &rArr; AttcMtuReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciGetMaxRxAclLen
<LI><a href="#[263]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStop
<LI><a href="#[173]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnRole
<LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcMtuReq
<LI><a href="#[34d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcReqClear
<LI><a href="#[34e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcWriteCmdCallback
</UL>
<BR>[Address Reference Count : 1]<UL><LI> attc_main.o(.constdata)
</UL>
<P><STRONG><a name="[a0]"></a>attcCtrlCback</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, attc_main.o(i.attcCtrlCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 312<LI>Call Chain = attcCtrlCback &rArr; AttcIndConfirm &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcIndConfirm
<LI><a href="#[34c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcCcbByConnId
<LI><a href="#[34e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcWriteCmdCallback
</UL>
<BR>[Address Reference Count : 1]<UL><LI> attc_main.o(.constdata)
</UL>
<P><STRONG><a name="[9f]"></a>attcDataCback</STRONG> (Thumb, 66 bytes, Stack size 24 bytes, attc_main.o(i.attcDataCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 344<LI>Call Chain = attcDataCback &rArr; attcProcInd &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[34f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcProcRsp
<LI><a href="#[350]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcProcInd
<LI><a href="#[1db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcCcbByHandle
</UL>
<BR>[Address Reference Count : 1]<UL><LI> attc_main.o(.constdata)
</UL>
<P><STRONG><a name="[a1]"></a>attcMsgCback</STRONG> (Thumb, 238 bytes, Stack size 16 bytes, attc_main.o(i.attcMsgCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = attcMsgCback &rArr; attcReqClear &rArr; attcExecCallback &rArr; attExecCallback
</UL>
<BR>[Calls]<UL><LI><a href="#[263]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStop
<LI><a href="#[359]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSetupReq
<LI><a href="#[34d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcReqClear
<LI><a href="#[357]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcFreePkt
<LI><a href="#[34c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcCcbByConnId
<LI><a href="#[358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcPendWriteCmd
</UL>
<BR>[Address Reference Count : 1]<UL><LI> attc_main.o(.constdata)
</UL>
<P><STRONG><a name="[358]"></a>attcPendWriteCmd</STRONG> (Thumb, 64 bytes, Stack size 12 bytes, attc_main.o(i.attcPendWriteCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = attcPendWriteCmd
</UL>
<BR>[Called By]<UL><LI><a href="#[a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcMsgCback
</UL>

<P><STRONG><a name="[a4]"></a>attcSendContinuingReq</STRONG> (Thumb, 160 bytes, Stack size 16 bytes, attc_main.o(i.attcSendContinuingReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 296<LI>Call Chain = attcSendContinuingReq &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[2a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStartSec
<LI><a href="#[1d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attMsgAlloc
<LI><a href="#[1dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cDataReq
<LI><a href="#[34d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcReqClear
<LI><a href="#[13e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4
</UL>
<BR>[Address Reference Count : 1]<UL><LI> attc_main.o(.constdata)
</UL>
<P><STRONG><a name="[a3]"></a>attcSendMtuReq</STRONG> (Thumb, 48 bytes, Stack size 8 bytes, attc_main.o(i.attcSendMtuReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 304<LI>Call Chain = attcSendMtuReq &rArr; attcSendSimpleReq &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[357]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcFreePkt
<LI><a href="#[a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendSimpleReq
</UL>
<BR>[Address Reference Count : 1]<UL><LI> attc_main.o(.constdata)
</UL>
<P><STRONG><a name="[a7]"></a>attcSendPrepWriteReq</STRONG> (Thumb, 174 bytes, Stack size 24 bytes, attc_main.o(i.attcSendPrepWriteReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 304<LI>Call Chain = attcSendPrepWriteReq &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[2a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStartSec
<LI><a href="#[1d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attMsgAlloc
<LI><a href="#[1dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cDataReq
<LI><a href="#[34d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcReqClear
<LI><a href="#[13e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Address Reference Count : 1]<UL><LI> attc_main.o(.constdata)
</UL>
<P><STRONG><a name="[a5]"></a>attcSendSimpleReq</STRONG> (Thumb, 52 bytes, Stack size 16 bytes, attc_main.o(i.attcSendSimpleReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 296<LI>Call Chain = attcSendSimpleReq &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[2a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStartSec
<LI><a href="#[1dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cDataReq
</UL>
<BR>[Called By]<UL><LI><a href="#[a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendWriteCmd
<LI><a href="#[a3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendMtuReq
</UL>
<BR>[Address Reference Count : 1]<UL><LI> attc_main.o(.constdata)
</UL>
<P><STRONG><a name="[a6]"></a>attcSendWriteCmd</STRONG> (Thumb, 48 bytes, Stack size 8 bytes, attc_main.o(i.attcSendWriteCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 304<LI>Call Chain = attcSendWriteCmd &rArr; attcSendSimpleReq &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[356]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcExecCallback
<LI><a href="#[35b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSetPendWriteCmd
<LI><a href="#[a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendSimpleReq
</UL>
<BR>[Address Reference Count : 1]<UL><LI> attc_main.o(.constdata)
</UL>
<P><STRONG><a name="[35b]"></a>attcSetPendWriteCmd</STRONG> (Thumb, 40 bytes, Stack size 0 bytes, attc_main.o(i.attcSetPendWriteCmd))
<BR><BR>[Called By]<UL><LI><a href="#[a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcSendWriteCmd
</UL>

<P><STRONG><a name="[34e]"></a>attcWriteCmdCallback</STRONG> (Thumb, 64 bytes, Stack size 24 bytes, attc_main.o(i.attcWriteCmdCallback))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = attcWriteCmdCallback &rArr; attcExecCallback &rArr; attExecCallback
</UL>
<BR>[Calls]<UL><LI><a href="#[356]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcExecCallback
</UL>
<BR>[Called By]<UL><LI><a href="#[a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcCtrlCback
<LI><a href="#[a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attcConnCback
</UL>

<P><STRONG><a name="[1ec]"></a>attsCccAllocTbl</STRONG> (Thumb, 40 bytes, Stack size 8 bytes, atts_ccc.o(i.attsCccAllocTbl))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = attsCccAllocTbl &rArr; WsfBufAlloc
</UL>
<BR>[Calls]<UL><LI><a href="#[16d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufAlloc
</UL>
<BR>[Called By]<UL><LI><a href="#[19e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsCccInitTable
</UL>

<P><STRONG><a name="[1ed]"></a>attsCccCback</STRONG> (Thumb, 42 bytes, Stack size 32 bytes, atts_ccc.o(i.attsCccCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = attsCccCback
</UL>
<BR>[Called By]<UL><LI><a href="#[19e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsCccInitTable
<LI><a href="#[35d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsCccWriteValue
</UL>

<P><STRONG><a name="[1e9]"></a>attsCccFreeTbl</STRONG> (Thumb, 38 bytes, Stack size 8 bytes, atts_ccc.o(i.attsCccFreeTbl))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = attsCccFreeTbl &rArr; WsfBufFree
</UL>
<BR>[Calls]<UL><LI><a href="#[168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufFree
</UL>
<BR>[Called By]<UL><LI><a href="#[1a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsCccClearTable
</UL>

<P><STRONG><a name="[1eb]"></a>attsCccGetTbl</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, atts_ccc.o(i.attsCccGetTbl))
<BR><BR>[Called By]<UL><LI><a href="#[1a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsCccGet
<LI><a href="#[35d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsCccWriteValue
<LI><a href="#[35c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsCccReadValue
</UL>

<P><STRONG><a name="[40]"></a>attsCccMainCback</STRONG> (Thumb, 42 bytes, Stack size 24 bytes, atts_ccc.o(i.attsCccMainCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = attsCccMainCback &rArr; attsCccWriteValue &rArr; attsCccCback
</UL>
<BR>[Calls]<UL><LI><a href="#[35d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsCccWriteValue
<LI><a href="#[35c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsCccReadValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> atts_ccc.o(i.AttsCccRegister)
</UL>
<P><STRONG><a name="[35c]"></a>attsCccReadValue</STRONG> (Thumb, 98 bytes, Stack size 32 bytes, atts_ccc.o(i.attsCccReadValue))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = attsCccReadValue
</UL>
<BR>[Calls]<UL><LI><a href="#[1eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsCccGetTbl
</UL>
<BR>[Called By]<UL><LI><a href="#[40]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsCccMainCback
</UL>

<P><STRONG><a name="[35d]"></a>attsCccWriteValue</STRONG> (Thumb, 142 bytes, Stack size 40 bytes, atts_ccc.o(i.attsCccWriteValue))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = attsCccWriteValue &rArr; attsCccCback
</UL>
<BR>[Calls]<UL><LI><a href="#[1eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsCccGetTbl
<LI><a href="#[1ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsCccCback
</UL>
<BR>[Called By]<UL><LI><a href="#[40]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsCccMainCback
</UL>

<P><STRONG><a name="[363]"></a>attsExecCallback</STRONG> (Thumb, 26 bytes, Stack size 24 bytes, atts_ind.o(i.attsExecCallback))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = attsExecCallback &rArr; attExecCallback
</UL>
<BR>[Calls]<UL><LI><a href="#[1cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attExecCallback
</UL>
<BR>[Called By]<UL><LI><a href="#[e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcValueCnf
<LI><a href="#[36c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsSetupMsg
<LI><a href="#[36a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsIndNtfCallback
<LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsIndMsgCback
<LI><a href="#[1f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsHandleValueIndNtf
</UL>

<P><STRONG><a name="[1f2]"></a>attsHandleValueIndNtf</STRONG> (Thumb, 262 bytes, Stack size 64 bytes, atts_ind.o(i.attsHandleValueIndNtf))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = attsHandleValueIndNtf &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgFree
<LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[1e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskUnlock
<LI><a href="#[1e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskLock
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
<LI><a href="#[369]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsCsfIsClientChangeAware
<LI><a href="#[1d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attMsgAlloc
<LI><a href="#[1cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttMsgFree
<LI><a href="#[368]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsIndCcbByConnId
<LI><a href="#[363]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsExecCallback
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[1f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsHandleValueInd
</UL>

<P><STRONG><a name="[368]"></a>attsIndCcbByConnId</STRONG> (Thumb, 30 bytes, Stack size 8 bytes, atts_ind.o(i.attsIndCcbByConnId))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = attsIndCcbByConnId
</UL>
<BR>[Calls]<UL><LI><a href="#[214]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnInUse
</UL>
<BR>[Called By]<UL><LI><a href="#[e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcValueCnf
<LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsIndMsgCback
<LI><a href="#[b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsIndCtrlCback
<LI><a href="#[1f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsHandleValueIndNtf
</UL>

<P><STRONG><a name="[b3]"></a>attsIndConnCback</STRONG> (Thumb, 80 bytes, Stack size 24 bytes, atts_ind.o(i.attsIndConnCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 112<LI>Call Chain = attsIndConnCback &rArr; attsIndNtfCallback &rArr; attsExecCallback &rArr; attExecCallback
</UL>
<BR>[Calls]<UL><LI><a href="#[263]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStop
<LI><a href="#[36a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsIndNtfCallback
</UL>
<BR>[Address Reference Count : 1]<UL><LI> atts_ind.o(.constdata)
</UL>
<P><STRONG><a name="[b1]"></a>attsIndCtrlCback</STRONG> (Thumb, 26 bytes, Stack size 16 bytes, atts_ind.o(i.attsIndCtrlCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 104<LI>Call Chain = attsIndCtrlCback &rArr; attsIndNtfCallback &rArr; attsExecCallback &rArr; attExecCallback
</UL>
<BR>[Calls]<UL><LI><a href="#[36a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsIndNtfCallback
<LI><a href="#[368]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsIndCcbByConnId
</UL>
<BR>[Address Reference Count : 1]<UL><LI> atts_ind.o(.constdata)
</UL>
<P><STRONG><a name="[b2]"></a>attsIndMsgCback</STRONG> (Thumb, 120 bytes, Stack size 16 bytes, atts_ind.o(i.attsIndMsgCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = attsIndMsgCback &rArr; attsSetupMsg &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgFree
<LI><a href="#[36c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsSetupMsg
<LI><a href="#[36b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsPendIndNtfHandle
<LI><a href="#[368]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsIndCcbByConnId
<LI><a href="#[363]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsExecCallback
</UL>
<BR>[Address Reference Count : 1]<UL><LI> atts_ind.o(.constdata)
</UL>
<P><STRONG><a name="[36a]"></a>attsIndNtfCallback</STRONG> (Thumb, 80 bytes, Stack size 24 bytes, atts_ind.o(i.attsIndNtfCallback))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = attsIndNtfCallback &rArr; attsExecCallback &rArr; attExecCallback
</UL>
<BR>[Calls]<UL><LI><a href="#[363]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsExecCallback
</UL>
<BR>[Called By]<UL><LI><a href="#[b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsIndCtrlCback
<LI><a href="#[b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsIndConnCback
</UL>

<P><STRONG><a name="[36b]"></a>attsPendIndNtfHandle</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, atts_ind.o(i.attsPendIndNtfHandle))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = attsPendIndNtfHandle
</UL>
<BR>[Called By]<UL><LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsIndMsgCback
</UL>

<P><STRONG><a name="[372]"></a>attsSetPendNtfHandle</STRONG> (Thumb, 38 bytes, Stack size 0 bytes, atts_ind.o(i.attsSetPendNtfHandle))
<BR><BR>[Called By]<UL><LI><a href="#[36c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsSetupMsg
</UL>

<P><STRONG><a name="[36c]"></a>attsSetupMsg</STRONG> (Thumb, 92 bytes, Stack size 24 bytes, atts_ind.o(i.attsSetupMsg))
<BR><BR>[Stack]<UL><LI>Max Depth = 304<LI>Call Chain = attsSetupMsg &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[2a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStartSec
<LI><a href="#[1dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cDataReq
<LI><a href="#[372]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsSetPendNtfHandle
<LI><a href="#[363]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsExecCallback
</UL>
<BR>[Called By]<UL><LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsIndMsgCback
</UL>

<P><STRONG><a name="[b7]"></a>attsConnCback</STRONG> (Thumb, 52 bytes, Stack size 16 bytes, atts_main.o(i.attsConnCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = attsConnCback &rArr; WsfTimerStop &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[263]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStop
<LI><a href="#[213]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnCheckIdle
<LI><a href="#[360]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsClearPrepWrites
</UL>
<BR>[Address Reference Count : 1]<UL><LI> atts_main.o(.constdata)
</UL>
<P><STRONG><a name="[b4]"></a>attsDataCback</STRONG> (Thumb, 190 bytes, Stack size 48 bytes, atts_main.o(i.attsDataCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 360<LI>Call Chain = attsDataCback &rArr; attsErrRsp &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[361]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsCsfActClientState
<LI><a href="#[347]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attCcbByHandle
<LI><a href="#[35f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsErrRsp
</UL>
<BR>[Address Reference Count : 1]<UL><LI> atts_main.o(.constdata)
</UL>
<P><STRONG><a name="[b5]"></a>attsL2cCtrlCback</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, atts_main.o(i.attsL2cCtrlCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = attsL2cCtrlCback
</UL>
<BR>[Address Reference Count : 1]<UL><LI> atts_main.o(.constdata)
</UL>
<P><STRONG><a name="[b6]"></a>attsMsgCback</STRONG> (Thumb, 70 bytes, Stack size 8 bytes, atts_main.o(i.attsMsgCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 408<LI>Call Chain = attsMsgCback &rArr; attsProcessDatabaseHashUpdate &rArr; attsCsfSetHashUpdateStatus &rArr; attsCheckPendDbHashReadRsp &rArr; attsErrRsp &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnSetIdle
<LI><a href="#[36d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcessDatabaseHashUpdate
</UL>
<BR>[Address Reference Count : 1]<UL><LI> atts_main.o(.constdata)
</UL>
<P><STRONG><a name="[1f0]"></a>attsSignCcbByConnId</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, atts_sign.o(i.attsSignCcbByConnId))
<BR><BR>[Called By]<UL><LI><a href="#[1f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsSetSignCounter
<LI><a href="#[1f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsSetCsrk
<LI><a href="#[1a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsGetSignCounter
</UL>

<P><STRONG><a name="[364]"></a>attsExecPrepWrite</STRONG> (Thumb, 164 bytes, Stack size 40 bytes, atts_write.o(i.attsExecPrepWrite))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = attsExecPrepWrite &rArr; attsFindByHandle
</UL>
<BR>[Calls]<UL><LI><a href="#[1ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsFindByHandle
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attsProcExecWriteReq
</UL>

<P><STRONG><a name="[3f]"></a>attDmConnCback</STRONG> (Thumb, 100 bytes, Stack size 16 bytes, att_main.o(i.attDmConnCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = attDmConnCback &rArr; WsfBufFree
</UL>
<BR>[Calls]<UL><LI><a href="#[168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufFree
<LI><a href="#[349]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attCcbByConnId
</UL>
<BR>[Address Reference Count : 1]<UL><LI> att_main.o(i.AttHandlerInit)
</UL>
<P><STRONG><a name="[3d]"></a>attL2cCtrlCback</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, att_main.o(i.attL2cCtrlCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = attL2cCtrlCback
</UL>
<BR>[Calls]<UL><LI><a href="#[349]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;attCcbByConnId
</UL>
<BR>[Address Reference Count : 1]<UL><LI> att_main.o(i.AttHandlerInit)
</UL>
<P><STRONG><a name="[3e]"></a>attL2cDataCback</STRONG> (Thumb, 52 bytes, Stack size 24 bytes, att_main.o(i.attL2cDataCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = attL2cDataCback
</UL>
<BR>[Address Reference Count : 1]<UL><LI> att_main.o(i.AttHandlerInit)
</UL>
<P><STRONG><a name="[384]"></a>dmAdvConfig</STRONG> (Thumb, 58 bytes, Stack size 40 bytes, dm_adv_leg.o(i.dmAdvConfig))
<BR><BR>[Stack]<UL><LI>Max Depth = 272<LI>Call Chain = dmAdvConfig &rArr; HciLeSetAdvParamCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[28a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetAdvParamCmd
<LI><a href="#[385]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmLlAddrType
</UL>
<BR>[Called By]<UL><LI><a href="#[b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmAdvActConfig
</UL>

<P><STRONG><a name="[392]"></a>dmConn2ActAuthToExpired</STRONG> (Thumb, 42 bytes, Stack size 24 bytes, dm_conn.o(i.dmConn2ActAuthToExpired))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = dmConn2ActAuthToExpired
</UL>
<BR>[Called By]<UL><LI><a href="#[ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConn2HciHandler
</UL>

<P><STRONG><a name="[390]"></a>dmConn2ActDataLenChange</STRONG> (Thumb, 66 bytes, Stack size 32 bytes, dm_conn.o(i.dmConn2ActDataLenChange))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = dmConn2ActDataLenChange
</UL>
<BR>[Called By]<UL><LI><a href="#[ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConn2HciHandler
</UL>

<P><STRONG><a name="[393]"></a>dmConn2ActReadRemoteFeaturesCmpl</STRONG> (Thumb, 84 bytes, Stack size 32 bytes, dm_conn.o(i.dmConn2ActReadRemoteFeaturesCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = dmConn2ActReadRemoteFeaturesCmpl
</UL>
<BR>[Called By]<UL><LI><a href="#[ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConn2HciHandler
</UL>

<P><STRONG><a name="[394]"></a>dmConn2ActReadRemoteVerInfoCmpl</STRONG> (Thumb, 66 bytes, Stack size 32 bytes, dm_conn.o(i.dmConn2ActReadRemoteVerInfoCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = dmConn2ActReadRemoteVerInfoCmpl
</UL>
<BR>[Called By]<UL><LI><a href="#[ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConn2HciHandler
</UL>

<P><STRONG><a name="[38f]"></a>dmConn2ActRemoteConnParamReq</STRONG> (Thumb, 66 bytes, Stack size 32 bytes, dm_conn.o(i.dmConn2ActRemoteConnParamReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = dmConn2ActRemoteConnParamReq
</UL>
<BR>[Called By]<UL><LI><a href="#[ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConn2HciHandler
</UL>

<P><STRONG><a name="[38e]"></a>dmConn2ActRssiRead</STRONG> (Thumb, 52 bytes, Stack size 24 bytes, dm_conn.o(i.dmConn2ActRssiRead))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = dmConn2ActRssiRead
</UL>
<BR>[Called By]<UL><LI><a href="#[ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConn2HciHandler
</UL>

<P><STRONG><a name="[391]"></a>dmConn2ActWriteAuthToCmpl</STRONG> (Thumb, 48 bytes, Stack size 24 bytes, dm_conn.o(i.dmConn2ActWriteAuthToCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = dmConn2ActWriteAuthToCmpl
</UL>
<BR>[Called By]<UL><LI><a href="#[ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConn2HciHandler
</UL>

<P><STRONG><a name="[397]"></a>dmConnCmplStates</STRONG> (Thumb, 50 bytes, Stack size 0 bytes, dm_conn.o(i.dmConnCmplStates))
<BR><BR>[Called By]<UL><LI><a href="#[cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnHciHandler
</UL>

<P><STRONG><a name="[39d]"></a>dmConnUpdateCback</STRONG> (Thumb, 44 bytes, Stack size 32 bytes, dm_conn_slave.o(i.dmConnUpdateCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = dmConnUpdateCback
</UL>
<BR>[Called By]<UL><LI><a href="#[d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActUpdateSlave
<LI><a href="#[d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnSmActL2cUpdateCnf
</UL>

<P><STRONG><a name="[3a1]"></a>dmDevHciEvtHwError</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, dm_dev.o(i.dmDevHciEvtHwError))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = dmDevHciEvtHwError
</UL>
<BR>[Called By]<UL><LI><a href="#[d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmDevHciHandler
</UL>

<P><STRONG><a name="[39f]"></a>dmDevHciEvtReset</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, dm_dev.o(i.dmDevHciEvtReset))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = dmDevHciEvtReset
</UL>
<BR>[Called By]<UL><LI><a href="#[d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmDevHciHandler
</UL>

<P><STRONG><a name="[3a0]"></a>dmDevHciEvtVendorSpec</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, dm_dev.o(i.dmDevHciEvtVendorSpec))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = dmDevHciEvtVendorSpec
</UL>
<BR>[Called By]<UL><LI><a href="#[d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmDevHciHandler
</UL>

<P><STRONG><a name="[49]"></a>dmHciEvtCback</STRONG> (Thumb, 34 bytes, Stack size 8 bytes, dm_main.o(i.dmHciEvtCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = dmHciEvtCback
</UL>
<BR>[Address Reference Count : 1]<UL><LI> dm_main.o(i.DmHandlerInit)
</UL>
<P><STRONG><a name="[22e]"></a>dmScanPhyToIdx</STRONG> (Thumb, 46 bytes, Stack size 0 bytes, dm_main.o(i.dmScanPhyToIdx))
<BR><BR>[Called By]<UL><LI><a href="#[22d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmScanPhyToIdx
</UL>

<P><STRONG><a name="[3a2]"></a>dmPrivSetAddrResEnable</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, dm_priv.o(i.dmPrivSetAddrResEnable))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = dmPrivSetAddrResEnable &rArr; HciLeSetAddrResolutionEnable &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[287]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLeSetAddrResolutionEnable
</UL>
<BR>[Called By]<UL><LI><a href="#[e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmPrivHciHandler
<LI><a href="#[df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmPrivActSetAddrResEnable
</UL>

<P><STRONG><a name="[22f]"></a>dmScanSetInterval</STRONG> (Thumb, 42 bytes, Stack size 24 bytes, dm_scan.o(i.dmScanSetInterval))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = dmScanSetInterval &rArr; DmScanPhyToIdx
</UL>
<BR>[Calls]<UL><LI><a href="#[1e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskUnlock
<LI><a href="#[1e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTaskLock
<LI><a href="#[22d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmScanPhyToIdx
</UL>
<BR>[Called By]<UL><LI><a href="#[197]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmScanSetInterval
</UL>

<P><STRONG><a name="[3a3]"></a>dmScanActHciReport</STRONG> (Thumb, 100 bytes, Stack size 16 bytes, dm_scan_leg.o(i.dmScanActHciReport))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = dmScanActHciReport
</UL>
<BR>[Calls]<UL><LI><a href="#[37f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmFindAdType
</UL>
<BR>[Called By]<UL><LI><a href="#[ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmScanHciHandler
</UL>

<P><STRONG><a name="[42e]"></a>__NVIC_EnableIRQ</STRONG> (Thumb, 34 bytes, Stack size 0 bytes, port.o(i.__NVIC_EnableIRQ))
<BR><BR>[Called By]<UL><LI><a href="#[42b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortSetupTimerInterrupt
</UL>

<P><STRONG><a name="[42d]"></a>__NVIC_SetPriority</STRONG> (Thumb, 32 bytes, Stack size 8 bytes, port.o(i.__NVIC_SetPriority))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __NVIC_SetPriority
</UL>
<BR>[Called By]<UL><LI><a href="#[42b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortSetupTimerInterrupt
</UL>

<P><STRONG><a name="[6a]"></a>prvTaskExitError</STRONG> (Thumb, 42 bytes, Stack size 0 bytes, port.o(i.prvTaskExitError))
<BR>[Address Reference Count : 1]<UL><LI> port.o(i.pxPortInitialiseStack)
</UL>
<P><STRONG><a name="[266]"></a>error_check</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, hci_drv_apollo3.o(i.error_check))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = error_check
</UL>
<BR>[Called By]<UL><LI><a href="#[268]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvRadioShutdown
<LI><a href="#[1b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvRadioBoot
<LI><a href="#[3c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;hciDrvWrite
<LI><a href="#[69]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciDrvHandler
</UL>

<P><STRONG><a name="[414]"></a>smpDbAddDevice</STRONG> (Thumb, 60 bytes, Stack size 24 bytes, smp_db.o(i.smpDbAddDevice))
<BR><BR>[Stack]<UL><LI>Max Depth = 28<LI>Call Chain = smpDbAddDevice &rArr; __aeabi_memclr4
</UL>
<BR>[Calls]<UL><LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCpy
<LI><a href="#[2c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpDbRecordInUse
<LI><a href="#[160]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Called By]<UL><LI><a href="#[2be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpDbGetRecord
</UL>

<P><STRONG><a name="[2be]"></a>smpDbGetRecord</STRONG> (Thumb, 94 bytes, Stack size 32 bytes, smp_db.o(i.smpDbGetRecord))
<BR><BR>[Stack]<UL><LI>Max Depth = 60<LI>Call Chain = smpDbGetRecord &rArr; smpDbAddDevice &rArr; __aeabi_memclr4
</UL>
<BR>[Calls]<UL><LI><a href="#[15a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCmp
<LI><a href="#[159]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmHostAddrType
<LI><a href="#[175]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnPeerAddrType
<LI><a href="#[174]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnPeerAddr
<LI><a href="#[2c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpDbRecordInUse
<LI><a href="#[414]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpDbAddDevice
</UL>
<BR>[Called By]<UL><LI><a href="#[2c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpDbPairingFailed
<LI><a href="#[2c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpDbSetFailureCount
<LI><a href="#[2bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpDbGetPairingDisabledTime
<LI><a href="#[2bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpDbGetFailureCount
<LI><a href="#[2c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpDbMaxAttemptReached
</UL>

<P><STRONG><a name="[2c5]"></a>smpDbRecordInUse</STRONG> (Thumb, 34 bytes, Stack size 0 bytes, smp_db.o(i.smpDbRecordInUse))
<BR><BR>[Called By]<UL><LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpDbService
<LI><a href="#[2be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpDbGetRecord
<LI><a href="#[414]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpDbAddDevice
</UL>

<P><STRONG><a name="[2c2]"></a>smpDbStartServiceTimer</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, smp_db.o(i.smpDbStartServiceTimer))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = smpDbStartServiceTimer &rArr; WsfTimerStartMs &rArr; wsfTimerInsert &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[260]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStartMs
</UL>
<BR>[Called By]<UL><LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpDbService
<LI><a href="#[2c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpDbMaxAttemptReached
</UL>

<P><STRONG><a name="[57]"></a>smpDmConnCback</STRONG> (Thumb, 166 bytes, Stack size 16 bytes, smp_main.o(i.smpDmConnCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 108<LI>Call Chain = smpDmConnCback &rArr; smpResumeAttemptsState &rArr; SmpDbGetPairingDisabledTime &rArr; smpDbGetRecord &rArr; smpDbAddDevice &rArr; __aeabi_memclr4
</UL>
<BR>[Calls]<UL><LI><a href="#[1cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgFree
<LI><a href="#[173]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnRole
<LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
<LI><a href="#[2c9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCcbByConnId
<LI><a href="#[415]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpResumeAttemptsState
<LI><a href="#[2c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpDbSetFailureCount
<LI><a href="#[2bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpDbGetFailureCount
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smp_main.o(i.SmpHandlerInit)
</UL>
<P><STRONG><a name="[55]"></a>smpL2cCtrlCback</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, smp_main.o(i.smpL2cCtrlCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 312<LI>Call Chain = smpL2cCtrlCback &rArr; smpSendPkt &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
<LI><a href="#[40c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSendPkt
<LI><a href="#[417]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpStateIdle
<LI><a href="#[2c9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCcbByConnId
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smp_main.o(i.SmpHandlerInit)
</UL>
<P><STRONG><a name="[56]"></a>smpL2cDataCback</STRONG> (Thumb, 106 bytes, Stack size 48 bytes, smp_main.o(i.smpL2cDataCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = smpL2cDataCback &rArr; smpSmExecute
</UL>
<BR>[Calls]<UL><LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpSmExecute
<LI><a href="#[413]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCcbByHandle
</UL>
<BR>[Address Reference Count : 1]<UL><LI> smp_main.o(i.SmpHandlerInit)
</UL>
<P><STRONG><a name="[415]"></a>smpResumeAttemptsState</STRONG> (Thumb, 88 bytes, Stack size 16 bytes, smp_main.o(i.smpResumeAttemptsState))
<BR><BR>[Stack]<UL><LI>Max Depth = 92<LI>Call Chain = smpResumeAttemptsState &rArr; SmpDbGetPairingDisabledTime &rArr; smpDbGetRecord &rArr; smpDbAddDevice &rArr; __aeabi_memclr4
</UL>
<BR>[Calls]<UL><LI><a href="#[260]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStartMs
<LI><a href="#[173]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnRole
<LI><a href="#[2c9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpCcbByConnId
<LI><a href="#[2bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SmpDbGetPairingDisabledTime
</UL>
<BR>[Called By]<UL><LI><a href="#[57]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpDmConnCback
</UL>

<P><STRONG><a name="[41a]"></a>smpScCatInitiatorBdAddr</STRONG> (Thumb, 126 bytes, Stack size 16 bytes, smp_sc_act.o(i.smpScCatInitiatorBdAddr))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = smpScCatInitiatorBdAddr &rArr; BdaIsZeros &rArr; memcmp
</UL>
<BR>[Calls]<UL><LI><a href="#[1f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaIsZeros
<LI><a href="#[2bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WStrReverseCpy
<LI><a href="#[227]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnCcbById
</UL>
<BR>[Called By]<UL><LI><a href="#[11e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActDHKeyCalcF6Eb
<LI><a href="#[11d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActDHKeyCalcF6Ea
<LI><a href="#[11b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActCalcF5MacKey
<LI><a href="#[11c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActCalcF5Ltk
</UL>

<P><STRONG><a name="[41b]"></a>smpScCatResponderBdAddr</STRONG> (Thumb, 126 bytes, Stack size 16 bytes, smp_sc_act.o(i.smpScCatResponderBdAddr))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = smpScCatResponderBdAddr &rArr; BdaIsZeros &rArr; memcmp
</UL>
<BR>[Calls]<UL><LI><a href="#[1f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaIsZeros
<LI><a href="#[2bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WStrReverseCpy
<LI><a href="#[227]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dmConnCcbById
</UL>
<BR>[Called By]<UL><LI><a href="#[11e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActDHKeyCalcF6Eb
<LI><a href="#[11d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActDHKeyCalcF6Ea
<LI><a href="#[11b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActCalcF5MacKey
<LI><a href="#[11c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;smpScActCalcF5Ltk
</UL>

<P><STRONG><a name="[4c]"></a>l2cDefaultCtrlCback</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, l2c_main.o(i.l2cDefaultCtrlCback))
<BR>[Address Reference Count : 1]<UL><LI> l2c_main.o(i.L2cInit)
</UL>
<P><STRONG><a name="[4a]"></a>l2cDefaultDataCback</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, l2c_main.o(i.l2cDefaultDataCback))
<BR>[Address Reference Count : 1]<UL><LI> l2c_main.o(i.L2cInit)
</UL>
<P><STRONG><a name="[4d]"></a>l2cDefaultDataCidCback</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, l2c_main.o(i.l2cDefaultDataCidCback))
<BR>[Address Reference Count : 1]<UL><LI> l2c_main.o(i.L2cInit)
</UL>
<P><STRONG><a name="[4f]"></a>l2cHciAclCback</STRONG> (Thumb, 166 bytes, Stack size 32 bytes, l2c_main.o(i.l2cHciAclCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = l2cHciAclCback &rArr; WsfMsgFree &rArr; WsfBufFree
</UL>
<BR>[Calls]<UL><LI><a href="#[1cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgFree
</UL>
<BR>[Address Reference Count : 1]<UL><LI> l2c_main.o(i.L2cInit)
</UL>
<P><STRONG><a name="[4e]"></a>l2cHciFlowCback</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, l2c_main.o(i.l2cHciFlowCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = l2cHciFlowCback
</UL>
<BR>[Calls]<UL><LI><a href="#[348]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnIdByHandle
</UL>
<BR>[Address Reference Count : 1]<UL><LI> l2c_main.o(i.L2cInit)
</UL>
<P><STRONG><a name="[2a8]"></a>l2cSlaveReqTimeout</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, l2c_slave.o(i.l2cSlaveReqTimeout))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = l2cSlaveReqTimeout &rArr; DmL2cConnUpdateCnf &rArr; dmConnSmExecute
</UL>
<BR>[Calls]<UL><LI><a href="#[220]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmL2cConnUpdateCnf
</UL>
<BR>[Called By]<UL><LI><a href="#[63]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;L2cSlaveHandler
</UL>

<P><STRONG><a name="[50]"></a>l2cSlaveRxSignalingPkt</STRONG> (Thumb, 158 bytes, Stack size 40 bytes, l2c_slave.o(i.l2cSlaveRxSignalingPkt))
<BR><BR>[Stack]<UL><LI>Max Depth = 344<LI>Call Chain = l2cSlaveRxSignalingPkt &rArr; l2cSendCmdReject &rArr; L2cDataReq &rArr; HciSendAclData &rArr; hciCoreTxAclStart &rArr; hciCoreTxAclContinue &rArr; hciCoreSendAclData &rArr; hciTrSendAclData &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[263]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStop
<LI><a href="#[220]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmL2cConnUpdateCnf
<LI><a href="#[3d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmL2cCmdRejInd
<LI><a href="#[3d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;l2cSendCmdReject
</UL>
<BR>[Address Reference Count : 1]<UL><LI> l2c_slave.o(i.L2cSlaveInit)
</UL>
<P><STRONG><a name="[2ae]"></a>getNextToken</STRONG> (Thumb, 40 bytes, Stack size 0 bytes, sec_aes.o(i.getNextToken))
<BR><BR>[Called By]<UL><LI><a href="#[2ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecAes
</UL>

<P><STRONG><a name="[2b2]"></a>secCmacComplete</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, sec_cmac_hci.o(i.secCmacComplete))
<BR><BR>[Stack]<UL><LI>Max Depth = 168<LI>Call Chain = secCmacComplete &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
</UL>
<BR>[Called By]<UL><LI><a href="#[52]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecCmacHciCback
</UL>

<P><STRONG><a name="[2af]"></a>secCmacGenSubkey1</STRONG> (Thumb, 32 bytes, Stack size 32 bytes, sec_cmac_hci.o(i.secCmacGenSubkey1))
<BR><BR>[Stack]<UL><LI>Max Depth = 304<LI>Call Chain = secCmacGenSubkey1 &rArr; SecLeEncryptCmd &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[2bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecLeEncryptCmd
</UL>
<BR>[Called By]<UL><LI><a href="#[1f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecCmac
</UL>

<P><STRONG><a name="[2b0]"></a>secCmacGenSubkey2</STRONG> (Thumb, 100 bytes, Stack size 16 bytes, sec_cmac_hci.o(i.secCmacGenSubkey2))
<BR><BR>[Stack]<UL><LI>Max Depth = 328<LI>Call Chain = secCmacGenSubkey2 &rArr; secCmacProcessBlock &rArr; SecLeEncryptCmd &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[206]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Calc128Cpy
<LI><a href="#[2b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;secCmacProcessBlock
<LI><a href="#[402]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;secCmacKeyShift
</UL>
<BR>[Called By]<UL><LI><a href="#[52]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecCmacHciCback
</UL>

<P><STRONG><a name="[402]"></a>secCmacKeyShift</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, sec_cmac_hci.o(i.secCmacKeyShift))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = secCmacKeyShift
</UL>
<BR>[Called By]<UL><LI><a href="#[2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;secCmacGenSubkey2
</UL>

<P><STRONG><a name="[2b1]"></a>secCmacProcessBlock</STRONG> (Thumb, 122 bytes, Stack size 40 bytes, sec_cmac_hci.o(i.secCmacProcessBlock))
<BR><BR>[Stack]<UL><LI>Max Depth = 312<LI>Call Chain = secCmacProcessBlock &rArr; SecLeEncryptCmd &rArr; HciLeEncryptCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[403]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Calc128Xor
<LI><a href="#[206]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Calc128Cpy
<LI><a href="#[2bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecLeEncryptCmd
<LI><a href="#[1d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[52]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecCmacHciCback
<LI><a href="#[2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;secCmacGenSubkey2
</UL>

<P><STRONG><a name="[54]"></a>secHciCback</STRONG> (Thumb, 190 bytes, Stack size 16 bytes, sec_main.o(i.secHciCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = secHciCback &rArr; WsfMsgDeq &rArr; WsfQueueDeq
</UL>
<BR>[Calls]<UL><LI><a href="#[257]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgDeq
<LI><a href="#[404]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WStrReverse
</UL>
<BR>[Address Reference Count : 1]<UL><LI> sec_main.o(i.SecInit)
</UL>
<P><STRONG><a name="[17a]"></a>appDiscCfgStart</STRONG> (Thumb, 50 bytes, Stack size 16 bytes, app_disc.o(i.appDiscCfgStart))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = appDiscCfgStart
</UL>
<BR>[Called By]<UL><LI><a href="#[17e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscStart
<LI><a href="#[171]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscProcAttMsg
</UL>

<P><STRONG><a name="[183]"></a>appDiscConnClose</STRONG> (Thumb, 52 bytes, Stack size 16 bytes, app_disc.o(i.appDiscConnClose))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = appDiscConnClose &rArr; WsfBufFree
</UL>
<BR>[Calls]<UL><LI><a href="#[169]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetHdl
<LI><a href="#[168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfBufFree
<LI><a href="#[16b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbSetDiscStatus
</UL>
<BR>[Called By]<UL><LI><a href="#[181]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscProcDmMsg
</UL>

<P><STRONG><a name="[182]"></a>appDiscConnOpen</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, app_disc.o(i.appDiscConnOpen))
<BR><BR>[Stack]<UL><LI>Max Depth = 288<LI>Call Chain = appDiscConnOpen &rArr; appDiscStart &rArr; AttcReadByTypeReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[17e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscStart
<LI><a href="#[1d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr
</UL>
<BR>[Called By]<UL><LI><a href="#[181]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscProcDmMsg
</UL>

<P><STRONG><a name="[186]"></a>appDiscEncryptInd</STRONG> (Thumb, 68 bytes, Stack size 16 bytes, app_disc.o(i.appDiscEncryptInd))
<BR><BR>[Stack]<UL><LI>Max Depth = 288<LI>Call Chain = appDiscEncryptInd &rArr; AttcDiscConfigResume &rArr; attcDiscConfigNext &rArr; AttcWriteReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcDiscConfigResume
<LI><a href="#[17e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscStart
</UL>
<BR>[Called By]<UL><LI><a href="#[181]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscProcDmMsg
</UL>

<P><STRONG><a name="[184]"></a>appDiscPairCmpl</STRONG> (Thumb, 154 bytes, Stack size 16 bytes, app_disc.o(i.appDiscPairCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 288<LI>Call Chain = appDiscPairCmpl &rArr; AttcDiscConfigResume &rArr; attcDiscConfigNext &rArr; AttcWriteReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[169]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetHdl
<LI><a href="#[1d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcDiscConfigResume
<LI><a href="#[16a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppCheckBonded
<LI><a href="#[162]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbSetHdlList
<LI><a href="#[16b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbSetDiscStatus
<LI><a href="#[177]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbSetCacheByHash
<LI><a href="#[337]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbIsCacheCheckedByHash
<LI><a href="#[17e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appDiscStart
</UL>
<BR>[Called By]<UL><LI><a href="#[181]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscProcDmMsg
</UL>

<P><STRONG><a name="[185]"></a>appDiscPairFail</STRONG> (Thumb, 58 bytes, Stack size 24 bytes, app_disc.o(i.appDiscPairFail))
<BR><BR>[Stack]<UL><LI>Max Depth = 264<LI>Call Chain = appDiscPairFail &rArr; AttcReadByTypeReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1d3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttcReadByTypeReq
</UL>
<BR>[Called By]<UL><LI><a href="#[181]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscProcDmMsg
</UL>

<P><STRONG><a name="[191]"></a>appProcMsg</STRONG> (Thumb, 34 bytes, Stack size 8 bytes, app_main.o(i.appProcMsg))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = appProcMsg &rArr; appUiBtnPoll
</UL>
<BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appUiTimerExpired
<LI><a href="#[339]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appUiBtnPoll
</UL>
<BR>[Called By]<UL><LI><a href="#[66]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppHandler
</UL>

<P><STRONG><a name="[196]"></a>appMasterScanMode</STRONG> (Thumb, 38 bytes, Stack size 0 bytes, app_master_leg.o(i.appMasterScanMode))
<BR><BR>[Called By]<UL><LI><a href="#[195]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppScanStart
<LI><a href="#[199]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppScanStop
</UL>

<P><STRONG><a name="[1a0]"></a>appServerSetSigningInfo</STRONG> (Thumb, 60 bytes, Stack size 24 bytes, app_server.o(i.appServerSetSigningInfo))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = appServerSetSigningInfo &rArr; AttsSetSignCounter
</UL>
<BR>[Calls]<UL><LI><a href="#[169]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetHdl
<LI><a href="#[1f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsSetSignCounter
<LI><a href="#[1f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsSetCsrk
<LI><a href="#[33e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetPeerSignCounter
<LI><a href="#[148]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetKey
</UL>
<BR>[Called By]<UL><LI><a href="#[44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppServerConnCback
</UL>

<P><STRONG><a name="[335]"></a>appConnUpdateTimerStart</STRONG> (Thumb, 40 bytes, Stack size 16 bytes, app_slave.o(i.appConnUpdateTimerStart))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = appConnUpdateTimerStart &rArr; WsfTimerStartMs &rArr; wsfTimerInsert &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[260]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStartMs
</UL>
<BR>[Called By]<UL><LI><a href="#[342]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveProcConnOpen
<LI><a href="#[1b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveConnUpdateTimeout
<LI><a href="#[1af]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveConnUpdate
</UL>

<P><STRONG><a name="[1bf]"></a>appPrivAddDevToResListInd</STRONG> (Thumb, 24 bytes, Stack size 16 bytes, app_slave.o(i.appPrivAddDevToResListInd))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = appPrivAddDevToResListInd
</UL>
<BR>[Calls]<UL><LI><a href="#[1c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbSetPeerAddedToRl
</UL>
<BR>[Called By]<UL><LI><a href="#[1b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppSlaveSecProcDmMsg
</UL>

<P><STRONG><a name="[1c0]"></a>appPrivRemDevFromResListInd</STRONG> (Thumb, 24 bytes, Stack size 16 bytes, app_slave.o(i.appPrivRemDevFromResListInd))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = appPrivRemDevFromResListInd
</UL>
<BR>[Calls]<UL><LI><a href="#[1c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbSetPeerAddedToRl
</UL>
<BR>[Called By]<UL><LI><a href="#[1b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppSlaveSecProcDmMsg
</UL>

<P><STRONG><a name="[1be]"></a>appPrivSetAddrResEnableInd</STRONG> (Thumb, 20 bytes, Stack size 16 bytes, app_slave.o(i.appPrivSetAddrResEnableInd))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = appPrivSetAddrResEnableInd
</UL>
<BR>[Calls]<UL><LI><a href="#[333]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmLlPrivEnabled
<LI><a href="#[338]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SvcCoreGapCentAddrResUpdate
</UL>
<BR>[Called By]<UL><LI><a href="#[1b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppSlaveSecProcDmMsg
</UL>

<P><STRONG><a name="[1ba]"></a>appSecEncryptInd</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, app_slave.o(i.appSecEncryptInd))
<BR><BR>[Called By]<UL><LI><a href="#[1b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppSlaveSecProcDmMsg
</UL>

<P><STRONG><a name="[1bd]"></a>appSecFindLtk</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, app_slave.o(i.appSecFindLtk))
<BR><BR>[Stack]<UL><LI>Max Depth = 208<LI>Call Chain = appSecFindLtk &rArr; appSecRspLtk &rArr; DmSecLtkRsp &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[15b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbFindByLtkReq
<LI><a href="#[33b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSecRspLtk
<LI><a href="#[15c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
</UL>
<BR>[Called By]<UL><LI><a href="#[1b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppSlaveSecProcDmMsg
</UL>

<P><STRONG><a name="[1b8]"></a>appSecPairCmpl</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, app_slave.o(i.appSecPairCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 232<LI>Call Chain = appSecPairCmpl &rArr; AppAddDevToResList &rArr; DmPrivAddDevToResList &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[33d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppSetBondable
<LI><a href="#[33c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbValidateRecord
<LI><a href="#[146]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppAddDevToResList
</UL>
<BR>[Called By]<UL><LI><a href="#[1b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppSlaveSecProcDmMsg
</UL>

<P><STRONG><a name="[1b9]"></a>appSecPairFailed</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, app_slave.o(i.appSecPairFailed))
<BR><BR>[Called By]<UL><LI><a href="#[1b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppSlaveSecProcDmMsg
</UL>

<P><STRONG><a name="[1bc]"></a>appSecPairInd</STRONG> (Thumb, 164 bytes, Stack size 32 bytes, app_slave.o(i.appSecPairInd))
<BR><BR>[Stack]<UL><LI>Max Depth = 224<LI>Call Chain = appSecPairInd &rArr; DmSecPairRsp &rArr; SmpDmMsgSend &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[17f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnSecLevel
<LI><a href="#[175]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnPeerAddrType
<LI><a href="#[174]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnPeerAddr
<LI><a href="#[236]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecPairRsp
<LI><a href="#[231]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecCancelReq
<LI><a href="#[15f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbNewRecord
</UL>
<BR>[Called By]<UL><LI><a href="#[1b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppSlaveSecProcDmMsg
</UL>

<P><STRONG><a name="[33b]"></a>appSecRspLtk</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, app_slave.o(i.appSecRspLtk))
<BR><BR>[Stack]<UL><LI>Max Depth = 192<LI>Call Chain = appSecRspLtk &rArr; DmSecLtkRsp &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[235]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecLtkRsp
<LI><a href="#[148]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetKey
</UL>
<BR>[Called By]<UL><LI><a href="#[1b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveResolvedAddrInd
<LI><a href="#[1bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSecFindLtk
</UL>

<P><STRONG><a name="[1bb]"></a>appSecStoreKey</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, app_slave.o(i.appSecStoreKey))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = appSecStoreKey &rArr; AppDbSetKey
</UL>
<BR>[Calls]<UL><LI><a href="#[164]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbSetKey
</UL>
<BR>[Called By]<UL><LI><a href="#[1b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppSlaveSecProcDmMsg
</UL>

<P><STRONG><a name="[331]"></a>appSetAdvScanData</STRONG> (Thumb, 156 bytes, Stack size 24 bytes, app_slave.o(i.appSetAdvScanData))
<BR><BR>[Stack]<UL><LI>Max Depth = 248<LI>Call Chain = appSetAdvScanData &rArr; appSetAdvScanDataFrag &rArr; DmAdvSetData &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[32d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSetAdvScanDataFrag
</UL>
<BR>[Called By]<UL><LI><a href="#[153]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appConnAccept
<LI><a href="#[32e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appAdvStart
</UL>

<P><STRONG><a name="[32d]"></a>appSetAdvScanDataFrag</STRONG> (Thumb, 184 bytes, Stack size 40 bytes, app_slave.o(i.appSetAdvScanDataFrag))
<BR><BR>[Stack]<UL><LI>Max Depth = 224<LI>Call Chain = appSetAdvScanDataFrag &rArr; DmAdvSetData &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[20d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmAdvSetData
</UL>
<BR>[Called By]<UL><LI><a href="#[14d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appAdvSetData
<LI><a href="#[331]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSetAdvScanData
</UL>

<P><STRONG><a name="[1ab]"></a>appSlaveAdvModeInit</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, app_slave.o(i.appSlaveAdvModeInit))
<BR><BR>[Called By]<UL><LI><a href="#[1ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppSlaveProcDmMsg
<LI><a href="#[1aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppSlaveInit
</UL>

<P><STRONG><a name="[1ae]"></a>appSlaveConnClose</STRONG> (Thumb, 36 bytes, Stack size 16 bytes, app_slave.o(i.appSlaveConnClose))
<BR><BR>[Stack]<UL><LI>Max Depth = 208<LI>Call Chain = appSlaveConnClose &rArr; AppUpdatePrivacyMode &rArr; DmPrivSetPrivacyMode &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[1c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppUpdatePrivacyMode
<LI><a href="#[341]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveProcConnClose
</UL>
<BR>[Called By]<UL><LI><a href="#[1ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppSlaveProcDmMsg
</UL>

<P><STRONG><a name="[1ad]"></a>appSlaveConnOpen</STRONG> (Thumb, 36 bytes, Stack size 16 bytes, app_slave.o(i.appSlaveConnOpen))
<BR><BR>[Stack]<UL><LI>Max Depth = 256<LI>Call Chain = appSlaveConnOpen &rArr; DmReadRemoteFeatures &rArr; HciLeReadRemoteFeatCmd &rArr; hciCmdSend &rArr; hciTrSendCmd &rArr; hciDrvWrite &rArr; WsfSetEvent &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[226]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmReadRemoteFeatures
<LI><a href="#[342]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveProcConnOpen
</UL>
<BR>[Called By]<UL><LI><a href="#[1ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppSlaveProcDmMsg
</UL>

<P><STRONG><a name="[1af]"></a>appSlaveConnUpdate</STRONG> (Thumb, 84 bytes, Stack size 16 bytes, app_slave.o(i.appSlaveConnUpdate))
<BR><BR>[Stack]<UL><LI>Max Depth = 104<LI>Call Chain = appSlaveConnUpdate &rArr; appConnUpdateTimerStart &rArr; WsfTimerStartMs &rArr; wsfTimerInsert &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[336]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appConnUpdateTimerStop
<LI><a href="#[335]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appConnUpdateTimerStart
</UL>
<BR>[Called By]<UL><LI><a href="#[1ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppSlaveProcDmMsg
</UL>

<P><STRONG><a name="[1b2]"></a>appSlaveConnUpdateTimeout</STRONG> (Thumb, 112 bytes, Stack size 32 bytes, app_slave.o(i.appSlaveConnUpdateTimeout))
<BR><BR>[Stack]<UL><LI>Max Depth = 200<LI>Call Chain = appSlaveConnUpdateTimeout &rArr; DmConnUpdate &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[213]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnCheckIdle
<LI><a href="#[215]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnUpdate
<LI><a href="#[335]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appConnUpdateTimerStart
</UL>
<BR>[Called By]<UL><LI><a href="#[1ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppSlaveProcDmMsg
<LI><a href="#[3c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveProcMsg
</UL>

<P><STRONG><a name="[32f]"></a>appSlaveConnectableAdv</STRONG> (Thumb, 66 bytes, Stack size 8 bytes, app_slave.o(i.appSlaveConnectableAdv))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = appSlaveConnectableAdv
</UL>
<BR>[Called By]<UL><LI><a href="#[32e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appAdvStart
</UL>

<P><STRONG><a name="[340]"></a>appSlaveForceAdvDataSync</STRONG> (Thumb, 48 bytes, Stack size 12 bytes, app_slave.o(i.appSlaveForceAdvDataSync))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = appSlaveForceAdvDataSync
</UL>
<BR>[Called By]<UL><LI><a href="#[14f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveAdvStart
<LI><a href="#[341]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveProcConnClose
</UL>

<P><STRONG><a name="[341]"></a>appSlaveProcConnClose</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, app_slave.o(i.appSlaveProcConnClose))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = appSlaveProcConnClose &rArr; appConnUpdateTimerStop &rArr; WsfTimerStop &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[336]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appConnUpdateTimerStop
<LI><a href="#[340]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveForceAdvDataSync
</UL>
<BR>[Called By]<UL><LI><a href="#[1ae]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveConnClose
</UL>

<P><STRONG><a name="[342]"></a>appSlaveProcConnOpen</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, app_slave.o(i.appSlaveProcConnOpen))
<BR><BR>[Stack]<UL><LI>Max Depth = 104<LI>Call Chain = appSlaveProcConnOpen &rArr; appConnUpdateTimerStart &rArr; WsfTimerStartMs &rArr; wsfTimerInsert &rArr; wsfTimerRemove &rArr; WsfQueueRemove
</UL>
<BR>[Calls]<UL><LI><a href="#[335]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appConnUpdateTimerStart
</UL>
<BR>[Called By]<UL><LI><a href="#[1ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveConnOpen
</UL>

<P><STRONG><a name="[1b1]"></a>appSlaveRemoteConnParamReq</STRONG> (Thumb, 78 bytes, Stack size 24 bytes, app_slave.o(i.appSlaveRemoteConnParamReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 192<LI>Call Chain = appSlaveRemoteConnParamReq &rArr; DmRemoteConnParamReqReply &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[22a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmRemoteConnParamReqReply
<LI><a href="#[229]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmRemoteConnParamReqNegReply
</UL>
<BR>[Called By]<UL><LI><a href="#[1ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppSlaveProcDmMsg
</UL>

<P><STRONG><a name="[346]"></a>appSlaveResolveAddr</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, app_slave.o(i.appSlaveResolveAddr))
<BR><BR>[Stack]<UL><LI>Max Depth = 192<LI>Call Chain = appSlaveResolveAddr &rArr; DmPrivResolveAddr &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[224]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmPrivResolveAddr
<LI><a href="#[15d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetNextRecord
<LI><a href="#[148]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetKey
</UL>
<BR>[Called By]<UL><LI><a href="#[1b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveSecConnOpen
</UL>

<P><STRONG><a name="[1b0]"></a>appSlaveResolvedAddrInd</STRONG> (Thumb, 128 bytes, Stack size 24 bytes, app_slave.o(i.appSlaveResolvedAddrInd))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = appSlaveResolvedAddrInd &rArr; appSecRspLtk &rArr; DmSecLtkRsp &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[174]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnPeerAddr
<LI><a href="#[224]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmPrivResolveAddr
<LI><a href="#[15d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetNextRecord
<LI><a href="#[148]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetKey
<LI><a href="#[33b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSecRspLtk
</UL>
<BR>[Called By]<UL><LI><a href="#[1ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppSlaveProcDmMsg
</UL>

<P><STRONG><a name="[14c]"></a>appSlaveAdvMode</STRONG> (Thumb, 38 bytes, Stack size 0 bytes, app_slave_leg.o(i.appSlaveAdvMode))
<BR><BR>[Called By]<UL><LI><a href="#[14e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppAdvStart
<LI><a href="#[14b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppAdvSetData
<LI><a href="#[152]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppConnAccept
<LI><a href="#[150]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppAdvStop
</UL>

<P><STRONG><a name="[60]"></a>appSlaveLegAdvRestart</STRONG> (Thumb, 86 bytes, Stack size 8 bytes, app_slave_leg.o(i.appSlaveLegAdvRestart))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = appSlaveLegAdvRestart &rArr; appSlaveLegAdvStart &rArr; appAdvStart &rArr; appSetAdvScanData &rArr; appSetAdvScanDataFrag &rArr; DmAdvSetData &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[343]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveLegAdvStart
</UL>
<BR>[Address Reference Count : 1]<UL><LI> app_slave_leg.o(i.appSlaveAdvMode)
</UL>
<P><STRONG><a name="[343]"></a>appSlaveLegAdvStart</STRONG> (Thumb, 82 bytes, Stack size 24 bytes, app_slave_leg.o(i.appSlaveLegAdvStart))
<BR><BR>[Stack]<UL><LI>Max Depth = 312<LI>Call Chain = appSlaveLegAdvStart &rArr; appAdvStart &rArr; appSetAdvScanData &rArr; appSetAdvScanDataFrag &rArr; DmAdvSetData &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[32e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appAdvStart
</UL>
<BR>[Called By]<UL><LI><a href="#[345]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveNextLegAdvState
<LI><a href="#[344]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveLegAdvTypeChanged
<LI><a href="#[60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveLegAdvRestart
</UL>

<P><STRONG><a name="[5f]"></a>appSlaveLegAdvStop</STRONG> (Thumb, 42 bytes, Stack size 8 bytes, app_slave_leg.o(i.appSlaveLegAdvStop))
<BR><BR>[Stack]<UL><LI>Max Depth = 328<LI>Call Chain = appSlaveLegAdvStop &rArr; appSlaveNextLegAdvState &rArr; appSlaveLegAdvStart &rArr; appAdvStart &rArr; appSetAdvScanData &rArr; appSetAdvScanDataFrag &rArr; DmAdvSetData &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[345]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveNextLegAdvState
<LI><a href="#[344]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveLegAdvTypeChanged
</UL>
<BR>[Address Reference Count : 1]<UL><LI> app_slave_leg.o(i.appSlaveAdvMode)
</UL>
<P><STRONG><a name="[344]"></a>appSlaveLegAdvTypeChanged</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, app_slave_leg.o(i.appSlaveLegAdvTypeChanged))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = appSlaveLegAdvTypeChanged &rArr; appSlaveLegAdvStart &rArr; appAdvStart &rArr; appSetAdvScanData &rArr; appSetAdvScanDataFrag &rArr; DmAdvSetData &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[343]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveLegAdvStart
</UL>
<BR>[Called By]<UL><LI><a href="#[5f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveLegAdvStop
</UL>

<P><STRONG><a name="[345]"></a>appSlaveNextLegAdvState</STRONG> (Thumb, 34 bytes, Stack size 8 bytes, app_slave_leg.o(i.appSlaveNextLegAdvState))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = appSlaveNextLegAdvState &rArr; appSlaveLegAdvStart &rArr; appAdvStart &rArr; appSetAdvScanData &rArr; appSetAdvScanDataFrag &rArr; DmAdvSetData &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[343]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveLegAdvStart
</UL>
<BR>[Called By]<UL><LI><a href="#[5f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;appSlaveLegAdvStop
</UL>

<P><STRONG><a name="[3fe]"></a>prvHeapInit</STRONG> (Thumb, 42 bytes, Stack size 0 bytes, heap_2.o(i.prvHeapInit))
<BR><BR>[Called By]<UL><LI><a href="#[3fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pvPortMalloc
</UL>

<P><STRONG><a name="[446]"></a>prvTestWaitCondition</STRONG> (Thumb, 30 bytes, Stack size 8 bytes, event_groups.o(i.prvTestWaitCondition))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = prvTestWaitCondition
</UL>
<BR>[Called By]<UL><LI><a href="#[444]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xEventGroupWaitBits
</UL>

<P><STRONG><a name="[3e1]"></a>prvCopyDataFromQueue</STRONG> (Thumb, 42 bytes, Stack size 16 bytes, queue.o(i.prvCopyDataFromQueue))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = prvCopyDataFromQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[3f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueReceive
</UL>

<P><STRONG><a name="[3e2]"></a>prvCopyDataToQueue</STRONG> (Thumb, 106 bytes, Stack size 24 bytes, queue.o(i.prvCopyDataToQueue))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Called By]<UL><LI><a href="#[44d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSendFromISR
<LI><a href="#[44a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSend
</UL>

<P><STRONG><a name="[3e8]"></a>prvInitialiseNewQueue</STRONG> (Thumb, 38 bytes, Stack size 24 bytes, queue.o(i.prvInitialiseNewQueue))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = prvInitialiseNewQueue &rArr; xQueueGenericReset &rArr; xTaskRemoveFromEventList
</UL>
<BR>[Calls]<UL><LI><a href="#[3e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericReset
</UL>
<BR>[Called By]<UL><LI><a href="#[3e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericCreate
</UL>

<P><STRONG><a name="[3ef]"></a>prvIsQueueEmpty</STRONG> (Thumb, 26 bytes, Stack size 16 bytes, queue.o(i.prvIsQueueEmpty))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = prvIsQueueEmpty
</UL>
<BR>[Calls]<UL><LI><a href="#[3dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[3db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
</UL>
<BR>[Called By]<UL><LI><a href="#[3f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueReceive
</UL>

<P><STRONG><a name="[3f0]"></a>prvIsQueueFull</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, queue.o(i.prvIsQueueFull))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = prvIsQueueFull
</UL>
<BR>[Calls]<UL><LI><a href="#[3dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[3db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
</UL>
<BR>[Called By]<UL><LI><a href="#[44a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSend
</UL>

<P><STRONG><a name="[3fa]"></a>prvUnlockQueue</STRONG> (Thumb, 126 bytes, Stack size 16 bytes, queue.o(i.prvUnlockQueue))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = prvUnlockQueue &rArr; xTaskRemoveFromEventList
</UL>
<BR>[Calls]<UL><LI><a href="#[3dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[3db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
<LI><a href="#[3fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskRemoveFromEventList
<LI><a href="#[3fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskMissedYield
</UL>
<BR>[Called By]<UL><LI><a href="#[3f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueReceive
<LI><a href="#[44a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericSend
<LI><a href="#[3f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vQueueWaitForMessageRestricted
</UL>

<P><STRONG><a name="[3d6]"></a>prvAddCurrentTaskToDelayedList</STRONG> (Thumb, 100 bytes, Stack size 24 bytes, tasks.o(i.prvAddCurrentTaskToDelayedList))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = prvAddCurrentTaskToDelayedList &rArr; vListInsert
</UL>
<BR>[Calls]<UL><LI><a href="#[3d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInsertEnd
<LI><a href="#[3d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInsert
<LI><a href="#[3d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uxListRemove
</UL>
<BR>[Called By]<UL><LI><a href="#[436]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskPlaceOnEventListRestricted
<LI><a href="#[437]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskPlaceOnEventList
<LI><a href="#[438]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskPlaceOnUnorderedEventList
</UL>

<P><STRONG><a name="[3da]"></a>prvAddNewTaskToReadyList</STRONG> (Thumb, 148 bytes, Stack size 8 bytes, tasks.o(i.prvAddNewTaskToReadyList))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = prvAddNewTaskToReadyList &rArr; prvInitialiseTaskLists
</UL>
<BR>[Calls]<UL><LI><a href="#[3dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[3db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
<LI><a href="#[3dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvInitialiseTaskLists
<LI><a href="#[3d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInsertEnd
</UL>
<BR>[Called By]<UL><LI><a href="#[400]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskCreate
</UL>

<P><STRONG><a name="[3e3]"></a>prvCheckTasksWaitingTermination</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, tasks.o(i.prvCheckTasksWaitingTermination))
<BR><BR>[Called By]<UL><LI><a href="#[6d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvIdleTask
</UL>

<P><STRONG><a name="[3e4]"></a>prvGetExpectedIdleTime</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, tasks.o(i.prvGetExpectedIdleTime))
<BR><BR>[Called By]<UL><LI><a href="#[6d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvIdleTask
</UL>

<P><STRONG><a name="[6d]"></a>prvIdleTask</STRONG> (Thumb, 90 bytes, Stack size 0 bytes, tasks.o(i.prvIdleTask))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = prvIdleTask &rArr; vPortSuppressTicksAndSleep &rArr; am_hal_stimer_compare_delta_set
</UL>
<BR>[Calls]<UL><LI><a href="#[3e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortSuppressTicksAndSleep
<LI><a href="#[3e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvGetExpectedIdleTime
<LI><a href="#[3e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvCheckTasksWaitingTermination
<LI><a href="#[3e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeAll
<LI><a href="#[3e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspendAll
</UL>
<BR>[Address Reference Count : 1]<UL><LI> tasks.o(i.vTaskStartScheduler)
</UL>
<P><STRONG><a name="[3ea]"></a>prvInitialiseNewTask</STRONG> (Thumb, 166 bytes, Stack size 40 bytes, tasks.o(i.prvInitialiseNewTask))
<BR><BR>[Stack]<UL><LI>Max Depth = 40 + Unknown Stack Size
<LI>Call Chain = prvInitialiseNewTask
</UL>
<BR>[Calls]<UL><LI><a href="#[3ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pxPortInitialiseStack
<LI><a href="#[3eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInitialiseItem
<LI><a href="#[13f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memset
</UL>
<BR>[Called By]<UL><LI><a href="#[400]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskCreate
</UL>

<P><STRONG><a name="[3dc]"></a>prvInitialiseTaskLists</STRONG> (Thumb, 64 bytes, Stack size 8 bytes, tasks.o(i.prvInitialiseTaskLists))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = prvInitialiseTaskLists
</UL>
<BR>[Calls]<UL><LI><a href="#[3df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInitialise
</UL>
<BR>[Called By]<UL><LI><a href="#[3da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvAddNewTaskToReadyList
</UL>

<P><STRONG><a name="[43c]"></a>prvResetNextTaskUnblockTime</STRONG> (Thumb, 42 bytes, Stack size 0 bytes, tasks.o(i.prvResetNextTaskUnblockTime))
<BR><BR>[Called By]<UL><LI><a href="#[2d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskIncrementTick
<LI><a href="#[405]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspend
<LI><a href="#[3fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskRemoveFromEventList
<LI><a href="#[3e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeAll
</UL>

<P><STRONG><a name="[3de]"></a>prvCheckForValidListAndQueue</STRONG> (Thumb, 56 bytes, Stack size 8 bytes, timers.o(i.prvCheckForValidListAndQueue))
<BR><BR>[Stack]<UL><LI>Max Depth = 104<LI>Call Chain = prvCheckForValidListAndQueue &rArr; xQueueGenericCreate &rArr; pvPortMalloc &rArr; xTaskResumeAll &rArr; xTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[3dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortExitCritical
<LI><a href="#[3db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortEnterCritical
<LI><a href="#[3e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueGenericCreate
<LI><a href="#[3df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInitialise
</UL>
<BR>[Called By]<UL><LI><a href="#[3ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvInitialiseNewTimer
<LI><a href="#[43a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTimerCreateTimerTask
</UL>

<P><STRONG><a name="[3f9]"></a>prvGetNextExpireTime</STRONG> (Thumb, 36 bytes, Stack size 0 bytes, timers.o(i.prvGetNextExpireTime))
<BR><BR>[Called By]<UL><LI><a href="#[6e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvTimerTask
</UL>

<P><STRONG><a name="[3ed]"></a>prvInitialiseNewTimer</STRONG> (Thumb, 60 bytes, Stack size 32 bytes, timers.o(i.prvInitialiseNewTimer))
<BR><BR>[Stack]<UL><LI>Max Depth = 136<LI>Call Chain = prvInitialiseNewTimer &rArr; prvCheckForValidListAndQueue &rArr; xQueueGenericCreate &rArr; pvPortMalloc &rArr; xTaskResumeAll &rArr; xTaskIncrementTick
</UL>
<BR>[Calls]<UL><LI><a href="#[3de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvCheckForValidListAndQueue
<LI><a href="#[3eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInitialiseItem
</UL>
<BR>[Called By]<UL><LI><a href="#[2e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTimerCreate
</UL>

<P><STRONG><a name="[3ee]"></a>prvInsertTimerInActiveList</STRONG> (Thumb, 80 bytes, Stack size 24 bytes, timers.o(i.prvInsertTimerInActiveList))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = prvInsertTimerInActiveList &rArr; vListInsert
</UL>
<BR>[Calls]<UL><LI><a href="#[3d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInsert
</UL>
<BR>[Called By]<UL><LI><a href="#[3f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvProcessReceivedCommands
<LI><a href="#[3f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvProcessExpiredTimer
</UL>

<P><STRONG><a name="[3f1]"></a>prvProcessExpiredTimer</STRONG> (Thumb, 76 bytes, Stack size 24 bytes, timers.o(i.prvProcessExpiredTimer))
<BR><BR>[Stack]<UL><LI>Max Depth = 176<LI>Call Chain = prvProcessExpiredTimer &rArr; xTimerGenericCommand &rArr; xQueueGenericSend &rArr; vTaskPlaceOnEventList &rArr; prvAddCurrentTaskToDelayedList &rArr; vListInsert
</UL>
<BR>[Calls]<UL><LI><a href="#[2ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTimerGenericCommand
<LI><a href="#[3ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvInsertTimerInActiveList
<LI><a href="#[3d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uxListRemove
</UL>
<BR>[Called By]<UL><LI><a href="#[3f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvProcessTimerOrBlockTask
</UL>

<P><STRONG><a name="[3f2]"></a>prvProcessReceivedCommands</STRONG> (Thumb, 228 bytes, Stack size 48 bytes, timers.o(i.prvProcessReceivedCommands))
<BR><BR>[Stack]<UL><LI>Max Depth = 248<LI>Call Chain = prvProcessReceivedCommands &rArr; prvSampleTimeNow &rArr; prvSwitchTimerLists &rArr; xTimerGenericCommand &rArr; xQueueGenericSend &rArr; vTaskPlaceOnEventList &rArr; prvAddCurrentTaskToDelayedList &rArr; vListInsert
</UL>
<BR>[Calls]<UL><LI><a href="#[2ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTimerGenericCommand
<LI><a href="#[3f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvSampleTimeNow
<LI><a href="#[3ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvInsertTimerInActiveList
<LI><a href="#[3f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xQueueReceive
<LI><a href="#[3d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uxListRemove
<LI><a href="#[3f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vPortFree
</UL>
<BR>[Called By]<UL><LI><a href="#[6e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvTimerTask
</UL>

<P><STRONG><a name="[3f6]"></a>prvProcessTimerOrBlockTask</STRONG> (Thumb, 102 bytes, Stack size 24 bytes, timers.o(i.prvProcessTimerOrBlockTask))
<BR><BR>[Stack]<UL><LI>Max Depth = 224<LI>Call Chain = prvProcessTimerOrBlockTask &rArr; prvSampleTimeNow &rArr; prvSwitchTimerLists &rArr; xTimerGenericCommand &rArr; xQueueGenericSend &rArr; vTaskPlaceOnEventList &rArr; prvAddCurrentTaskToDelayedList &rArr; vListInsert
</UL>
<BR>[Calls]<UL><LI><a href="#[3f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvSampleTimeNow
<LI><a href="#[3f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvProcessExpiredTimer
<LI><a href="#[3f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vQueueWaitForMessageRestricted
<LI><a href="#[3e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskResumeAll
<LI><a href="#[3e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vTaskSuspendAll
</UL>
<BR>[Called By]<UL><LI><a href="#[6e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvTimerTask
</UL>

<P><STRONG><a name="[3f3]"></a>prvSampleTimeNow</STRONG> (Thumb, 40 bytes, Stack size 16 bytes, timers.o(i.prvSampleTimeNow))
<BR><BR>[Stack]<UL><LI>Max Depth = 200<LI>Call Chain = prvSampleTimeNow &rArr; prvSwitchTimerLists &rArr; xTimerGenericCommand &rArr; xQueueGenericSend &rArr; vTaskPlaceOnEventList &rArr; prvAddCurrentTaskToDelayedList &rArr; vListInsert
</UL>
<BR>[Calls]<UL><LI><a href="#[2ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTaskGetTickCount
<LI><a href="#[3f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvSwitchTimerLists
</UL>
<BR>[Called By]<UL><LI><a href="#[3f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvProcessTimerOrBlockTask
<LI><a href="#[3f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvProcessReceivedCommands
</UL>

<P><STRONG><a name="[3f8]"></a>prvSwitchTimerLists</STRONG> (Thumb, 132 bytes, Stack size 32 bytes, timers.o(i.prvSwitchTimerLists))
<BR><BR>[Stack]<UL><LI>Max Depth = 184<LI>Call Chain = prvSwitchTimerLists &rArr; xTimerGenericCommand &rArr; xQueueGenericSend &rArr; vTaskPlaceOnEventList &rArr; prvAddCurrentTaskToDelayedList &rArr; vListInsert
</UL>
<BR>[Calls]<UL><LI><a href="#[2ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xTimerGenericCommand
<LI><a href="#[3d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vListInsert
<LI><a href="#[3d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uxListRemove
</UL>
<BR>[Called By]<UL><LI><a href="#[3f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvSampleTimeNow
</UL>

<P><STRONG><a name="[6e]"></a>prvTimerTask</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, timers.o(i.prvTimerTask))
<BR><BR>[Stack]<UL><LI>Max Depth = 256<LI>Call Chain = prvTimerTask &rArr; prvProcessReceivedCommands &rArr; prvSampleTimeNow &rArr; prvSwitchTimerLists &rArr; xTimerGenericCommand &rArr; xQueueGenericSend &rArr; vTaskPlaceOnEventList &rArr; prvAddCurrentTaskToDelayedList &rArr; vListInsert
</UL>
<BR>[Calls]<UL><LI><a href="#[3f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvProcessTimerOrBlockTask
<LI><a href="#[3f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvProcessReceivedCommands
<LI><a href="#[3f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prvGetNextExpireTime
</UL>
<BR>[Address Reference Count : 1]<UL><LI> timers.o(i.xTimerCreateTimerTask)
</UL>
<P><STRONG><a name="[323]"></a>decstr_to_int</STRONG> (Thumb, 66 bytes, Stack size 12 bytes, am_util_stdio.o(i.decstr_to_int))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = decstr_to_int
</UL>
<BR>[Called By]<UL><LI><a href="#[322]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_vsprintf
</UL>

<P><STRONG><a name="[3d5]"></a>divu64_10</STRONG> (Thumb, 204 bytes, Stack size 36 bytes, am_util_stdio.o(i.divu64_10))
<BR><BR>[Stack]<UL><LI>Max Depth = 36<LI>Call Chain = divu64_10
</UL>
<BR>[Called By]<UL><LI><a href="#[329]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uint64_to_str
<LI><a href="#[328]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ndigits_in_u64
</UL>

<P><STRONG><a name="[32c]"></a>ftoa</STRONG> (Thumb, 370 bytes, Stack size 64 bytes, am_util_stdio.o(i.ftoa))
<BR><BR>[Stack]<UL><LI>Max Depth = 164<LI>Call Chain = ftoa &rArr; uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[329]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uint64_to_str
</UL>
<BR>[Called By]<UL><LI><a href="#[322]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_vsprintf
</UL>

<P><STRONG><a name="[326]"></a>ndigits_in_hex</STRONG> (Thumb, 52 bytes, Stack size 12 bytes, am_util_stdio.o(i.ndigits_in_hex))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = ndigits_in_hex
</UL>
<BR>[Called By]<UL><LI><a href="#[322]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_vsprintf
</UL>

<P><STRONG><a name="[32a]"></a>ndigits_in_i64</STRONG> (Thumb, 36 bytes, Stack size 16 bytes, am_util_stdio.o(i.ndigits_in_i64))
<BR><BR>[Stack]<UL><LI>Max Depth = 68<LI>Call Chain = ndigits_in_i64 &rArr; ndigits_in_u64 &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[328]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ndigits_in_u64
</UL>
<BR>[Called By]<UL><LI><a href="#[322]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_vsprintf
</UL>

<P><STRONG><a name="[328]"></a>ndigits_in_u64</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, am_util_stdio.o(i.ndigits_in_u64))
<BR><BR>[Stack]<UL><LI>Max Depth = 52<LI>Call Chain = ndigits_in_u64 &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[3d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;divu64_10
</UL>
<BR>[Called By]<UL><LI><a href="#[322]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_vsprintf
<LI><a href="#[32a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ndigits_in_i64
</UL>

<P><STRONG><a name="[325]"></a>padbuffer</STRONG> (Thumb, 34 bytes, Stack size 12 bytes, am_util_stdio.o(i.padbuffer))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = padbuffer
</UL>
<BR>[Called By]<UL><LI><a href="#[322]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_vsprintf
</UL>

<P><STRONG><a name="[324]"></a>simple_strlen</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, am_util_stdio.o(i.simple_strlen))
<BR><BR>[Called By]<UL><LI><a href="#[322]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_vsprintf
</UL>

<P><STRONG><a name="[327]"></a>uint64_to_hexstr</STRONG> (Thumb, 138 bytes, Stack size 44 bytes, am_util_stdio.o(i.uint64_to_hexstr))
<BR><BR>[Stack]<UL><LI>Max Depth = 44<LI>Call Chain = uint64_to_hexstr
</UL>
<BR>[Called By]<UL><LI><a href="#[322]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_vsprintf
</UL>

<P><STRONG><a name="[329]"></a>uint64_to_str</STRONG> (Thumb, 112 bytes, Stack size 64 bytes, am_util_stdio.o(i.uint64_to_str))
<BR><BR>[Stack]<UL><LI>Max Depth = 100<LI>Call Chain = uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[3d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;divu64_10
</UL>
<BR>[Called By]<UL><LI><a href="#[322]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_vsprintf
<LI><a href="#[32c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ftoa
</UL>

<P><STRONG><a name="[373]"></a>beaconScannerAlert</STRONG> (Thumb, 38 bytes, Stack size 8 bytes, beaconscanner_main.o(i.beaconScannerAlert))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = beaconScannerAlert &rArr; AppUiAction
</UL>
<BR>[Calls]<UL><LI><a href="#[190]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppUiAction
</UL>
<BR>[Called By]<UL><LI><a href="#[48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerIasWriteCback
<LI><a href="#[377]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerClose
</UL>

<P><STRONG><a name="[43]"></a>beaconScannerAttCback</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, beaconscanner_main.o(i.beaconScannerAttCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 168<LI>Call Chain = beaconScannerAttCback &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy
</UL>
<BR>[Address Reference Count : 1]<UL><LI> beaconscanner_main.o(i.BeaconScannerStart)
</UL>
<P><STRONG><a name="[46]"></a>beaconScannerBtnCback</STRONG> (Thumb, 254 bytes, Stack size 24 bytes, beaconscanner_main.o(i.beaconScannerBtnCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 392<LI>Call Chain = beaconScannerBtnCback &rArr; AppAdvStart &rArr; appSlaveAdvStart &rArr; appAdvStart &rArr; appSetAdvScanData &rArr; appSetAdvScanDataFrag &rArr; DmAdvSetData &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[147]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HciLlPrivacySupported
<LI><a href="#[333]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmLlPrivEnabled
<LI><a href="#[223]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmPrivClearResList
<LI><a href="#[216]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmDevPrivStart
<LI><a href="#[21c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmDevWhiteListClear
<LI><a href="#[21a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmDevWhiteListAdd
<LI><a href="#[217]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmDevSetFilterPolicy
<LI><a href="#[175]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnPeerAddrType
<LI><a href="#[174]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmConnPeerAddr
<LI><a href="#[225]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmPrivSetAddrResEnable
<LI><a href="#[33d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppSetBondable
<LI><a href="#[374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppConnIsOpen
<LI><a href="#[154]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppConnClose
<LI><a href="#[14e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppAdvStart
<LI><a href="#[375]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbDeleteAllRecords
<LI><a href="#[376]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SvcCoreGapAddRpaoCh
<LI><a href="#[152]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppConnAccept
<LI><a href="#[150]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppAdvStop
<LI><a href="#[24c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FmplSendAlert
</UL>
<BR>[Address Reference Count : 1]<UL><LI> beaconscanner_main.o(i.BeaconScannerStart)
</UL>
<P><STRONG><a name="[45]"></a>beaconScannerCccCback</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, beaconscanner_main.o(i.beaconScannerCccCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 168<LI>Call Chain = beaconScannerCccCback &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[169]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetHdl
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
<LI><a href="#[1a3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbSetCccTblValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> beaconscanner_main.o(i.BeaconScannerStart)
</UL>
<P><STRONG><a name="[377]"></a>beaconScannerClose</STRONG> (Thumb, 42 bytes, Stack size 16 bytes, beaconscanner_main.o(i.beaconScannerClose))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = beaconScannerClose &rArr; AttsGetAttr &rArr; attsFindByHandle
</UL>
<BR>[Calls]<UL><LI><a href="#[1ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsGetAttr
<LI><a href="#[373]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerAlert
</UL>
<BR>[Called By]<UL><LI><a href="#[1f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerProcMsg
</UL>

<P><STRONG><a name="[47]"></a>beaconScannerDiscCback</STRONG> (Thumb, 222 bytes, Stack size 24 bytes, beaconscanner_main.o(i.beaconScannerDiscCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 352<LI>Call Chain = beaconScannerDiscCback &rArr; GattDiscover &rArr; AppDiscFindService &rArr; AttcDiscService &rArr; AttcFindByTypeValueReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[250]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GattDiscover
<LI><a href="#[24d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GapDiscover
<LI><a href="#[378]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscSetHdlList
<LI><a href="#[16c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscConfigure
<LI><a href="#[166]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDiscComplete
<LI><a href="#[1c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppSlaveSecurityReq
<LI><a href="#[24b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FmplIasDiscover
<LI><a href="#[379]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerDiscGapCmpl
</UL>
<BR>[Address Reference Count : 1]<UL><LI> beaconscanner_main.o(i.BeaconScannerStart)
</UL>
<P><STRONG><a name="[379]"></a>beaconScannerDiscGapCmpl</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, beaconscanner_main.o(i.beaconScannerDiscGapCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = beaconScannerDiscGapCmpl
</UL>
<BR>[Calls]<UL><LI><a href="#[169]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetHdl
<LI><a href="#[37a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbSetPeerRpao
</UL>
<BR>[Called By]<UL><LI><a href="#[47]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerDiscCback
</UL>

<P><STRONG><a name="[42]"></a>beaconScannerDmCback</STRONG> (Thumb, 60 bytes, Stack size 16 bytes, beaconscanner_main.o(i.beaconScannerDmCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 168<LI>Call Chain = beaconScannerDmCback &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgAlloc
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfMsgSend
<LI><a href="#[37b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSizeOfEvt
<LI><a href="#[237]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecSetEccKey
<LI><a href="#[13e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4
</UL>
<BR>[Address Reference Count : 1]<UL><LI> beaconscanner_main.o(i.BeaconScannerStart)
</UL>
<P><STRONG><a name="[48]"></a>beaconScannerIasWriteCback</STRONG> (Thumb, 30 bytes, Stack size 32 bytes, beaconscanner_main.o(i.beaconScannerIasWriteCback))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = beaconScannerIasWriteCback &rArr; beaconScannerAlert &rArr; AppUiAction
</UL>
<BR>[Calls]<UL><LI><a href="#[373]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerAlert
</UL>
<BR>[Address Reference Count : 1]<UL><LI> beaconscanner_main.o(i.BeaconScannerStart)
</UL>
<P><STRONG><a name="[37c]"></a>beaconScannerOpen</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, beaconscanner_main.o(i.beaconScannerOpen))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = beaconScannerOpen
</UL>
<BR>[Calls]<UL><LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCpy
</UL>
<BR>[Called By]<UL><LI><a href="#[1f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerProcMsg
</UL>

<P><STRONG><a name="[1f8]"></a>beaconScannerProcMsg</STRONG> (Thumb, 352 bytes, Stack size 16 bytes, beaconscanner_main.o(i.beaconScannerProcMsg))
<BR><BR>[Stack]<UL><LI>Max Depth = 772<LI>Call Chain = beaconScannerProcMsg &rArr; DmSecGenerateEccKeyReq &rArr; SecEccGenKey &rArr; uECC_make_key &rArr; EccPoint_compute_public_key &rArr; EccPoint_mult &rArr; XYcZ_initial_double &rArr; EccPoint_double_jacobian &rArr; vli_modSquare_fast &rArr; vli_square &rArr; mul2add
</UL>
<BR>[Calls]<UL><LI><a href="#[2a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStartSec
<LI><a href="#[260]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WsfTimerStartMs
<LI><a href="#[37f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmFindAdType
<LI><a href="#[1e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AttsCalculateDbHash
<LI><a href="#[233]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmSecGenerateEccKeyReq
<LI><a href="#[190]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppUiAction
<LI><a href="#[18c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppHandlePasskey
<LI><a href="#[188]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppHandleNumericComparison
<LI><a href="#[374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppConnIsOpen
<LI><a href="#[14e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppAdvStart
<LI><a href="#[381]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppUiDisplayRssi
<LI><a href="#[195]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppScanStart
<LI><a href="#[199]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppScanStop
<LI><a href="#[37d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerValueUpdate
<LI><a href="#[37e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerSetup
<LI><a href="#[380]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerSecPairCmpl
<LI><a href="#[37c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerOpen
<LI><a href="#[377]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerClose
<LI><a href="#[15c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcmp
</UL>
<BR>[Called By]<UL><LI><a href="#[67]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BeaconScannerHandler
</UL>

<P><STRONG><a name="[380]"></a>beaconScannerSecPairCmpl</STRONG> (Thumb, 60 bytes, Stack size 16 bytes, beaconscanner_main.o(i.beaconScannerSecPairCmpl))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = beaconScannerSecPairCmpl &rArr; AppDbGetKey
</UL>
<BR>[Calls]<UL><LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BdaCpy
<LI><a href="#[333]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DmLlPrivEnabled
<LI><a href="#[148]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppDbGetKey
</UL>
<BR>[Called By]<UL><LI><a href="#[1f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerProcMsg
</UL>

<P><STRONG><a name="[37e]"></a>beaconScannerSetup</STRONG> (Thumb, 52 bytes, Stack size 8 bytes, beaconscanner_main.o(i.beaconScannerSetup))
<BR><BR>[Stack]<UL><LI>Max Depth = 376<LI>Call Chain = beaconScannerSetup &rArr; AppAdvStart &rArr; appSlaveAdvStart &rArr; appAdvStart &rArr; appSetAdvScanData &rArr; appSetAdvScanDataFrag &rArr; DmAdvSetData &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[14e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppAdvStart
<LI><a href="#[14b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AppAdvSetData
</UL>
<BR>[Called By]<UL><LI><a href="#[1f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerProcMsg
</UL>

<P><STRONG><a name="[37d]"></a>beaconScannerValueUpdate</STRONG> (Thumb, 40 bytes, Stack size 8 bytes, beaconscanner_main.o(i.beaconScannerValueUpdate))
<BR><BR>[Stack]<UL><LI>Max Depth = 352<LI>Call Chain = beaconScannerValueUpdate &rArr; GattValueUpdate &rArr; AppDiscServiceChanged &rArr; appDiscRestartDiscovery &rArr; appDiscStart &rArr; AttcReadByTypeReq &rArr; attcSendMsg &rArr; WsfMsgSend &rArr; WsfTaskSetReady &rArr; WsfSetOsSpecificEvent &rArr; xTimerPendFunctionCallFromISR &rArr; xQueueGenericSendFromISR &rArr; prvCopyDataToQueue
</UL>
<BR>[Calls]<UL><LI><a href="#[251]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GattValueUpdate
<LI><a href="#[24e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GapValueUpdate
</UL>
<BR>[Called By]<UL><LI><a href="#[1f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;beaconScannerProcMsg
</UL>

<P><STRONG><a name="[309]"></a>am_hal_ble_cmd_write</STRONG> (Thumb, 142 bytes, Stack size 4 bytes, am_hal_ble.o(i.am_hal_ble_cmd_write))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = am_hal_ble_cmd_write
</UL>
<BR>[Called By]<UL><LI><a href="#[304]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ble_blocking_transfer
</UL>
<P>
<H3>
Undefined Global Symbols
</H3><HR></body></html>
